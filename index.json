[{"content":"需要更早的更新或需要修正请联系我。\n一些无关紧要的更新不会写，部分更新会加上个人看法。\n初来建议从下往上读，下面的一些专有名词在上面不做解释。\n【20250227】神使询问更新 现在你可以询问神使某个花瓣将在何时上架商店。\n询问格式：\nOracle, oracle, make me a prediction about 品质名 花瓣全名 询问格式大小写不敏感（你可以任意变化其中单词的大小写）。\n暂不确定英文询问的品质名与花瓣全名能否为中文。\n在翻译更新后可以用其他语言来询问。\n神使回答：\nIt is imminent（即将发生的）：商店刷新一次后。 Soon：商店刷新两次后。 Eventually（最后，终于）：商店刷新三次后。 Perhaps some futures are just indeterminate（不确定的）：商店刷新四次或更多次后。 The future is too cloudy to tell：商店不会上架这个花瓣。 同一个服务器内的神使只会如实回答二十个小时内（也就是一次商店刷新周期内）的第一个询问的玩家，在这个时间段内，如果已经有玩家询问过神使了（不论是什么花瓣），那么神使对任何询问都只会回答永不上架。\n游戏更新后服务器重启，所以也可以在此时进行询问。\n补充：\n碎片不能拿来与商人交易硬币。 M28说商店下一次上架SMimic（拟态）是在商店刷新 $48$ 次后，打折-10%的在刷新 $706$ 次后，打折-50%的在刷新 $862$ 次后。 【20250226】总结前几次更新 现在的地图：\n目前为止所有的配方：\n10空气 $\\to$ 泡泡 月石 $\\to$ 10岩石 3电池 $\\to$ 电池+闪电 玻璃 $\\to$ 沙子 3蜂蜜 $\\to$ 蜂蜡 玻璃+电池+灯泡 $\\to$ 2激光器 碎片+磁铁+玻璃 $\\to$ 指南针 叶子+铀 $\\to$ 龟背竹 触角+灯泡 $\\to$ 机械触角 罗勒 $\\to$ 叶子 轻+玫瑰 $\\to$ 大丽花 触角+电池 $\\to$ 2机械导弹 龟背竹 $\\to$ 叶子 轻+蜂蜜 $\\to$ 花粉 齿轮 $\\to$ 碎片 电池 $\\to$ 碎片 沙子 $\\to$ 玻璃 100万岩石 $\\to$ 月石 【20250226】杂项更新 花朵：\n玩家的质量现在根据花朵的半径变化得更快。 解释一下：质量是决定该生物是否能被另外一个生物推动的重要因素，与真实世界类似。 堵门大佬狂喜。 生物：\n机械螃蟹的激光似乎变短了。 NPC：\n新Assemble配方： 100万岩石 $\\to$ 月石 没用，有这时间早就掉出来了 电池 $\\to$ 碎片 沙子 $\\to$ 玻璃 更改Assemble配方： 碎片+磁铁+玻璃 $\\to$ 指南针（之前不需要玻璃） 齿轮 $\\to$ 碎片（之前需要2齿轮） 用户界面：\n训练假人的伤害每秒信息的数字现在像其他地方一样缩写了，按住Alt键（苹果为Option键）以展开。 修复：训练假人的伤害每秒信息终于能被翻译了。 【20250225】工厂细节更改 工厂位置：\n目前两个队伍内的公会和玩家：\n（对于不在上表中的公会/玩家，会为你随机分配左右队伍，可以通过加入/退出公会来改变这一点）\n由于Assembler的特性，现有一些曾经无法获取的花瓣现在可以获取：\nMythic 指南针 Rare $\\sim$ Legendary 机械导弹 Rare $\\sim$ Epic 龟背竹 Common 闪电 Common 大丽花 注：Common Assembler 十分罕见，因此很难换 Common 闪电/大丽花 新Assemble配方：\n轻+蜂蜜 $\\to$ 花粉（Pollen） 2齿轮 $\\to$ 碎片 更改Assemble配方：\n月石 $\\to$ 10岩石（之前是25岩石） 生物：\n工厂生物与自然生物互不共戴天。（不知道啥意思，估计是意为敌对） 低稀有度的铀桶不会掉落任何花瓣。 【20250225】杂项更新 用户界面：\n状态栏：移除了神秘的粉末图标。 Assemble界面：添加了数字输入框。 【20250224】工厂正式更新 警告：前方信息量巨大。\n更新日志 添加了工厂。还有很多东西需要添加，但玩家现在就可以开始玩了。 Added Factory. There\u0026rsquo;s still more things that need to be added, but it\u0026rsquo;s at a point where players can start playing it. 工厂群系特性 Factory群系有两个传送门，分别对应着两个队伍，任意一个队伍看敌方队伍都是灰色的花花，也就是说没有敌方队伍在你的眼中一定是灰色的（怀疑笔误了）。 分队由两点决定，分别是：\n同公会者一定在同一队伍。且每个公会都只能在一个队伍。 你只能通过加入敌方的任意一公会以达到切换队伍的效果。也就是说，一般情况下你将无法切换队伍。 新生物 Mecha Wasp：可发射追踪导弹，除护甲稍高之外并无不同，掉落Mecha Missile和Mecha Ante和Battery。 Mecha Spider：无毒伤，伤害为电伤，下个版本中其发射的Web将会变化或者消失，剩余特性与普通蜘蛛一致，掉落Fragment和Battery。 Barrel：靠近会有毒伤，掉落Uranium和Fragment。 Mecha Crab：发射激光，激光为电伤，激光攻击也有范围和射程，掉落Laser和Battery。 Mecha Flower：与Gambler类似，但是仅装备Cog，不再装备Light，掉落Cog和Battery，极低概率掉落Mimic。 新NPC 更新新NPC，Assembler（可以翻译为“装配者”）。\n可以分裂或者合成，甚至可以转化。比如：A $\\to$ B+C，A+B $\\to$ C，A+B $\\to$ C+D。Assembler有不同的品质（稀有度），一个品质的Assembler只能装配（Assemble的意思）与其相同品质的花瓣，且不能装配魔法花瓣，装配的低于u品质的Compass在下一个版本会被禁用，虽然还能装配出来，但是装备后的低品质Compass图案将会是被毁坏的样子（颜色灰色）。SMoon被装配至SRock时会有多条警告。且只有9个Assemblers，并一定是不同品质的，每 $10$ 到 $60$ 分钟 Assemblers都会重生至原先的位置。一个Assembler在一定时间内只会有一种配方，这个时间取决于Assembler何时重生。\n使你可以通过Assemble（可以翻译为“装配”）来转化花瓣，目前已知配方：\n10空气 $\\to$ 泡泡 月石 $\\to$ 岩石 3电池 $\\to$ 电池+闪电 玻璃 $\\to$ 沙子 3蜂蜜 $\\to$ 蜂蜡 玻璃+电池+灯泡 $\\to$ 2激光器 碎片+磁铁 $\\to$ 指南针 叶子+铀 $\\to$ 龟背竹 触角+灯泡 $\\to$ 机械触角 罗勒 $\\to$ 叶子 轻（Light）+玫瑰 $\\to$ 大丽花（Dahlia） 触角+电池 $\\to$ 2机械导弹 龟背竹 $\\to$ 叶子 新花瓣 Mecha Missile：装备较Mecha Missile同品质的Mecha Antennae才能正常发挥作用，其作用是可以追踪敌人，具体信息待补充。 Mecha Antennae：使与Mecha Antennae同一个品质的Mecha Missile能正常发挥作用，具体信息待补充。 Cog：见这里。 Mimic：还不知道的线下问。 Fragment：见这里。 Laser：由Mecha Crab掉落，电伤伤害，具体信息待补充。 【20250224】杂项更新 生物战利品调整：\nSoldier Fire Ant（火兵蚁）掉落物Privet（女贞子）改为Bone（骨头） Soldier Termite（火兵蚁）掉落物Bone（骨头）改为Privet（女贞子） @靳王晨凯 不要想着去白蚁穴练撞击流然后拿一堆Bone了。 Fire Queen Ant（火蚁后）掉落物Fragment（碎片）改为掉落Basil（罗勒） 无Basil玩家有救了（？） Mecha Spider（机械蜘蛛）新增掉落物Fragment（碎片） 新花瓣属性：\n损坏（Broken） 神话及以下的指南针具有此属性 意思是没法使用，在下个版本中将会删除 用户界面：\n生物图鉴中Gambler（赌徒）有了五片花瓣 状态栏新增Sponge（海绵）图标 【20250222】状态栏更新 省流：终于可以显示sc（Second Chance）冷却了，撞击流玩家有福了。\n官方群已经说得足够清楚了，直接粘贴。\n状态栏在卡槽正上方，目前已知会显示的图案和状态分别如下：\nDandelion图案：减少回血 Web图案：Web减速 Second Chance图案: Second Chance冷却 Monstera图案：回血 毒伤天赋图案：毒伤 Uranium图案：铀伤害 Powder图案：Powder快速移动 Bur图案：破盾 Scorpion踩到Web图案：Pincer减速（不知道啥意思） 一些状态会显示还有多长时间结束和一些数值，表现形式为状态栏上的数字和状态边框上的黑色圆环状进度条。\n更新：\n会显示的：粉末、铀、中毒、网、螫针、龟背竹、sc、sc冷却、刺果、蒲公英、铲子、传奇四叶草（怪死亡的时候装备有1%概率多判一次掉落）、腐化 【20250221】齿轮更新 更新新花瓣Cog（齿轮）。\n伤害和同等级Leaf一样，耐久和伤害一样，可以使装备的所有花瓣周期性暂时停止一段时间。\n关于用途，维基百科上这么写的：\n齿轮搭配跑图装，可以提升跑图效率。 对于阴阳泡：它因为它的特性，你可以减少阴阳切换频率但能更稳定地向某个方向移动。 对于机关泡：更稳定地指向鼠标方向移动。 【20250220】Mark更新 现在被Mark后必须在地狱待上一段时间才能去其他地图，时间与最终作用效果的Mark的等级有关。\n【20250220】龟背竹更新 咋天天更新……\n更新新花瓣Monstera（别称Monsters，龟背竹）。\n外貌很抽象，只有耐久没有伤害，可以给范围内玩家加血，相当于反方向的钟反效果的铀。\n最高回血在Leaf和Yucca之间，更偏Leaf。\n不可堆叠。\n【20250218~20250219】金叶更新 更新新花瓣Golden Leaf（简称gl，金叶）。\n数据和同等级Leaf一样，但不能回血，可以减花瓣的冷却时间，似乎也可以减自己的（待确认），最低等级是u，u减19.2%，s减21.6%，q减24%。\n可以由u+的Bush（灌木丛）掉落，掉率低的离谱（跟Moon一样），据说现在仍然可以掉落（待确认）。\n现在还可以通过新生物闪亮叶虫掉落，该生物刷新率和Shiny（金瓢虫的简写）一样，数据和普通叶虫一样，gl掉率和普通叶虫掉落叶子的概率一样。\n【20250214】蜂蜡更新 更新新花瓣Wax（蜂蜡）。\n没有伤害，耐久特别高（是同等级Honey的 $40$ 倍），体积特别大，冷却特别长（30s）。\n不可堆叠（如果装备多个只能加载最高等级的）。\n可以被玩家推动，但不能勾引生物（与Honey区分开）。\n关于用途，维基百科上这么写的：\n大量生成用来抵挡生物潮 也可以弹飞敌人的子弹 可以用来挡刀 似乎可以当低配版月石？ 【20250210】多倍掉落更新 现在可以在商店的“Bonus”页面领取多倍掉落，每天领取一次，时长1h。\n连续登录并领取才可以保持上面那个环的进度。\n到第七天的时候可以领取三倍掉落，随后重置（推测）。\n建议把下面的Auto关了，否则会白白浪费1h的双倍或者三倍掉落。\n如果你是20250210后第一天上florr，且不想浪费第一次的1h双倍掉落，可以这么做：（仅限电脑端，移动端不知道怎么操作）\n打开florr。 按下F12或者Ctrl+Shift+I。 点击上面或者左侧菜单内一个叫做“控制台”的选项（Google Chrome），如果没有这三个字可以看有没有一个窗口样子的里面有\u0026gt;_字样的图标（Microsoft Edge），单击一下。 点一下最底下的“\u0026gt;”右侧，把光标放到上面。 输入以下代码： localStorage.setItem(\u0026#39;florrio_auto_activate_bonus\u0026#39;,\u0026#39;N\u0026#39;) 随后你的自动开启双倍掉落就会关闭。\n【20250124】雷神之锤更新 现在打火蚁后可以掉Fragment（碎片），最低等级是m，用五个s可以合成一个Unique（简称Q/q）的雷神之锤（外语不会拼）。\n雷神之锤可以造成闪电伤害，伤害197k(196830)，耐久328k(328050)，冷却8s。\n【20250117~20250118】构筑保存更新 多数人都知道，如果有需要可以线下问，懒得写了。\n【20250109】杂项更新 减速花瓣（如Pincer）效果重做，明显等级歧视，同等级实测MPincer能把MBeetle定住，低等级效果更佳显著，高等级会被削。 被ygg的玩家30s内无法再被ygg。 敌对、中立生物被激怒后如果无法索敌（如躲在墙后面或者钻地，即使用Shovel），会尝试逃跑，这也就意味着你无法在粉区旁边隔着墙壁用te（Third Eye，三眼）抢怪。 ","permalink":"https://qjwh.github.io/posts/play/florr_upds/","summary":"\u003cp\u003e需要更早的更新或需要修正请\u003ca href=\"mailto:3055198305@qq.com\"\u003e联系我\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e一些无关紧要的更新不会写，部分更新会加上个人看法。\u003c/p\u003e\n\u003cp\u003e初来建议从下往上读，下面的一些专有名词在上面不做解释。\u003c/p\u003e\n\u003ch2 id=\"20250227神使询问更新\"\u003e【20250227】神使询问更新\u003c/h2\u003e\n\u003cp\u003e现在你可以询问神使某个花瓣将在何时上架商店。\u003c/p\u003e\n\u003cp\u003e询问格式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOracle, oracle, make me a prediction about 品质名 花瓣全名\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e询问格式大小写不敏感（你可以任意变化其中单词的大小写）。\u003c/p\u003e\n\u003cp\u003e\u003cu\u003e暂不确定英文询问的品质名与花瓣全名能否为中文。\u003c/u\u003e\u003c/p\u003e\n\u003cp\u003e在翻译更新后可以用其他语言来询问。\u003c/p\u003e\n\u003cp\u003e神使回答：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIt is imminent（即将发生的）：商店刷新一次后。\u003c/li\u003e\n\u003cli\u003eSoon：商店刷新两次后。\u003c/li\u003e\n\u003cli\u003eEventually（最后，终于）：商店刷新三次后。\u003c/li\u003e\n\u003cli\u003ePerhaps some futures are just indeterminate（不确定的）：商店刷新四次或更多次后。\u003c/li\u003e\n\u003cli\u003eThe future is too cloudy to tell：商店不会上架这个花瓣。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e同一个服务器内的神使只会如实回答二十个小时内（也就是一次商店刷新周期内）的第一个询问的玩家，在这个时间段内，如果已经有玩家询问过神使了（不论是什么花瓣），那么神使对任何询问都只会回答永不上架。\u003c/p\u003e\n\u003cp\u003e游戏更新后服务器重启，所以也可以在此时进行询问。\u003c/p\u003e\n\u003cp\u003e补充：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e碎片\u003cstrong\u003e不能\u003c/strong\u003e拿来与商人交易硬币。\u003c/li\u003e\n\u003cli\u003eM28说商店下一次上架SMimic（拟态）是在商店刷新 $48$ 次后，打折-10%的在刷新 $706$ 次后，打折-50%的在刷新 $862$ 次后。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"20250226总结前几次更新\"\u003e【20250226】总结前几次更新\u003c/h2\u003e\n\u003cp\u003e现在的地图：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/boyuanqy/3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e目前为止所有的配方：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e10空气 $\\to$ 泡泡\u003c/li\u003e\n\u003cli\u003e月石 $\\to$ 10岩石\u003c/li\u003e\n\u003cli\u003e3电池 $\\to$ 电池+闪电\u003c/li\u003e\n\u003cli\u003e玻璃 $\\to$ 沙子\u003c/li\u003e\n\u003cli\u003e3蜂蜜 $\\to$ 蜂蜡\u003c/li\u003e\n\u003cli\u003e玻璃+电池+灯泡 $\\to$ 2激光器\u003c/li\u003e\n\u003cli\u003e碎片+磁铁+玻璃 $\\to$ 指南针\u003c/li\u003e\n\u003cli\u003e叶子+铀 $\\to$ 龟背竹\u003c/li\u003e\n\u003cli\u003e触角+灯泡 $\\to$ 机械触角\u003c/li\u003e\n\u003cli\u003e罗勒 $\\to$ 叶子\u003c/li\u003e\n\u003cli\u003e轻+玫瑰 $\\to$ 大丽花\u003c/li\u003e\n\u003cli\u003e触角+电池 $\\to$ 2机械导弹\u003c/li\u003e\n\u003cli\u003e龟背竹 $\\to$ 叶子\u003c/li\u003e\n\u003cli\u003e轻+蜂蜜 $\\to$ 花粉\u003c/li\u003e\n\u003cli\u003e齿轮 $\\to$ 碎片\u003c/li\u003e\n\u003cli\u003e电池 $\\to$ 碎片\u003c/li\u003e\n\u003cli\u003e沙子 $\\to$ 玻璃\u003c/li\u003e\n\u003cli\u003e100万岩石 $\\to$ 月石\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"20250226杂项更新\"\u003e【20250226】杂项更新\u003c/h2\u003e\n\u003cp\u003e花朵：\u003c/p\u003e","title":"【娱乐】florr.io更新快报"},{"content":" 赛时记录 比赛一开始（$11$ 分钟）就过了A。\n后来一直在B题思考正解。\n在比赛达到 $2h$ 之后，我发现正解已经没希望了，结论假了。\n所以改成了暴力。\n事实上我先写的C，因为感觉B不太有希望，C一眼 $20$ 分。\n之后回头看B，干了最低档。\n最后是D，思考了一下可以做 $45$ 分，搞了。\n此时里比赛结束还有 $27$ 分钟，所以回头看了一下，发现C题的暴力很多。\n先后搞了子任务 $1 \\sim 3$，总共 $70$ 分。\n然后比赛就结束了。\n估分 VS 结果 估分：$100+10+70+45=225$\n结果：$100+25+0+30=155$\n挂分原因 关于B为啥多了 $15$ 分，我也不知道。\nC很复杂：\n子任务1 $T \\leq 100,n \\leq 10$ 挂了：赋值消耗时间复杂度太多，在swap的时候回溯写挂了。 子任务2 $k=0$ 挂了：赋值消耗时间复杂度太多。 子任务3 $k=1$ 挂了：做法假了 D：\n子任务3 $T=1,k \\leq 15$ 挂了：实现的时候没有预处理 $s$、$e$ 的答案，导致询问次数太多TLE。 策略 感觉还是卡B太久。\n事实上这次A非常确信做法正确，事实就是正确的，但后面的题没有对拍，导致总共挂了 $85$ 分。\n之后无论对于正解还是暴力都得对拍，如果认为有挂的概率的那种。\n","permalink":"https://qjwh.github.io/posts/oi/competition/20250211%E4%BB%A3%E7%A0%81%E6%BA%90%E6%AF%94%E8%B5%9B/","summary":"\u003ch2 id=\"text-stylecolorrgb0150136-赛时记录\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 赛时记录\u003c/h2\u003e\n\u003cp\u003e比赛一开始（$11$ 分钟）就过了A。\u003c/p\u003e\n\u003cp\u003e后来一直在B题思考正解。\u003c/p\u003e\n\u003cp\u003e在比赛达到 $2h$ 之后，我发现正解已经没希望了，结论假了。\u003c/p\u003e\n\u003cp\u003e所以改成了暴力。\u003c/p\u003e\n\u003cp\u003e事实上我先写的C，因为感觉B不太有希望，C一眼 $20$ 分。\u003c/p\u003e\n\u003cp\u003e之后回头看B，干了最低档。\u003c/p\u003e\n\u003cp\u003e最后是D，思考了一下可以做 $45$ 分，搞了。\u003c/p\u003e\n\u003cp\u003e此时里比赛结束还有 $27$ 分钟，所以回头看了一下，发现C题的暴力很多。\u003c/p\u003e\n\u003cp\u003e先后搞了子任务 $1 \\sim 3$，总共 $70$ 分。\u003c/p\u003e\n\u003cp\u003e然后比赛就结束了。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-估分-vs-结果\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 估分 VS 结果\u003c/h2\u003e\n\u003cp\u003e估分：$100+10+70+45=225$\u003c/p\u003e\n\u003cp\u003e结果：$100+25+0+30=155$\u003c/p\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-挂分原因\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 挂分原因\u003c/h3\u003e\n\u003cp\u003e关于B为啥多了 $15$ 分，我也不知道。\u003c/p\u003e\n\u003cp\u003eC很复杂：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e子任务1 $T \\leq 100,n \\leq 10$ 挂了：赋值消耗时间复杂度太多，在\u003ccode\u003eswap\u003c/code\u003e的时候回溯写挂了。\u003c/li\u003e\n\u003cli\u003e子任务2 $k=0$ 挂了：赋值消耗时间复杂度太多。\u003c/li\u003e\n\u003cli\u003e子任务3 $k=1$ 挂了：做法假了\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eD：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e子任务3 $T=1,k \\leq 15$ 挂了：实现的时候没有预处理 $s$、$e$ 的答案，导致询问次数太多TLE。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-策略\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 策略\u003c/h2\u003e\n\u003cp\u003e感觉还是卡B太久。\u003c/p\u003e\n\u003cp\u003e事实上这次A非常确信做法正确，事实就是正确的，但后面的题没有对拍，导致总共挂了 $85$ 分。\u003c/p\u003e\n\u003cp\u003e之后无论对于正解还是暴力都得对拍，如果认为有挂的概率的那种。\u003c/p\u003e","title":"20250211代码源比赛"},{"content":"跳题\n如果一道题认为难写，先看后面的题，也许有好写的部分分甚至是正解 如果一道题写完了挂了，认为很对： 找不到错误数据，就规定一段时间（一般为5~10分钟，或者直接执行），然后立刻跳题 找到了错误数据，就可以调时间长一些 如果要在开场把所有题读完（OI赛制专用），遇到难读的题目可以先不读 如果要把剩下的时间全部用在一道题上，先去吃其他题的保底，再开始写这道题 对拍（OI赛制专用）\n如果说一道题强数据好造、暴力好写，那么一定要对拍 即使是模拟赛也要对拍，不止是正式比赛，把模拟赛当做正式比赛认真对待 总结\n比赛后写一下总结，包括以下内容： 赛时记录，什么时候在干什么 估分 VS 得分 挂分原因（BBE） 赛后想一下赛时没有想到的部分分/满分/更优做法 策略总结+调整 ","permalink":"https://qjwh.github.io/posts/oi/competition/%E7%AD%96%E7%95%A5%E6%9B%B4%E6%94%B9/","summary":"\u003cp\u003e跳题\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果一道题认为难写，先看后面的题，也许有好写的部分分甚至是正解\u003c/li\u003e\n\u003cli\u003e如果一道题写完了挂了，认为很对：\n\u003cul\u003e\n\u003cli\u003e找不到错误数据，就规定一段时间（一般为5~10分钟，或者直接执行），然后立刻跳题\u003c/li\u003e\n\u003cli\u003e找到了错误数据，就可以调时间长一些\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e如果要在开场把所有题读完（OI赛制专用），遇到难读的题目可以先不读\u003c/li\u003e\n\u003cli\u003e如果要把剩下的时间全部用在一道题上，先去吃其他题的保底，再开始写这道题\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对拍（OI赛制专用）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果说一道题强数据好造、暴力好写，那么一定要对拍\u003c/li\u003e\n\u003cli\u003e即使是模拟赛也要对拍，不止是正式比赛，把模拟赛当做正式比赛认真对待\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e总结\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e比赛后写一下总结，包括以下内容：\n\u003cul\u003e\n\u003cli\u003e赛时记录，什么时候在干什么\u003c/li\u003e\n\u003cli\u003e估分 VS 得分\u003c/li\u003e\n\u003cli\u003e挂分原因（BBE）\u003c/li\u003e\n\u003cli\u003e赛后想一下赛时没有想到的部分分/满分/更优做法\u003c/li\u003e\n\u003cli\u003e策略总结+调整\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","title":"策略更改"},{"content":"网址\n每天北京时间0点整会更新所有测验。\n这里只说部分，其他的自行摸索。\n猜城/猜城3D/猜国/猜旗/天眼/乡音/城景 线索 会给你关于这个行政区/国家的信息（如果是猜旗则随着你的猜测会逐步揭开）。\n你有 $6$ 次机会去猜，输入方式是类似于查找然后点击的方式（可以自己试试就知道是啥意思了）。\n判题 每次猜完后会告诉你答案在你猜的答案的（大致）哪个方位（八方向），以及距离是多少。\n天眼不会告诉你方位，只会告诉你距离，所以非常难猜，没有足够实力不要去挑战。\n不用管后面的百分比，这个是接近程度，按照距离除以一个很大的数去计算。\n一旦猜对则游戏结束。\n填省/填国/填歌 线索 给你一个表格，表头有限制条件。\n判题 需要在表格内每一个方格填入数据库内同时满足行、列表头上的条件的元素。\n尝试机会有限，看最上面的生命值。\n填完则游戏结束。\n猜Word 线索 跟Wordle一模一样。\n判题 跟阴阳小游戏很像，但不同的是可以告诉你每个位置是匹配还是错位。\n匹配显示为绿色，错位则是黄色，没有则是灰色。\n歌词/诗文 线索 一开始所有格子都是黑色的状态。\n你有无限次机会，每次可以输入一个字，然后这个字在这首歌（包括歌名、歌手、歌词）或诗（包括诗名、作者、内容）内出现的所有位置都会揭开。\n判题 如果猜的字没有出现，则会提示“未出现”并将该字以红色背景显示在最底下。\n如果猜过，则会提示“猜过”并不执行任何操作。\n将歌名或诗名完全揭开即可。\n连句 规则 给你一个表格，你要在里面找到固定数量（可以看最底下）的诗句或者歌词。\n可以通过八方向的一条链表示该诗句，连接的时候可以交叉，可以自己玩一下。\n每个字只能使用一次。\n判题 尝试机会有限，看最上面的生命值。\n如果连句成功则会标记为绿色，并不能再选。\n全部为绿色则游戏结束。\n","permalink":"https://qjwh.github.io/posts/play/xiaoce_fun_daily/","summary":"\u003cp\u003e\u003ca href=\"https://xiaoce.fun/daily\"\u003e网址\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e每天北京时间0点整会更新所有测验。\u003c/p\u003e\n\u003cp\u003e这里只说部分，其他的自行摸索。\u003c/p\u003e\n\u003ch2 id=\"猜城猜城3d猜国猜旗天眼乡音城景\"\u003e猜城/猜城3D/猜国/猜旗/天眼/乡音/城景\u003c/h2\u003e\n\u003ch3 id=\"线索\"\u003e线索\u003c/h3\u003e\n\u003cp\u003e会给你关于这个行政区/国家的信息（如果是猜旗则随着你的猜测会逐步揭开）。\u003c/p\u003e\n\u003cp\u003e你有 $6$ 次机会去猜，输入方式是类似于查找然后点击的方式（可以自己试试就知道是啥意思了）。\u003c/p\u003e\n\u003ch3 id=\"判题\"\u003e判题\u003c/h3\u003e\n\u003cp\u003e每次猜完后会告诉你答案在你猜的答案的（大致）哪个方位（八方向），以及距离是多少。\u003c/p\u003e\n\u003cp\u003e天眼不会告诉你方位，只会告诉你距离，所以非常难猜，没有足够实力不要去挑战。\u003c/p\u003e\n\u003cp\u003e不用管后面的百分比，这个是接近程度，按照距离除以一个很大的数去计算。\u003c/p\u003e\n\u003cp\u003e一旦猜对则游戏结束。\u003c/p\u003e\n\u003ch2 id=\"填省填国填歌\"\u003e填省/填国/填歌\u003c/h2\u003e\n\u003ch3 id=\"线索-1\"\u003e线索\u003c/h3\u003e\n\u003cp\u003e给你一个表格，表头有限制条件。\u003c/p\u003e\n\u003ch3 id=\"判题-1\"\u003e判题\u003c/h3\u003e\n\u003cp\u003e需要在表格内每一个方格填入数据库内同时满足行、列表头上的条件的元素。\u003c/p\u003e\n\u003cp\u003e尝试机会有限，看最上面的生命值。\u003c/p\u003e\n\u003cp\u003e填完则游戏结束。\u003c/p\u003e\n\u003ch2 id=\"猜word\"\u003e猜Word\u003c/h2\u003e\n\u003ch3 id=\"线索-2\"\u003e线索\u003c/h3\u003e\n\u003cp\u003e跟Wordle一模一样。\u003c/p\u003e\n\u003ch3 id=\"判题-2\"\u003e判题\u003c/h3\u003e\n\u003cp\u003e跟阴阳小游戏很像，但不同的是可以告诉你每个位置是匹配还是错位。\u003c/p\u003e\n\u003cp\u003e匹配显示为绿色，错位则是黄色，没有则是灰色。\u003c/p\u003e\n\u003ch2 id=\"歌词诗文\"\u003e歌词/诗文\u003c/h2\u003e\n\u003ch3 id=\"线索-3\"\u003e线索\u003c/h3\u003e\n\u003cp\u003e一开始所有格子都是黑色的状态。\u003c/p\u003e\n\u003cp\u003e你有无限次机会，每次可以输入一个字，然后这个字在这首歌（包括歌名、歌手、歌词）或诗（包括诗名、作者、内容）内出现的所有位置都会揭开。\u003c/p\u003e\n\u003ch3 id=\"判题-3\"\u003e判题\u003c/h3\u003e\n\u003cp\u003e如果猜的字没有出现，则会提示“未出现”并将该字以红色背景显示在最底下。\u003c/p\u003e\n\u003cp\u003e如果猜过，则会提示“猜过”并不执行任何操作。\u003c/p\u003e\n\u003cp\u003e将歌名或诗名完全揭开即可。\u003c/p\u003e\n\u003ch2 id=\"连句\"\u003e连句\u003c/h2\u003e\n\u003ch3 id=\"规则\"\u003e规则\u003c/h3\u003e\n\u003cp\u003e给你一个表格，你要在里面找到固定数量（可以看最底下）的诗句或者歌词。\u003c/p\u003e\n\u003cp\u003e可以通过八方向的一条链表示该诗句，连接的时候可以交叉，可以自己玩一下。\u003c/p\u003e\n\u003cp\u003e每个字只能使用一次。\u003c/p\u003e\n\u003ch3 id=\"判题-4\"\u003e判题\u003c/h3\u003e\n\u003cp\u003e尝试机会有限，看最上面的生命值。\u003c/p\u003e\n\u003cp\u003e如果连句成功则会标记为绿色，并不能再选。\u003c/p\u003e\n\u003cp\u003e全部为绿色则游戏结束。\u003c/p\u003e","title":"【娱乐】炒饭每日小测验食用指南"},{"content":"更新中……\n稀有度 Common：绿 Unusual：un/黄 Rare：蓝 Epic：紫 Legendary：l/红 Mythic：m/青 Ultra：u/ul/粉 Super：s/书青 合成 合成Mythic：合青 合成Ultra：合粉/河粉 合成Super：合苏（su） 合成Ultra并失败：冒青烟 合成Super并失败：冒粉烟 用x个花瓣合成并成功：x=1（如5=1） 用x个花瓣合成并失败：-数字（如-2，但通常此处x=5） 花瓣 默认可以叫花瓣的英文名和大家普遍公认的中文名。\nAnt Egg：agg/egg Antennae：ante/触 Basil：比勒（一般不叫它罗勒） Beetle Egg：bgg Bone：骨/装 Bubble：泡 Claw：头发（一般不叫他爪子/蟹爪） Dandelion：dande Dice：色（shǎi） Faster：罚 Iris：毒药 Lightning：lāi Magic Eye：me/魔眼 Magnet：mag Mana Orb：orb（拼写式读法） Pincer：品色/拼刺儿 Powder：pow Rice：米 Shovel：铲 Sponge：海 Third Eye：te/三眼 Uranium：uran Wing：羽毛 Yggdrasil：ygg（一般不叫它世界树） Yucca：于夹（一般不叫它丝兰） 生物 Queen Ant：queen Starfish：兴（xìng）禹（yú） 黄色瓢虫：shiny ","permalink":"https://qjwh.github.io/posts/play/florr_simple_name/","summary":"\u003cp\u003e更新中……\u003c/p\u003e\n\u003ch2 id=\"稀有度\"\u003e稀有度\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCommon：绿\u003c/li\u003e\n\u003cli\u003eUnusual：un/黄\u003c/li\u003e\n\u003cli\u003eRare：蓝\u003c/li\u003e\n\u003cli\u003eEpic：紫\u003c/li\u003e\n\u003cli\u003eLegendary：l/红\u003c/li\u003e\n\u003cli\u003eMythic：m/青\u003c/li\u003e\n\u003cli\u003eUltra：u/ul/粉\u003c/li\u003e\n\u003cli\u003eSuper：s/书青\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"合成\"\u003e合成\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e合成Mythic：合青\u003c/li\u003e\n\u003cli\u003e合成Ultra：合粉/河粉\u003c/li\u003e\n\u003cli\u003e合成Super：合苏（su）\u003c/li\u003e\n\u003cli\u003e合成Ultra并失败：冒青烟\u003c/li\u003e\n\u003cli\u003e合成Super并失败：冒粉烟\u003c/li\u003e\n\u003cli\u003e用x个花瓣合成并成功：x=1（如5=1）\u003c/li\u003e\n\u003cli\u003e用x个花瓣合成并失败：-数字（如-2，但通常此处x=5）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"花瓣\"\u003e花瓣\u003c/h2\u003e\n\u003cp\u003e默认可以叫花瓣的英文名和大家普遍公认的中文名。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAnt Egg：agg/egg\u003c/li\u003e\n\u003cli\u003eAntennae：ante/触\u003c/li\u003e\n\u003cli\u003eBasil：比勒（一般不叫它罗勒）\u003c/li\u003e\n\u003cli\u003eBeetle Egg：bgg\u003c/li\u003e\n\u003cli\u003eBone：骨/装\u003c/li\u003e\n\u003cli\u003eBubble：泡\u003c/li\u003e\n\u003cli\u003eClaw：头发（一般不叫他爪子/蟹爪）\u003c/li\u003e\n\u003cli\u003eDandelion：dande\u003c/li\u003e\n\u003cli\u003eDice：色（shǎi）\u003c/li\u003e\n\u003cli\u003eFaster：罚\u003c/li\u003e\n\u003cli\u003eIris：毒药\u003c/li\u003e\n\u003cli\u003eLightning：lāi\u003c/li\u003e\n\u003cli\u003eMagic Eye：me/魔眼\u003c/li\u003e\n\u003cli\u003eMagnet：mag\u003c/li\u003e\n\u003cli\u003eMana Orb：orb（拼写式读法）\u003c/li\u003e\n\u003cli\u003ePincer：品色/拼刺儿\u003c/li\u003e\n\u003cli\u003ePowder：pow\u003c/li\u003e\n\u003cli\u003eRice：米\u003c/li\u003e\n\u003cli\u003eShovel：铲\u003c/li\u003e\n\u003cli\u003eSponge：海\u003c/li\u003e\n\u003cli\u003eThird Eye：te/三眼\u003c/li\u003e\n\u003cli\u003eUranium：uran\u003c/li\u003e\n\u003cli\u003eWing：羽毛\u003c/li\u003e\n\u003cli\u003eYggdrasil：ygg（一般不叫它世界树）\u003c/li\u003e\n\u003cli\u003eYucca：于夹（一般不叫它丝兰）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"生物\"\u003e生物\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eQueen Ant：queen\u003c/li\u003e\n\u003cli\u003eStarfish：兴（xìng）禹（yú）\u003c/li\u003e\n\u003cli\u003e黄色瓢虫：shiny\u003c/li\u003e\n\u003c/ul\u003e","title":"【娱乐】交流必备 florr中那些特殊的简写或别称"},{"content":"\r前言 2-SAT中的SAT是适定性（Satisfiability）问题的简称，一般形式为 $k$ - 适定性问题，简称 $k$ - SAT，但由于 $k\u0026gt;2$ 时问题为NP完全问题（只有指数级别复杂度的解法，或者多项式级别复杂度的相似解法），而 $k=1$ 时都不用解了 （废话） ，所以下面全部考虑 $k=2$ 的情况。\n定义 2-SAT问题简单来说就是，有 $n$ 个集合，每个集合包含两个元素（集合 $i$ 包含元素 $2i-1$ 和 $2i$，但其实编号是无关紧要的，任意都行），你必须要在每个集合里分别选择刚好一个元素，但某些元素之间可能有矛盾，即这两个元素不能在一种方案里被同时选择，问你是否有解，报告出来，如果有解，输出一种方案（可能不用输出）。\n题目 看上面的定义可能有点难懂，这里举个题目。\n有一场宴会，这场宴会只有 $n$ 对幸运夫妻可以参加，每对夫妻里只能选择刚好一个人去参加这场宴会。\n但部分人之间可能有矛盾，会给出所有有矛盾的两人编号。\n问你，是否可以构造一种合法方案，如果不行，报告无解，否则输出一种方案。\n解法 （下面统一默认要解决的是实际问题，不是定义里的问题）\n定义点、边 我们考虑把夫妻编个名字：\n第一对夫妻：A男、A女 第二对夫妻：B男、B女 第三对夫妻：C男、C女 以此类推 然后，我们考虑建图。\n但这个建图就要用到一点思维了。\n我们不以其他的定义定义点，我们就把一个点当做一个现实。\n比如：\n$1$ 号点代表第一对夫妻是A男参与宴会，$2$ 号点代表A女参与宴会 $3$ 号点代表第二对夫妻是B男参与宴会，$4$ 号点代表B女参与宴会 $5$ 号点代表第三对夫妻是C男参与宴会，$6$ 号点代表C女参与宴会 以此类推 边的定义也很难思考出：\n一条有向边 $u \\to v$，代表现实 $u$ 满足了，现实 $v$ 也要满足。 举个例子 所以，如果说A男和B女、C男和A女之间都有矛盾，那么就需要在：\nA男、B男（如果A男参与宴会，那么因为有矛盾，B女就不能参与宴会，就需要B男去） B女、A女（如果B女参与宴会，那么因为有矛盾，A男就不能参与宴会，就需要A女去） C男、A男（如果C男参与宴会，那么因为有矛盾，A女就不能参与宴会，就需要A男去） A女、C女（如果A女参与宴会，那么因为有矛盾，C男就不能参与宴会，就需要C女去） 之间连边。\n换到图上就是要连：\n$1 \\to 3$ $4 \\to 2$ $5 \\to 1$ $2 \\to 6$ 建图后的处理、输出答案 我们可以先考虑对这个有向图做个SCC缩点。\n根据SCC性质，以及边定义具有传递性的性质（如果 $a \\to b$ 有边，$b \\to c$ 有边，那么 $a \\to c$ 之间也可以加边，而不影响答案），只要一个SCC中有一个现实满足了，其他现实都得满足。\n所以，一个SCC里要么就是所有现实都不满足，要么就是全部满足，不可能有部分满足的情况，显然。\n判断是否有解 于是乎，我们就判断一下，一个SCC里是否有同一对夫妻参与宴会的现实对应的两个点（可能有点难懂）。\n如果有，那么根据上一行里写的性质，这一对夫妻要么都参与宴会，要么都不参与，永远不可能满足题目条件。\n所以，我们只用循环每个SCC，然后：\n清空标记数组 循环当前SCC内的每个点 标记这个点对应夫妻编号 如果在标记前，这对夫妻已经被标记过 输出无解 如果到最后都没有说无解 输出有解 输出方案 而判断有解后如何构造一种方案输出呢？见下。\n这个输出方案的思路非常妙，也比较难理解。\n我们一对一对夫妻地考虑。\n我们找到这一对夫妻里两个人对应的节点编号 $x$（男性去参加宴会）、$y$（女性去参加宴会），那么一个结论就是，把缩点后的图跑个拓扑排序，如果说 $x$ 所属SCC的拓扑序，比 $y$ 所属SCC的拓扑序，要大，那么就让 $x$ 对应现实满足（男性去参加宴会），否则就让 $y$ 对应现实满足（女性去参加宴会）。\n由于SCC缩点的模板中，缩完点后，这张DAG的拓扑序就是所有SCC编号反向后的结果（设最大编号为 $n$，那么拓扑序就是 $[n,n-1,n-2,n-3,\\dots,2,1]$），所以如果说 $x$ 所属SCC的编号比 $y$ 所属SCC的编号要小，那么就让男性去参加，否则让女性，显然。\n为啥这样是对的呢？我们考虑证明一下：\n性质1 （下面假设拓扑排序就是用的通用模板）\n对于一个DAG，其拓扑排序的过程就是一个BFS的变种。\n即，我们把这个DAG分层后，按层去往拓扑序序列里加点，得到的最终序列就是拓扑序。\n一个节点被分到哪一层，全部取决于这个节点距离任意一个入度为 $0$ 的点的最长路的最大值；特殊地，本身入度就为 $0$ 的点被分到了第 $0$ 层。\n有人问，为啥要用最长路作为编号，而不是最短路？原因见下。\n由于是按照层去编号拓扑序的，所以这种分层方案必须要满足：\n对于每条边 $u \\to v$，$u$ 所处层必须要严格小于 $v$ 所处层。 所以，我们其实就只需要证明，最长路满足上述条件，但最短路不满足\n我们先证明最长路是正确的。\n考虑反证法。\n如果说对于某条边 $u \\to v$，不满足上述条件，我们考虑证明这个现象不存在。\n我们求出 $u$ 对应的层 $dis_u$，那么在跑Dijkstra（准确来说是SPFA）算法时，必然会执行语句 $dis_v=\\max(dis_v,dis_u+1)$，显然。\n所以，最终 $dis_v \\geq dis_u+1$（$dis_v\u0026gt;dis_u$）一定满足，显然。\n这个一定满足的条件也就说明，$v$ 所在层（$dis_v$），一定比 $u$ 所在层（$dis_u$）要大。\n也即，$u$ 所处层严格小于 $v$ 所处层。\n与假设矛盾，证毕。\n我们再证明最短路是错误的。\n$dis_v=\\max(dis_v,dis_u+1)$前面的过程先跳过，我们考虑语句 $dis_v=\\max(dis_v,dis_u+1)$，在使用最短路时，会变成 $dis_v=\\min(dis_v,dis_u+1)$。\n所以，在使用最短路作为层数的时候，只能保证 $dis_v \\leq dis_u+1$，不一定满足上述条件。\n虽然说是不一定满足上述条件，但可能错误是不可改变的现实，所以最短路不可取，证毕。\n如：\n的分层方案就是：\n所以拓扑序：（下面只是一种方案）\n此时有人就问了，说这个有啥用？待会儿你就知道了。\n性质2 有了这个结论的基础，我们就可以大胆猜想一个推论：\n如果说 $x$ 点的拓扑序比 $y$ 点大，那么一定满足下面两个条件之一：\n$x$ 和 $y$ 之间没有路径。 有从 $y$ 到 $x$ 的有向路径，但没有反向路径（从 $x$ 到 $y$ 的路径）。 这个是很好证明对于任何拓扑序都满足的，所以此处略。\n正式证明 （上面所有的 $x$、$y$ 都是设的变量，但下面的 $x$、$y$ 则是做法里的两个现实分别对应的编号）\n有了这两个结论的基础，我们就可以开始证明这个做法的正确性了。\n根据性质2，如果说 $x$ 点的拓扑序比 $y$ 点大，那么就有两种情况，只要分别证明即可。\n对于情况1，两点之间没有路径，那么无论是 $x$ 点对应现实满足，还是 $y$ 点，都是可行的，证毕。\n对于情况2，有从 $y$ 到 $x$ 的右项路径，但没有反向路径，那么根据连边具有传递性的性质，如果 $y$ 对应现实满足，$x$ 也要满足，不符合题目条件；但如果说 $x$ 对应现实满足，那么我们完全可以说 $y$ 对应现实不满足，此时就满足题目条件了，证毕。\n两种情况都满足，证毕。\n证明完后，直接按上述过程搞即可得到最终方案。\n","permalink":"https://qjwh.github.io/posts/oi/aln/2sat/","summary":"\u003ctext style=\"font-family:Noto Sans SC\"\u003e\r\n\u003ch2 id=\"text-stylecolorrgb0150136-前言\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 前言\u003c/h2\u003e\n\u003cp\u003e2-SAT中的SAT是适定性（Satisfiability）问题的简称，一般形式为 $k$ - 适定性问题，简称 $k$ - SAT，但由于 $k\u0026gt;2$ 时问题为NP完全问题（只有指数级别复杂度的解法，或者多项式级别复杂度的\u003cstrong\u003e相似\u003c/strong\u003e解法），而 $k=1$ 时都不用解了 \u003cdel\u003e（废话）\u003c/del\u003e ，所以下面全部考虑 $k=2$ 的情况。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-定义\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 定义\u003c/h2\u003e\n\u003cp\u003e2-SAT问题简单来说就是，有 $n$ 个集合，每个集合包含两个元素（集合 $i$ 包含元素 $2i-1$ 和 $2i$，但其实编号是无关紧要的，任意都行），你必须要在\u003cstrong\u003e每个\u003c/strong\u003e集合里分别选择\u003cstrong\u003e刚好\u003c/strong\u003e一个元素，但某些元素之间可能有矛盾，即这两个元素不能在一种方案里被同时选择，问你是否有解，报告出来，如果有解，输出一种方案（可能不用输出）。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-题目\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 题目\u003c/h2\u003e\n\u003cp\u003e看上面的定义可能有点难懂，这里举个题目。\u003c/p\u003e\n\u003cp\u003e有一场宴会，这场宴会只有 $n$ 对幸运夫妻可以参加，每对夫妻里只能选择\u003cstrong\u003e刚好\u003c/strong\u003e一个人去参加这场宴会。\u003c/p\u003e\n\u003cp\u003e但部分人之间可能有矛盾，会给出所有有矛盾的两人编号。\u003c/p\u003e\n\u003cp\u003e问你，是否可以构造一种合法方案，如果不行，报告无解，否则输出一种方案。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-解法\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 解法\u003c/h2\u003e\n\u003cp\u003e（下面统一默认要解决的是实际问题，不是定义里的问题）\u003c/p\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-定义点边\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 定义点、边\u003c/h3\u003e\n\u003cp\u003e我们考虑把夫妻编个名字：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第一对夫妻：A男、A女\u003c/li\u003e\n\u003cli\u003e第二对夫妻：B男、B女\u003c/li\u003e\n\u003cli\u003e第三对夫妻：C男、C女\u003c/li\u003e\n\u003cli\u003e以此类推\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e然后，我们考虑建图。\u003c/p\u003e\n\u003cp\u003e但这个建图就要用到一点思维了。\u003c/p\u003e\n\u003cp\u003e我们不以其他的定义定义点，我们就把一个点当做一个\u003cstrong\u003e现实\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e比如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$1$ 号点代表第一对夫妻是A男参与宴会，$2$ 号点代表A女参与宴会\u003c/li\u003e\n\u003cli\u003e$3$ 号点代表第二对夫妻是B男参与宴会，$4$ 号点代表B女参与宴会\u003c/li\u003e\n\u003cli\u003e$5$ 号点代表第三对夫妻是C男参与宴会，$6$ 号点代表C女参与宴会\u003c/li\u003e\n\u003cli\u003e以此类推\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e边的定义也很难思考出：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一条\u003cstrong\u003e有向边\u003c/strong\u003e $u \\to v$，代表现实 $u$ \u003cstrong\u003e满足\u003c/strong\u003e了，现实 $v$ 也要\u003cstrong\u003e满足\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"text-stylecolorrgb0150136-举个例子\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 举个例子\u003c/h4\u003e\n\u003cp\u003e所以，如果说A男和B女、C男和A女之间都有矛盾，那么就需要在：\u003c/p\u003e","title":"2-SAT算法"},{"content":"basic\nBSGS算法英文名叫“baby-step giant-step”，又称“大步小步算法”。\n这个算法听名字似乎是个随机化算法，但实际上是数论算法。\n具体地，这个算法解决的是 $a^x \\equiv b \\pmod{p}$ 的解，其中 $a$、$b$、$p$ 是已知的（$0 \\leq a,b\u0026lt;p$，保证 $\\gcd(a,p)=1$），$x$ 是要求的。\n这个算法甚至可以求出所有的 $x$，但为了好讲，我们先考虑如何求出是否有解，以下代码中YES就代表确定有解了。\nforce algorithm\n首先，有一个暴力算法：\nrep(x, 0, INF) if(ksm(a, x, p) == b) YES 但这个算法是 $O(\\infty)$ 的，我们考虑优化。\noptimization algorithm 1\n我们考虑 $x$ 的上界，根据欧拉定理，$a^{\\varphi(p)} \\equiv 1 \\pmod{p}$，我们就可以确定，$x$ 的上界就是 $\\varphi(p)$（准确来说减 $1$ 也彳亍），因为如果 $x\u0026gt;\\varphi(p)$，那么 $a^x$ 就等于 $a^{x-\\varphi(p)}$，也就成为了一个循环，所以上界就是 $\\varphi(p)$。\n由于 $\\varphi(p)\u0026lt;p$，所以可以把 $p$ 当做是质数，$x$ 的上界也就是 $p-1$ 了。\n所以：\nrep(x, 0, p - 1) if(ksm(a, x, p) == b) YES optimization algorithm 2 (BSGS)\n但这个算法还是可能会TLE，我们继续考虑优化\n我们定义 $q=\\left\\lceil \\sqrt{p} \\right\\rceil$，那么我们其实就可以把 $x$ 表示为 $q$ 进制下的两位数，具体地，我们把 $x$ 表示为了 $Aq+B$（$0 \\leq A,B\u0026lt;q$），然后上述公式就可以化成 $a^{Aq+B} \\equiv b \\pmod{p}$，即 $a^{Aq} \\times a^B \\equiv b \\pmod{p}$。\n但此时仍然不好求答案，我们继续转化，我们考虑移项，变成 $a^{Aq} \\equiv b \\times a^{-B} \\pmod{p}$。\n但这个 $a^{-B}$ 不好看，我们换一下。\n我们从最初公式开始修改：\n$a^{Aq-B} \\equiv b \\pmod{p}$（$0 \\leq A \\leq q \\land 0 \\leq B\u0026lt;q$）\n变化后：\n$a^{Aq} \\times a^{-B} \\equiv b \\pmod{p}$\n移项后：\n$a^{Aq} \\equiv b \\times a^B \\pmod{p}$\n但此时我们发现还是没有显著优化效果啊，代码还是 $O(p)$ 的：\nrep(A, 0, q) rep(B, 0, q - 1) if(ksm(a, A * q, p) == b * ksm(a, B, p) % p) YES 但我们发现，两重循环枚举的 $A$ 和 $B$ 是独立的，我们可以使用类似于双向搜索的思想变化成：\nset\u0026lt;LL\u0026gt; s; rep(A, 0, q) s.insert(ksm(a, A * q, p)); rep(B, 0, q - 1) if(s.count(b * ksm(a, B, p) % p)) YES 所以这个算法复杂度就变成了 $O(q \\times \\log q)$，即 $O(\\sqrt{p} \\times \\log \\sqrt{p})$，在 $p \\leq 2 \\times 10^9$ 左右的数据范围下是稳稳地过的。\nsummary and exdend\n其实BSGS就是用的（类似于）拆分的方法，把 $x$ 拆成用两个数 $A$、$B$（$A,B$ 在根号范围）来表示，然后发现 $A$ 和 $B$ 的枚举独立，然后才有这个优化。\n最开始的时候，提到有求出所有的 $x$ 的方法，其实也就是小改动一下，把set\u0026lt;LL\u0026gt;换成map\u0026lt;LL,bs\u0026lt;LL\u0026gt;\u0026gt;即可，代码很相似。\n不过，让求出所有的 $x$ 的题目必须要保证解的数量，但求出 $x$ 的数量的题目就不需要，对于求数量的题目，要换成map\u0026lt;LL,LL\u0026gt;来存。\nexBSGS\n上面说要保证 $\\gcd(a,p)=1$，但如果不保证呢？就需要用到exBSGS。\n其实exBSGS也很简单，首先我们设 $d=\\gcd(a,p)$，那么显然在 $d|b$ 的时候，方程才有解。\n然后我们考虑转化。\n我们把方程直接转化为 $\\dfrac{a^x}{d} \\equiv \\dfrac{b}{d} ~ \\left( \\bmod~\\dfrac{p}{d} \\right)$，即 $\\dfrac{a}{d} \\times a^{x-1} \\equiv \\dfrac{b}{d} ~ \\left( \\bmod~\\dfrac{p}{d} \\right)$。\n但此时的 $a$ 和 $\\dfrac{p}{d}$ 也不一定互质，我们需要继续进行操作。\n我们设进行了 $k$ 次操作，第 $i$ 次操作前，$d$ 的值为 $d_i$，那么其实最终的方程就是：\n$\\dfrac{a^k}{d_1 \\times d_2 \\times d_3 \\times \\dots \\times d_k} \\times a^{x-k} \\equiv \\dfrac{b}{d_1 \\times d_2 \\times d_3 \\times \\dots \\times d_k} ~ \\left( \\bmod~\\dfrac{p}{d_1 \\times d_2 \\times d_3 \\times \\dots \\times d_k} \\right)$。\n此时直接用类似于BSGS的方法求即可。\n","permalink":"https://qjwh.github.io/posts/oi/aln/bsgs/","summary":"\u003cp\u003e\u003cstrong\u003ebasic\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eBSGS算法英文名叫“baby-step giant-step”，又称“大步小步算法”。\u003c/p\u003e\n\u003cp\u003e这个算法听名字似乎是个随机化算法，但实际上是数论算法。\u003c/p\u003e\n\u003cp\u003e具体地，这个算法解决的是 $a^x \\equiv b \\pmod{p}$ 的解，其中 $a$、$b$、$p$ 是已知的（$0 \\leq a,b\u0026lt;p$，保证 $\\gcd(a,p)=1$），$x$ 是要求的。\u003c/p\u003e\n\u003cp\u003e这个算法甚至可以求出所有的 $x$，但为了好讲，我们先考虑如何求出是否有解，以下代码中\u003ccode\u003eYES\u003c/code\u003e就代表确定有解了。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003eforce algorithm\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e首先，有一个暴力算法：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003erep\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eINF\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eksm\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eYES\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e但这个算法是 $O(\\infty)$ 的，我们考虑优化。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003eoptimization algorithm 1\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e我们考虑 $x$ 的上界，根据欧拉定理，$a^{\\varphi(p)} \\equiv 1 \\pmod{p}$，我们就可以确定，$x$ 的上界就是 $\\varphi(p)$（准确来说减 $1$ 也彳亍），因为如果 $x\u0026gt;\\varphi(p)$，那么 $a^x$ 就等于 $a^{x-\\varphi(p)}$，也就成为了一个循环，所以上界就是 $\\varphi(p)$。\u003c/p\u003e\n\u003cp\u003e由于 $\\varphi(p)\u0026lt;p$，所以可以把 $p$ \u003cstrong\u003e当做\u003c/strong\u003e是质数，$x$ 的上界也就是 $p-1$ 了。\u003c/p\u003e\n\u003cp\u003e所以：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003erep\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eksm\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eYES\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003eoptimization algorithm 2 (BSGS)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e但这个算法还是可能会TLE，我们继续考虑优化\u003c/p\u003e\n\u003cp\u003e我们定义 $q=\\left\\lceil \\sqrt{p} \\right\\rceil$，那么我们其实就可以把 $x$ 表示为 $q$ 进制下的两位数，具体地，我们把 $x$ 表示为了 $Aq+B$（$0 \\leq A,B\u0026lt;q$），然后上述公式就可以化成 $a^{Aq+B} \\equiv b \\pmod{p}$，即 $a^{Aq} \\times a^B \\equiv b \\pmod{p}$。\u003c/p\u003e","title":"BSGS算法"},{"content":"\rCDQ分治是一种解决三维、四维偏序的算法。\n三维偏序 三维偏序问题形如：\n有 $q$ 次询问，每次询问有两种：\n修改：会给定 $t$、$x$、$y$、$v$，表示在时刻 $t$，在二维坐标 $(x,y)$ 上加上权值 $v$，修改会永久改变权值 （废话）。 查询：会给定 $t$、$x$、$y$，表示求在时刻 $t$ 时，所有满足 $x\u0026rsquo; \\leq x$，$y\u0026rsquo; \\leq y$ 的二维坐标 $(x\u0026rsquo;,y\u0026rsquo;)$ 上的权值和。 $q \\leq 2 \\times 10^5$ $t,x,y \\leq 2 \\times 10^5$ $v \\leq 10^9$ 这种问题都有一个通用的解决方法，就是CDQ分治，接下来我们讲一下算法的原理。\n我们先把所有的询问离线下来，然后按时刻（第一维）升序排序，显然排序前和排序后，相同询问答案不变。\n接下来我们定义函数 $\\text{solve}(l,r)$，代表只考虑 $l \\sim r$ 内的修改，然后准确回答 $l \\sim r$ 内的询问。\n既然是分治，我们就要构建好整个分治思路，像这道题，就这样做：\n找到 $mid$ 为区间 $[l,r]$ 的中点 $\\left\\lfloor \\dfrac{l+r}{2} \\right\\rfloor$。 考虑 $l \\sim mid$ 内的修改对 $l \\sim mid$ 内的询问的影响：递归调用 $\\text{solve}(l,mid)$。 考虑 $mid+1 \\sim r$ 内的修改对 $mid+1 \\sim r$ 内的询问的影响：递归调用 $\\text{solve}(mid+1,r)$。 考虑 $l \\sim mid$ 内的修改对 $mid+1 \\sim r$ 内的询问的影响： 把 $l \\sim mid$ 内的修改，和 $mid+1 \\sim r$ 内的询问，统统存入一个数组 $b$。 把 $b$ 中所有元素按 $x$ 坐标（第二维）升序排序。 有人对这一步的正确性有疑问，此处解释一下。\n我们初始时已经把所有询问按第一维排序了，所以一次询问 $i$（$i$ 为排序后的下标）只可能由（排序后的）下标比 $i$（严格）小的修改 $j$ 影响。\n我们统一假设询问、修改都是一起编号的，即我们把所有询问、修改放到一起，排序后，直接拿排序后的数组的下标作为编号。\n而我们已经指定了，$mid+1 \\sim r$ 内的询问只能由 $l \\sim mid$ 内的修改影响，所以就可以直接证明了。\n其实证明正确性的一种方式就是，证明排序前，一个询问 $i$，如果会受修改 $j$ 影响，那么在排序后，询问 $i$ 仍然会受修改 $j$ 影响（第一点）；反之，如果排序前，一个询问 $i$，不会受修改 $j$ 影响，那么在排序后，询问 $i$ 仍然不会受修改 $j$ 影响（第二点）。\n我们考虑，在排序后的数组 $b$ 中，对于任意的 $(i,j)$（$i\u0026gt;j$），都满足第二维的偏序关系；反之，对于任意的 $(i,j)$（$i\u0026lt;j$），都不满足第二维的偏序关系，即排序后的 $b$ 数组中，任意一个下标 $i$ 上的询问，都不能被下标 $j$（$j\u0026gt;i$）上的修改所影响。\n对应的，我们考虑在排序前的 $b$ 数组中，看看是否也不会被影响，显然是不会的，因为不管排序前后，第二维始终不满足偏序，也不会被影响。\n接下来考虑所有满足第二维偏序关系的 $(i,j)$（$i\u0026gt;j$），如果满足全部偏序关系，原本（排序前）是否也满足。\n也是显然的，因为如果 $i\u0026gt;j$，第一维偏序关系也满足，而在排序前也满足；第三维偏序关系也是一样的。\n同理也可以证明，所有满足第二维偏序关系的 $(i,j)$（$i\u0026gt;j$），如果不满足全部偏序关系，原本（排序前）也不满足。\n此时，第一、第二维全部都满足偏序了，所以我们就用树状数组维护第三维的偏序，然后从前往后依次考虑修改操作影响，并用树状数组回答询问，很好理解，也很好实现，此处略。 总复杂度：$O(q \\log^2 q)$。\n最后再说一下，如果上面题目中的 $t$ 代表的不是时刻，而是一维坐标，且不是先修改完再询问的特殊情况，那么上述做法会假掉，因为直接把第一维坐标排序会打乱修改和询问的次序，导致询问统计了不该统计的答案，需要用别的方式解决。\n四维偏序 题目描述没差多远，不过这时候是三维坐标。\n解法的话，我们先用CDQ分治将两维消除影响，然后还剩下两维需要单独维护。\n此时，我们发现，我们又转化成了一个CDQ分治问题，所以再跑一遍CDQ分治即可。\n所以，我们就解决了这题，用CDQ分治套CDQ分治。\n用主定理可证明其复杂度为 $O(q \\log^3 q)$。\n有很多人都说，这CDQ套CDQ太难写了，其实四维偏序问题，只可能会在NOI及以上级别的考试中遇到，所以遇到概率特小，但掌握也是要的。\n五维偏序 此时就要用到CDQ分治套CDQ分治套CDQ分治（\n但此时复杂度就是 $O(q \\log^4 q)$，已经接近 $O(q^2)$ 了，加上代码实现过于复杂，就需要另辟蹊径了。\n","permalink":"https://qjwh.github.io/posts/oi/aln/cdq/","summary":"\u003ctext style=\"font-family:Noto Sans SC\"\u003e\r\n\u003cp\u003eCDQ分治是一种解决三维、四维偏序的算法。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-三维偏序\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 三维偏序\u003c/h2\u003e\n\u003cp\u003e三维偏序问题形如：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e有 $q$ 次询问，每次询问有两种：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e修改：会给定 $t$、$x$、$y$、$v$，表示在时刻 $t$，在二维坐标 $(x,y)$ 上加上权值 $v$，修改会永久改变权值 \u003cdel\u003e（废话）\u003c/del\u003e。\u003c/li\u003e\n\u003cli\u003e查询：会给定 $t$、$x$、$y$，表示求在时刻 $t$ 时，所有满足 $x\u0026rsquo; \\leq x$，$y\u0026rsquo; \\leq y$ 的二维坐标 $(x\u0026rsquo;,y\u0026rsquo;)$ 上的权值和。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003e$q \\leq 2 \\times 10^5$\u003c/li\u003e\n\u003cli\u003e$t,x,y \\leq 2 \\times 10^5$\u003c/li\u003e\n\u003cli\u003e$v \\leq 10^9$\u003c/li\u003e\n\u003c/ul\u003e\u003c/blockquote\u003e\n\u003cp\u003e这种问题都有一个通用的解决方法，就是CDQ分治，接下来我们讲一下算法的原理。\u003c/p\u003e\n\u003cp\u003e我们先把所有的询问离线下来，然后按时刻（第一维）升序排序，显然排序前和排序后，相同询问答案不变。\u003c/p\u003e\n\u003cp\u003e接下来我们定义函数 $\\text{solve}(l,r)$，代表只考虑 $l \\sim r$ 内的修改，然后准确回答 $l \\sim r$ 内的询问。\u003c/p\u003e\n\u003cp\u003e既然是分治，我们就要构建好整个分治思路，像这道题，就这样做：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e找到 $mid$ 为区间 $[l,r]$ 的中点 $\\left\\lfloor \\dfrac{l+r}{2} \\right\\rfloor$。\u003c/li\u003e\n\u003cli\u003e考虑 $l \\sim mid$ 内的修改对 $l \\sim mid$ 内的询问的影响：递归调用 $\\text{solve}(l,mid)$。\u003c/li\u003e\n\u003cli\u003e考虑 $mid+1 \\sim r$ 内的修改对 $mid+1 \\sim r$ 内的询问的影响：递归调用 $\\text{solve}(mid+1,r)$。\u003c/li\u003e\n\u003cli\u003e考虑 $l \\sim mid$ 内的修改对 $mid+1 \\sim r$ 内的询问的影响：\n\u003cul\u003e\n\u003cli\u003e把 $l \\sim mid$ 内的修改，和 $mid+1 \\sim r$ 内的询问，统统存入一个数组 $b$。\u003c/li\u003e\n\u003cli\u003e把 $b$ 中所有元素按 $x$ 坐标（第二维）升序排序。\n\u003cblockquote\u003e\n\u003cp\u003e有人对这一步的正确性有疑问，此处解释一下。\u003c/p\u003e","title":"CDQ分治"},{"content":"参考：\n老师讲解 Fighting_Peter 的文章 其实Kruskal重构树并不难。\n概览 首先，Kruskal重构树，顾名思义就是把整棵树重构。\n并且其是基于Kruskal算法的。\n它能解决很多问题，并且变种很多。\n但我们先从基础的实现说起。\n实现过程 我们考虑，在Kruskal算法里，我们每次会合并两个并查集集合。\n准确来说是在两个点 $u$、$v$ 之间加一个边权为 $w$ 的无向边。\n那么，我们就考虑，在重构树里，我们找到 $u$ 和 $v$ 分别所在的子树，把这两个子树的根拎出来，设为 $u\u0026rsquo;$ 和 $v\u0026rsquo;$。\n然后，我们就新建一个点 $w$，然后把 $u\u0026rsquo;$ 和 $v\u0026rsquo;$ 的父亲设为 $w$。\n此时我们就得到了另外一棵树。\n比如说这个例子：\n而在代码中，我们需要给这些方点一个别的编号，而不是以 $w$ 作为编号，否则会重，并且会炸。\n特性 我们讲一些Kruskal重构树的特性：\n这棵树一定是二叉树。\n原树中的点放到重构树上一定是叶子，重构树上其他点都是原树中的边权。\n节点个数一定是 $2n-1$，且 $2n-1$ 一定是根。\n如果是最小生成树，那么这棵重构树一定是大根堆1，否则是小根堆。\n原图中两个点 $u$、$v$ 之间所有路径上的边权最大值的最小值，就是该图的最小生成树重构树上，$u$ 和 $v$​ 的LCA的权值。\n尚未想到证明方式\n对于一个最小生成树上的点 $x$，其只通过（边权）不超过 $v$ 的边，能到的点集；和 $x$ 在重构树上深度最浅的、权值 $\\leq v$ 的点 $y$ 的子树内（叶子）节点集合，是一样的。\n这里稍微证明一下。\n就是我们根据上面的性质，可以发现，设后者对应集合为 $S$，那么显然 $S$ 内的点，和 $x$ 点，的LCA的权值一定不超过 $v$，显然。\n那根据上面那个性质，LCA不超过 $v$，那么路径上的最大权值最小值一定也不超过 $v$。\n既然如此，就证毕了。\n解决题型 题型1 Kruskal重构树本来就是为了解决时间戳问题的。\n题型2 比如“混合药剂”（只是猜测，因为我找不到这道题的来源）这道题就是Kruskal重构树的变种。\n还比如说在正常情况下，如果要求如上面所说的「原图中两个点 $u$、$v$ 之间所有路径上的边权最大值的最小值」，那么其实可以用最小生成树。\n不过这样得要写路径上最大的边权，需要用倍增。\n为了防止部分人不了解，或者对下述文字出现误解或不理解，此处解释一下如何做这个倍增的。\n正常情况下，如果是序列内一个区间的最大边权，那么可以用RMQ，也就是ST表（本质上就是倍增）求出。\n但如果放到树上，就得稍微改一下了。\n定义两个状态 $up_{x,i}$ 表示 $x$ 点向上走 $2^i$ 条边后，到达的点的编号。\n还有 $ma_{x,i}$ 表示 $x$ 点往上的 $2^i$ 条边的最大边权。\n那么，可以得到 $ma_{x,i}=\\max(ma_{x,i-1},ma_{up_{x,i-1},i-1})$。\n而求一条路径上的边权最大值，我们可以求出这条路径两端点的LCA。\n随后我们把这条路径分成左右两段2处理。\n然后可以发现，这个取 $\\max$ 操作是可重的。\n但是尽管如此，我们还得倍增，而不是像ST表一样直接求值。\n具体而言，我们看 $len=dep_u-dep_t$ 的值，即 $u \\to t$ 的路径长度。\n然后，我们找到这个值的 $\\log_2$ 值，即 $lg=\\big\\lfloor \\log_2 (dep_u-dep_t) ~\\big\\rfloor$。\n随后，我们可以发现，我们得求出 $u$ 往上 $len-2^{lg}$ 条边的点。\n因为只有在知道这个点 $x$ 后，我们才能确定 $\\max$ 的第二项。\n最后我们可以直接求出答案 $\\max(ma_{u,lg},ma_{x,lg})$。\n那么，可以发现，这个复杂度是 $\\log$ 的，跑得慢，细节多~~（不过实际上不多）~~。\n不过根据上述特性，我们可以用Kruskal重构树做。\n我们使用RMQ可以 $O(1)$ 在线求出任意两点的LCA值，即可 $O(1)$ 回答询问。\n就是这样，我们就可以把那个 $\\log$ 去掉了。\n不过这样代码会长一些（我觉得实际上会长很多，不过以消掉一个 $\\log$ 为获利也是很值的）\n其他题型待补充 待补充\n此处假设叶子节点的点权是 $-\\infty$，并且我们比较的是点权，而不是代码里的节点编号（不过按理编号也是大根堆吧）。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n设一端点为 $u$，另一端点为 $v$，LCA为 $t$，那么这两段分别为 $u \\to t$ 和 $v \\to t$。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://qjwh.github.io/posts/oi/aln/kruskalcgs/","summary":"\u003cp\u003e参考：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e老师讲解\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.csdn.net/Fighting_Peter/article/details/109149369\"\u003eFighting_Peter 的文章\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e其实Kruskal重构树并不难。\u003c/p\u003e\n\u003ch2 id=\"概览\"\u003e概览\u003c/h2\u003e\n\u003cp\u003e首先，Kruskal重构树，顾名思义就是把整棵树重构。\u003c/p\u003e\n\u003cp\u003e并且其是基于Kruskal算法的。\u003c/p\u003e\n\u003cp\u003e它能解决很多问题，并且变种很多。\u003c/p\u003e\n\u003cp\u003e但我们先从基础的实现说起。\u003c/p\u003e\n\u003ch2 id=\"实现过程\"\u003e实现过程\u003c/h2\u003e\n\u003cp\u003e我们考虑，在Kruskal算法里，我们每次会合并两个并查集集合。\u003c/p\u003e\n\u003cp\u003e准确来说是在两个点 $u$、$v$ 之间加一个边权为 $w$ 的无向边。\u003c/p\u003e\n\u003cp\u003e那么，我们就考虑，在重构树里，我们找到 $u$ 和 $v$ 分别所在的子树，把这两个子树的根拎出来，设为 $u\u0026rsquo;$ 和 $v\u0026rsquo;$。\u003c/p\u003e\n\u003cp\u003e然后，我们就新建一个点 $w$，然后把 $u\u0026rsquo;$ 和 $v\u0026rsquo;$ 的父亲设为 $w$。\u003c/p\u003e\n\u003cp\u003e此时我们就得到了另外一棵树。\u003c/p\u003e\n\u003cp\u003e比如说这个例子：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.luogu.com.cn/upload/image_hosting/4t6kbaq1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e而在代码中，我们需要给这些方点一个别的编号，而不是以 $w$ 作为编号，否则会重，并且会炸。\u003c/p\u003e\n\u003ch2 id=\"特性\"\u003e特性\u003c/h2\u003e\n\u003cp\u003e我们讲一些Kruskal重构树的特性：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e这棵树一定是二叉树。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e原树中的点放到重构树上一定是叶子，重构树上其他点都是原树中的边权。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e节点个数一定是 $2n-1$，且 $2n-1$ 一定是根。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e如果是最小生成树，那么这棵重构树一定是大根堆\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e，否则是小根堆。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e原图中两个点 $u$、$v$ 之间所有路径上的边权最大值的最小值，就是该图的最小生成树重构树上，$u$ 和 $v$​ 的LCA的权值。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e尚未想到证明方式\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e对于一个最小生成树上的点 $x$，其只通过（边权）不超过 $v$ 的边，能到的点集；和 $x$ 在重构树上深度最浅的、权值 $\\leq v$ 的点 $y$ 的子树内（叶子）节点集合，是一样的。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e这里稍微证明一下。\u003c/p\u003e\n\u003cp\u003e就是我们根据上面的性质，可以发现，设后者对应集合为 $S$，那么显然 $S$ 内的点，和 $x$ 点，的LCA的权值一定不超过 $v$，显然。\u003c/p\u003e","title":"Kruskal重构树"},{"content":"（以下全部假设 $C_n^m$ 中的 $n$ 和 $m$ 都很大，最大能达到 $10^{18}$）\nLucas定理 Lucas定理往往用于求组合数的结果且模数较小的题目。\n其实定理很简单，也很好记，$\\Large C_n^m=C_{\\lfloor \\frac{n}{p} \\rfloor}^{\\lfloor \\frac{m}{p} \\rfloor} \\times \\color{orange} C_{n \\bmod p}^{m \\bmod p}$，在 $p$ 为质数的条件成立。\n上面之所以强调模数较小，是因为我们需要通过预处理阶乘的方式去求橙色项的值。\n代码实现很简单，此处略。\n但有个注意点，在我的代码模板里，由于求facny数组是递推求出的，而不是每个分别去用getny求出的，所以调用init函数时，传参应该是MOD-1而不是MOD。\nexLucas定理 （前方高能）\n这个定理还是解决求 $C_n^m \\bmod p$ 的值的问题，$p$ 仍然很小，但不保证是质数。\n根据M2579的做法，我们可以考虑对 $p$ 做一个唯一分解，分解成 ${p_1}^{a_1} \\times {p_2}^{a_2} \\times {p_3}^{a_3} \\times \\dots \\times {p_k}^{a_k}$。\n然后，分别求出 $C_n^m \\bmod {p_1}^{a_1}$ 的值、$C_n^m \\bmod {p_2}^{a_2}$ 的值、$C_n^m \\bmod {p_3}^{a_3}$ 的值、\u0026hellip;、$C_n^m \\bmod {p_k}^{a_k}$ 的值，然后就可以用CRT求出 $C_n^m \\bmod p$ 的值了。\n在M2579内，$p$ 唯一分解后，每个 $a_i$ 都等于 $1$，所以直接用Lucas定理就可以求，但在一般的题目中，指数不一定都等于 $1$，所以才要用到exLucas定理。\nLucas定理解决的是模数为质数的问题，exLucas定理在经过上述转化后，就转化为了模数是质数幂（几个质数乘起来）的问题。\n我们统一设模数为 $q^a$。\n根据组合数公式，$C_n^m=\\dfrac{n!}{m!(n-m)!}$，所以 $C_n^m \\bmod q^a=\\dfrac{n!}{m!(n-m)!} \\bmod q^a$。\n虽然说 $q$ 是质数，但 $q^a$ 不一定是质数，分母中的 $m!$ 和 $(n-m)!$ 也不一定有逆元，显然。\n所以，我们设三个变量 $x$、$y$、$z$，其中 $x$ 代表 $n!$ 唯一分解后，$q$ 的指数是多少，$y$ 代表 $m!$ 分解后 $q$ 的指数，$z$ 代表 $(n-m)!$ 分解后 $q$ 的指数。\n进而，我们就可以对公式做个转化，变成 $C_n^m \\bmod q^a=\\Large \\dfrac{\\frac{n!}{q^x}}{\\frac{m!}{q^y} \\times \\frac{(n-m)!}{q^z}} \\normalsize \\times q^{x-y-z} \\bmod q^a$。\n此处证明一下两个公式的等价性。\n其实也很简单，首先拆分一下外面 $q$ 的指数：\n$C_n^m \\bmod q^a=\\Large \\dfrac{\\frac{n!}{q^x}}{\\frac{m!}{q^y} \\times \\frac{(n-m)!}{q^z}} \\normalsize \\times q^x \\div q^y \\div q^z \\bmod q^a$\n变成分数：\n$C_n^m \\bmod q^a=\\Large \\dfrac{\\frac{n!}{q^x}}{\\frac{m!}{q^y} \\times \\frac{(n-m)!}{q^z}} \\normalsize \\times \\dfrac{q^x}{q^y \\times q^z} \\bmod q^a$\n分数乘法：\n$C_n^m \\bmod q^a=\\Large \\dfrac{\\frac{n!}{q^x} \\times \\color{orange} q^x}{\\frac{m!}{q^y} \\times \\frac{(n-m)!}{q^z} \\times \\color{orange} q^y \\times q^z} \\normalsize \\bmod q^a$\n（为了好看一些，我把新加进来的系数标成了橙色）\n化简：\n$C_n^m \\bmod q^a=\\dfrac{n!}{m!(n-m)!} \\bmod q^a$\n与原式相同，证毕。\n有人问，这个转化有啥用呢？用处很大，因为此时三项（$\\dfrac{n!}{q^x}$、$\\dfrac{m!}{q^y}$、$\\dfrac{(n-m)!}{q^z}$）的唯一分解中都没有 $q$ 了，也就意味着分母中的两个数都有在模 $q^a$ 意义下的逆元了，也就可以直接除了。\n所以，我们又把问题转化为了，求 $\\dfrac{n!}{q^x} \\bmod q^a$ 的值。\n这个值显然是没法直接求的，所以我们考虑递归求。\n我们首先求 $n! \\bmod q^a$ 的值，再变化公式。\n我们先把 $n!$ 展开：\n$1 \\times 2 \\times 3 \\times \\dots \\times n$\n然后把所有 $q$（不是 $q^a$）的倍数提取出来：\n$\\color{orange} (q \\times 2q \\times 3q \\times \\dots \\times \\lfloor \\frac{n}{q} \\rfloor ~ q) \\color{default} \\times \\color{green} \\big( 1 \\times 2 \\times 3 \\times \\dots \\times (q-1) \\big) \\times \\big( (q+1) \\times (q+2) \\times (q+3) \\times \\dots \\times (2q-1) \\big) \\times \\dots$\n（先转化橙色部分）\n由于都有 $q$，所以变化一下：\n$\\color{orange} \\Large q^{\\lfloor \\frac{n}{q} \\rfloor} \\normalsize \\times (1 \\times 2 \\times 3 \\times \\dots \\times \\lfloor \\frac{n}{q} \\rfloor) \\color{default} \\times \\color{green} \\big( 1 \\times 2 \\times 3 \\times \\dots \\times (q-1) \\big) \\times \\dots$\n也就是：\n$\\color{orange} \\Large q^{\\lfloor \\frac{n}{q} \\rfloor} \\normalsize \\times \\left( \\left\\lfloor \\dfrac{n}{q} \\right\\rfloor \\right) ! \\color{default} \\times \\color{green} \\big( 1 \\times 2 \\times 3 \\times \\dots \\times (q-1) \\big) \\times \\dots$\n（再转化绿色部分）\n其实绿色部分也可以转化为：\n（除非特殊注明，默认以下所有 $\\prod$ 中 $i$ 的起始值是 $1$）\n$\\color{orange} \\Large q^{\\lfloor \\frac{n}{q} \\rfloor} \\normalsize \\times \\left( \\left\\lfloor \\dfrac{n}{q} \\right\\rfloor \\right) ! \\color{default} \\times \\color{green} \\Large \\prod\\limits_{q \\nmid i}^n i \\normalsize$\n根据定理 $\\Large \\prod\\limits_{q \\nmid i}^{q^a} i \\equiv \\prod\\limits_{q \\nmid i}^{q^a} (i+cq^a) \\pmod{q^k}$ 对于每个 $c \\in \\mathbb{N^+}$，可转化为：\n$\\color{orange} \\Large q^{\\lfloor \\frac{n}{q} \\rfloor} \\normalsize \\times \\left( \\left\\lfloor \\dfrac{n}{q} \\right\\rfloor \\right) ! \\color{default} \\times \\color{green} \\left( \\Large \\prod\\limits_{q \\nmid i}^{q^a} i \\normalsize \\right)^{\\Large \\left\\lfloor \\frac{n}{q^a} \\right\\rfloor} \\times \\Large \\prod\\limits_{q \\nmid i}^n i$\n（注：最后一个 $\\prod$ 中，$i$ 的起始值是 $\\Large \\left\\lfloor \\frac{n}{q^a} \\right\\rfloor \\normalsize \\times q^a+1$）\n所以，我们就可以递归了。\n但这只是最初的公式，还没有把除以 $q^x$ 带入进去呢。\n由于 $x$ 保证刚好是 $n!$ 的唯一分解中 $q$ 的指数，所以我们直接把最后的那个公式中的所有 $q$ 都去掉就是最后的公式。\n在绿色部分中，显然是不存在 $q$ 的，所有的 $q$ 都在橙色部分。\n橙色部分的左项都是 $q$，直接去掉。\n右项是个递归的部分，所以会自动把所有 $q$ 都除掉，还是那样写即可。\n我们设 $f(n)=\\dfrac{n!}{q^x} \\bmod q^a$（$q$、$a$ 已知，$x$ 可以通过 $n$ 求出，所以不用再加参数了），那么上式就变成了：\n$f(n)=\\color{orange} f \\left( \\left\\lfloor \\dfrac{n}{q} \\right\\rfloor \\right) \\color{default} \\times \\color{green} \\left( \\Large \\prod\\limits_{q \\nmid i}^{q^a} i \\normalsize \\right)^{\\Large \\left\\lfloor \\frac{n}{q^a} \\right\\rfloor} \\times \\Large \\prod\\limits_{q \\nmid i}^n i$\n橙色部分直接递归，绿色部分中每一项只有 $O(q^a)$ 的计算量，由于模数很小，而 $q^a \\leq p$（$p$ 为模数），所以绿色部分的计算量可以当做是 $O(p)$。\n最后的总复杂度（查询复杂度）为 $O(p \\log n)$，显然。\n","permalink":"https://qjwh.github.io/posts/oi/aln/lucas/","summary":"\u003cp\u003e（以下全部假设 $C_n^m$ 中的 $n$ 和 $m$ 都很大，最大能达到 $10^{18}$）\u003c/p\u003e\n\u003ch2 id=\"lucas定理\"\u003eLucas定理\u003c/h2\u003e\n\u003cp\u003eLucas定理往往用于求组合数的结果且\u003cstrong\u003e模数较小\u003c/strong\u003e的题目。\u003c/p\u003e\n\u003cp\u003e其实定理很简单，也很好记，$\\Large C_n^m=C_{\\lfloor \\frac{n}{p} \\rfloor}^{\\lfloor \\frac{m}{p} \\rfloor} \\times \\color{orange} C_{n \\bmod p}^{m \\bmod p}$，在 $p$ 为质数的条件成立。\u003c/p\u003e\n\u003cp\u003e上面之所以强调模数较小，是因为我们需要通过预处理阶乘的方式去求橙色项的值。\u003c/p\u003e\n\u003cp\u003e代码实现很简单，此处略。\u003c/p\u003e\n\u003cp\u003e但有个注意点，在我的代码模板里，由于求\u003ccode\u003efacny\u003c/code\u003e数组是递推求出的，而不是每个分别去用\u003ccode\u003egetny\u003c/code\u003e求出的，所以调用\u003ccode\u003einit\u003c/code\u003e函数时，传参应该是\u003ccode\u003eMOD-1\u003c/code\u003e而不是\u003ccode\u003eMOD\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"exlucas定理\"\u003eexLucas定理\u003c/h2\u003e\n\u003cp\u003e\u003cdel\u003e（前方高能）\u003c/del\u003e\u003c/p\u003e\n\u003cp\u003e这个定理还是解决求 $C_n^m \\bmod p$ 的值的问题，$p$ 仍然很小，但\u003cstrong\u003e不保证是质数\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e根据M2579的做法，我们可以考虑对 $p$ 做一个唯一分解，分解成 ${p_1}^{a_1} \\times {p_2}^{a_2} \\times {p_3}^{a_3} \\times \\dots \\times {p_k}^{a_k}$。\u003c/p\u003e\n\u003cp\u003e然后，分别求出 $C_n^m \\bmod {p_1}^{a_1}$ 的值、$C_n^m \\bmod {p_2}^{a_2}$ 的值、$C_n^m \\bmod {p_3}^{a_3}$ 的值、\u0026hellip;、$C_n^m \\bmod {p_k}^{a_k}$ 的值，然后就可以用CRT求出 $C_n^m \\bmod p$ 的值了。\u003c/p\u003e\n\u003cp\u003e在M2579内，$p$ 唯一分解后，每个 $a_i$ 都等于 $1$，所以直接用Lucas定理就可以求，但在一般的题目中，指数不一定都等于 $1$，所以才要用到exLucas定理。\u003c/p\u003e","title":"Lucas定理"},{"content":"","permalink":"https://qjwh.github.io/posts/oi/aln/nthelement/","summary":"","title":"nth_element（未完工）"},{"content":"感谢这篇文章的作者。\nwqs二分一般解决这类问题：\n有 $n$ 个物品，你要选出恰好 $m$ 个（下称“选择物品个数限制”），可能有限制（下称“其他限制”），你要最大/小化某个权值。\n但除此之外，还有一些限制：\n如果我们设 $g_i$ 为选出恰好 $i$ 个时的最大/小权值，那么 $g$ 函数就应该是上凸（求最大权值）/下凹（求最小权值）的，即斜率单调递减（上凸）/递增（下凹）。 一般来说，如果没有任何限制（包括选择物品个数限制和其他限制），那么答案是很好求的。 一般来说，如果没有其他限制，那么选择物品数量越多，最小权值就越大/小。 以下是P5633的题解，顺带着讲了wqs二分的原理和应用。\n在原题中，我们可以以标号为 $s$ 点在最小生成树上的出度为横坐标，以这个出度对应的答案为纵坐标，画出图像：（网上粘的图，只画了部分横坐标的情况）\n显然D和E点就是最小值点。\n接下来就是wqs二分的重点了\nwqs二分也是二分，那它二分什么值呢，它二分的是斜率 $mid$。\n具体而言，一个斜率就对应若干条平行的边，而总有一条边是完全切这个凸包的，如 $mid=-1$ 的时候，上图中被且的那个点就刚好是C点：\n如果我们设题目要求 $s$ 的度数要恰好为 $6$，那么 $mid=-1$ 的时候被切的那个点C的纵坐标就是答案了。\n但此时我们就有两个问题了：\n如何求出被切的那个点的下标？ 就算求出了下标，那这个点的纵坐标又如何计算？ 接下来我们来解决这两个问题。\n首先，这个切线肯定是所有经过某个点且斜率等于 $mid$ 的直线中截距最小的点：\n具体地，根据切线的性质，在上述例子中，经过C点的斜率等于 $mid$ 的直线（即切线），与经过D点的斜率等于 $mid$ 的直线、经过E点的斜率等于 $mid$ 的直线相比，切线的截距肯定最小，后两者的截距肯定更大。\n其次，显然，经过点 $(x,y)$ 且斜率等于 $k$ 的直线（肯定唯一），其截距一定等于 $y-kx$（$y=kx+b$，$b=y-kx$）。\n而在二分的calc函数（此处不是check函数了，calc函数的返回值、返回值含义以及应用见下）中，我们已经知道了上述公式中的 $k$ 了（$k=mid$），所以我们只要让 $y-kx$ 最小、斜率为 $k$ 且经过了某个图上的点即可。\n考虑到上述公式中的 $x$ 未知，所以我们可以干脆把所有 $s$ 的出边的边权都减 $mid$。（关于是加、减还是都彳亍的问题存疑）\n然后我们对新图跑一个最小生成树，看这个最小生成树中 $s$ 的出度是多少，那么被切点的X坐标就是多少；并且这颗最小生成树的边权和就是这个切线的截距，显然。\n有了这个切线的斜率、截距，也有了切点的X坐标，不就可以计算切点的Y坐标了吗？很简单，此处略。\n接下来就是主函数部分了，可以发现，斜率越小，那么切点的X坐标就越靠后。\n所以，我们就可以考虑用LL calc(LL mid)函数代表用斜率为 $mid$ 的某条直线去切那个 $g$ 函数的图像，那么切点的X坐标是多少。\n由于传参越小，返回值就越大，所以我们就可以二分了，二分找到第一个返回值小于等于 $need$ 的传参 $mid$（要保证 $\\text{calc}(mid)=need$），然后计算如果调用calc(mid)，那么这颗最小生成树的边权和是多少（设为 $sum$），最后输出 $sum+mid \\times need$ 即可，显然。\n上面说“要保证 $\\text{calc}(mid)=need$”，但如果整数的 $mid$ 始终无法满足这个条件，就需要用到小数二分，但小数二分很可能会TLE，所以我们考虑修改。\n（下述做法为假）\n我觉得解决方法也很简单，我们直接找到最后一个 $\\text{calc}(mid) \\leq need$ 的 $mid$，然后答案就不输出 $sum+mid \\times need$ 了，而是输出 $sum+mid \\times \\text{calc}(mid)$ 即可。\n其实解决方法也很简单，我们还是输出 $sum+mid \\times need$ 即可，证明见M2434的代码。\n其实也不是所有题目都要用到上述方法，如果图像像上面说的那样：\n除了底部（即那些全局最小值点）可能会是平的，其他地方都不可能有三点共线，如这样的图像就需要用上述做法：\n（因为红色的三个点共线了）\n","permalink":"https://qjwh.github.io/posts/oi/aln/wqs/","summary":"\u003cp\u003e感谢\u003ca href=\"https://www.acwing.com/file_system/file/content/whole/index/content/5873556/\"\u003e这篇文章\u003c/a\u003e的作者。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003ewqs二分一般解决这类问题：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e有 $n$ 个物品，你要选出恰好 $m$ 个（下称“选择物品个数限制”），可能有限制（下称“其他限制”），你要最大/小化某个权值。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e但除此之外，还有一些限制：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果我们设 $g_i$ 为选出恰好 $i$ 个时的最大/小权值，那么 $g$ 函数就应该是上凸（求最大权值）/下凹（求最小权值）的，即斜率单调递减（上凸）/递增（下凹）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e一般来说\u003c/strong\u003e，如果没有任何限制（包括选择物品个数限制和其他限制），那么答案是很好求的。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e一般来说\u003c/strong\u003e，如果没有其他限制，那么选择物品数量越多，最小权值就越大/小。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e以下是\u003ca href=\"https://www.luogu.com.cn/problem/P5633\"\u003eP5633\u003c/a\u003e的题解，顺带着讲了wqs二分的原理和应用。\u003c/p\u003e\n\u003cp\u003e在原题中，我们可以以标号为 $s$ 点在最小生成树上的出度为横坐标，以这个出度对应的答案为纵坐标，画出图像：（网上粘的图，只画了部分横坐标的情况）\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.acwing.com/media/article/image/2022/06/21/58579_3af7039bf1-%E4%B8%8B%E5%87%B8%E5%A3%B3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e显然D和E点就是最小值点。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e接下来就是wqs二分的重点了\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003ewqs二分也是二分，那它二分什么值呢，它二分的是斜率 $mid$。\u003c/p\u003e\n\u003cp\u003e具体而言，一个斜率就对应若干条平行的边，而总有一条边是完全切这个凸包的，如 $mid=-1$ 的时候，上图中被且的那个点就刚好是C点：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.acwing.com/media/article/image/2022/06/21/58579_3213b178f1-%E5%88%87%E7%BA%BF.png\"\u003e\u003c/p\u003e\n\u003cp\u003e如果我们设题目要求 $s$ 的度数要恰好为 $6$，那么 $mid=-1$ 的时候被切的那个点C的纵坐标就是答案了。\u003c/p\u003e\n\u003cp\u003e但此时我们就有两个问题了：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e如何求出被切的那个点的下标？\u003c/li\u003e\n\u003cli\u003e就算求出了下标，那这个点的纵坐标又如何计算？\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e接下来我们来解决这两个问题。\u003c/p\u003e\n\u003cp\u003e首先，这个切线肯定是所有经过某个点且斜率等于 $mid$ 的直线中截距最小的点：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e具体地，根据切线的性质，在上述例子中，经过C点的斜率等于 $mid$ 的直线（即切线），与经过D点的斜率等于 $mid$ 的直线、经过E点的斜率等于 $mid$ 的直线相比，切线的截距肯定最小，后两者的截距肯定更大。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e其次，显然，经过点 $(x,y)$ 且斜率等于 $k$ 的直线（肯定唯一），其截距一定等于 $y-kx$（$y=kx+b$，$b=y-kx$）。\u003c/p\u003e\n\u003cp\u003e而在二分的\u003ccode\u003ecalc\u003c/code\u003e函数（此处不是\u003ccode\u003echeck\u003c/code\u003e函数了，\u003ccode\u003ecalc\u003c/code\u003e函数的返回值、返回值含义以及应用见下）中，我们已经知道了上述公式中的 $k$ 了（$k=mid$），所以我们只要让 $y-kx$ 最小、斜率为 $k$ 且经过了某个图上的点即可。\u003c/p\u003e\n\u003cp\u003e考虑到上述公式中的 $x$ 未知，所以我们可以干脆把所有 $s$ 的出边的边权都减 $mid$。\u003cem\u003e（关于是加、减还是都彳亍的问题存疑）\u003c/em\u003e\u003c/p\u003e","title":"wqs二分"},{"content":"\r下面是三道与博弈论相关的题目及其做法。\n题目1：皮肤病 题面 （改编自《不可思议事件簿 第5册 魔法学院》，由艾教提供变体）\n（原题名称：加试难题）\n在一个学校内，共有 $100$ 个人，每个人都养了一只狗。\n但由于某些原因，校长确定了这 $100$ 条狗内，必然存在至少一条狗有皮肤病。\n现在那些学生要确定一下哪些狗有皮肤病。\n他们准备这样确定：\n每天上午的时候，所有人看一下除了自己的狗之外的所有狗。 如果确认自己的狗病了，就在晚上敲一下宠物房内的钟。 现在已知：\n无论谁，看那只狗，都能立刻确认它是否有皮肤病。 假设皮肤病不会对狗的寿命造成影响，即所有的狗都不会死亡。 皮肤病不能传染，并且忽略“人患病”造成的影响。 所有人都绝顶聪明（废话 并且：\n第 $1$ 天晚上，没有钟声响起。 第 $2$ 天晚上，没有钟声响起。 第 $3$ 天晚上，没有钟声响起。 \u0026hellip; 直到第 $10$ 天晚上，终于有钟声响起了。 请问：\n那天晚上，共有多少人共同敲响了钟？ 在第 $10$ 天后，除了那些敲钟的人养的狗，是否会存在其他病了的狗？ 答案 $10$ 个人 不会 题解 我们考虑一下，如果说第 $1$ 天晚上有人敲钟，那么代表啥。\n我们从人的角度考虑，如果说一个人发现其他狗都是好狗（指没有皮肤病的狗），那么必然自己的狗有皮肤病 （除了自己的，还有谁的？难不成是他自己？）。\n这种情况下，他便会去敲钟。\n但第 $1$ 天晚上没有钟声，所以每个人都观察到了至少 $1$ 个病狗，也就是说至少有 $2$ 个病狗。\n随后第 $2$ 天，如果说一个人观察到其他的狗内，只有 $1$ 个病狗，那么显然自己的狗也得有皮肤病。\n所以这种情况下，他也会去敲钟。\n并且显然会有 $2$ 个人去敲钟。\n以此类推。\n可以发现，根据上面两天的模拟情况，有多少个病狗，就会在第几天敲钟，并且敲钟的都是那些养了病狗的，没养病狗的不会敲钟（实际上是废话\n所以就可以得到本题答案。\n题目2：抓豆子 题面 （本题面基于艾教讲述的题面进行修改）\n有 $10$ 个人在进行一场抓豆子游戏。\n游戏规则是这样的，$10$ 个人按照环的顺序依次取豆子（即取的顺序是 $1,2,3,\\dots,10,1,2,3,\\dots,10,\\dots$），初始袋子里面共有 $100$ 颗豆子。\n每个人都要取至少 $1$ 个豆子，如果袋子为空，则游戏结束。\n显然这个游戏会在有限局内结束。\n结束之后，我们看每个人一共取了多少个豆子，随后取的豆子最多的和最少的所有人都会被淘汰。\n但那些人显然不想让自己被淘汰，并且他们不存在“我不想让某个其他人被淘汰，即使付出自己被淘汰的代价”的情况。\n现在问你：\n在所有人都绝顶聪明的时候，哪些人被淘汰了。 注意，淘汰完该淘汰的人后，游戏就彻底结束了，不会继续下一轮游戏。\n答案 所有人都会被淘汰。 题解 我们从第 $1$ 个人的角度考虑。\n显然在第 $1$ 个人取完豆子后，第 $2$ 个人便会知道第 $1$ 个人取了多少豆子。\n分两种情况：\n第 $1$ 个人直接取完了所有豆子。 第 $1$ 个人没有取完。 显然第一种情况是直接全部淘汰。\n但第二种情况呢？我们再考虑第 $2$ 个人。\n可以发现，只要第 $1$ 个人和第 $2$ 个人取的豆子之间有一点的空隙（即差至少为 $2$），那么第 $3$ 个人就有机会不淘汰，不符合题目条件。\n所以显然第 $2$ 个人和第 $1$ 个人取的豆子数量的差不会超过 $1$。\n再看第 $3$ 个人，显然第 $3$ 个人取的豆子只能是第 $1$ 或者第 $2$ 个人取的豆子数量。\n因为只要是其他数量，那么第 $1$ 或者第 $2$ 个人中，必然会有一个人活。\n当然，如果说前两个人取一样的豆子个数，那么第 $3$ 个人还可以取到最多差为 $1$。\n以此类推，可以发现，最后谁都会被淘汰。\n题目3：分金币 题面 （本题面基于艾教讲述的题面进行修改）\n有 $10$ 个海盗，他们都是贪婪、自私但聪明的。\n现在他们要分偷来的 $100$ 个金币。\n他们准备采用投票的方式。\n具体而言，我们把十个人分别命名为：老大、老二、老三、老四、老五、老六、老七、老八、老九、老十。\n随后，先老大提供一种分硬币的方式。\n然后包括老大在内的共 $10$ 个人做投票。\n只要投支持票的人达到了总人数的一半（上取整）及以上，那么就采用老大的方式分配，否则把老大淘汰，然后老二说一个分配方案。\n当然，他们也接受贿赂，贿赂是这样的：\n假设 $a$ 要贿赂 $b$，那么就在 $a$ 说分配方案的时候，给 $b$ 至少一个金币（当然，显然给一个金币最好），此时 $b$ 便会考虑投支持票，也就是说 $b$ 可能会反水。 现在问你：\n在所有人都绝顶聪明的时候，每个人分别获得多少金币。 为了防止答案多解，那么我们假设每个人都想早点得到自己最优的金币。\n答案 老大分得 $96$ 个金币，老三、五、七、九各分得 $1$ 金币，其他人一无所得。 题解 （以下题解会采用半对话半陈述的形式）\n老十：只要我把老大到老九淘汰，我就能独占所有金币了。/tx\n老九：你没机会了——只要轮到我，我就让我独占所有，并且无论如何都不可能拒绝我的分配方案。/cf\n老八：不行，只要我被淘汰，那么老九就会独占所有金币，所以我就把老十贿赂一下，让他投我的票，我就能得到 $99$ 个金币了，不戳。/yx\n这里解释一下为啥老八贿赂的是老十而不是老九。\n是因为只要贿赂老九，那么老九就会反水，然后自己独占所有金币。\n而如果贿赂老十，那么老十就会想，如果我反水，那么就会轮到老九，此时我会一分不得。\n所以我还不如投支持票，我还能得到一个金币。\n老七：@老八 你没机会了，我贿赂一下老九，这样我就能得到 $99$ 个金币。/kx\n这里也解释一下为啥贿赂老九会更优。\n首先贿赂老八那么老八就一定会反水。\n其次考虑贿赂老十，这时候如果老十反水，那么会轮到老八，老八也会给我一个金币，那么不如早得。\n以此类推，直到老大，此时老大需要贿赂老三、五、七、九，自己获得 $96$ 个金币，此时就是最优的方案了。\n","permalink":"https://qjwh.github.io/posts/oi/aln/games/","summary":"\u003ctext style=\"font-family:Noto Sans SC\"\u003e\r\n\u003cp\u003e下面是三道与博弈论相关的题目及其做法。\u003c/p\u003e\n\u003ch1 id=\"text-stylecolorrgb0150136-题目1皮肤病\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 题目1：皮肤病\u003c/h1\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-题面\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 题面\u003c/h2\u003e\n\u003cp\u003e（改编自《不可思议事件簿 第5册 魔法学院》，由艾教提供变体）\u003c/p\u003e\n\u003cp\u003e（原题名称：加试难题）\u003c/p\u003e\n\u003cp\u003e在一个学校内，共有 $100$ 个人，每个人都养了一只狗。\u003c/p\u003e\n\u003cp\u003e但由于某些原因，校长确定了这 $100$ 条狗内，必然存在至少一条狗有皮肤病。\u003c/p\u003e\n\u003cp\u003e现在那些学生要确定一下哪些狗有皮肤病。\u003c/p\u003e\n\u003cp\u003e他们准备这样确定：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e每天上午的时候，所有人看一下\u003cstrong\u003e除了自己的狗之外\u003c/strong\u003e的所有狗。\u003c/li\u003e\n\u003cli\u003e如果确认自己的狗病了，就在晚上敲一下宠物房内的钟。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e现在已知：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e无论谁，看那只狗，都能立刻确认它是否有皮肤病。\u003c/li\u003e\n\u003cli\u003e假设皮肤病不会对狗的寿命造成影响，即所有的狗都不会死亡。\u003c/li\u003e\n\u003cli\u003e皮肤病不能传染，并且忽略“人患病”造成的影响。\u003c/li\u003e\n\u003cli\u003e所有人都绝顶聪明（废话\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e并且：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第 $1$ 天晚上，没有钟声响起。\u003c/li\u003e\n\u003cli\u003e第 $2$ 天晚上，没有钟声响起。\u003c/li\u003e\n\u003cli\u003e第 $3$ 天晚上，没有钟声响起。\u003c/li\u003e\n\u003cli\u003e\u0026hellip;\u003c/li\u003e\n\u003cli\u003e直到第 $10$ 天晚上，终于有钟声响起了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e请问：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e那天晚上，共有多少人共同敲响了钟？\u003c/li\u003e\n\u003cli\u003e在第 $10$ 天后，除了那些敲钟的人养的狗，是否会存在其他病了的狗？\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-答案\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 答案\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e$10$ 个人\u003c/li\u003e\n\u003cli\u003e不会\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-题解\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 题解\u003c/h2\u003e\n\u003cp\u003e我们考虑一下，如果说第 $1$ 天晚上有人敲钟，那么代表啥。\u003c/p\u003e\n\u003cp\u003e我们从人的角度考虑，如果说一个人发现其他狗都是好狗（指没有皮肤病的狗），那么必然自己的狗有皮肤病 \u003cdel\u003e（除了自己的，还有谁的？难不成是他自己？）\u003c/del\u003e。\u003c/p\u003e\n\u003cp\u003e这种情况下，他便会去敲钟。\u003c/p\u003e\n\u003cp\u003e但第 $1$ 天晚上没有钟声，所以每个人都观察到了至少 $1$ 个病狗，也就是说至少有 $2$ 个病狗。\u003c/p\u003e\n\u003cp\u003e随后第 $2$ 天，如果说一个人观察到其他的狗内，只有 $1$ 个病狗，那么显然自己的狗也得有皮肤病。\u003c/p\u003e","title":"博弈论三种扩展题型"},{"content":"\r点分治和树剖有一个相同点，就是算法都是从暴力经过一小步优化而来，但就是这一小步，让算法复杂度有了质的飞跃。\n下面来讲一下这个算法的原理。\n概览 其实“点分治”也是一个名不副实的算法，看完下面的讲述你就会发现这个算法根“分治”几乎无关。\n点分治是专门解决树上路径统计的一种算法（树剖则是解决对树上路径的判断的算法）。\n点分治的思想很朴素，就是DFS一下 $\\text{lca}$ 的节点编号 $x$，然后统计 $\\text{lca}$ 值刚好为 $x$ 的、满足题目条件的路径的数量，并累加到答案。\n但直接进行统计还是炸裂的，点分治则是对这种统计方式做了一步优化\n解决题型 上面说了，「点分治是专门解决树上路径统计的一种算法」，但并不是所有的树上路径统计都可以用点分治解决。\n其实看完下面的实现，你就能知道它解决什么类问题，不过这里还是说一下。\n就是首先，这个条件是形如“总和比某个值低”、“总和是某个值的倍数”等“可累加”的条件。\n其中“可累加”指的是，如果知道了 $A$ 部分的某个值，和 $B$ 部分的某个值，那么 $A$ 和 $B$ 部分合并后的部分是否合法也一定知道。\n但其他的条件目前还没有太明确，得自己去总结。\n算法实现 下面说一下点分治的实现。\n大体思路 我们拿“路径长度（路径上的边的边权之和）刚好为 $k$”问题举例。\n注：原题链接P3806\n就是我们考虑，当DFS到某个点 $x$ 的时候，就如上所说，设 $x$ 为 $\\text{lca}$ 值。\n然后，我们按顺序遍历所有子节点 $to$。\n由于只要两个点 $y$、$z$ 满足 $y$ 和 $z$ 分别在 $x$ 的两个不同儿子及其子树内，那么 $\\text{lca}(y,z)=x$。\n并且所有满足条件 $\\text{lca}(y,z)=x$ 的对 $(y,z)$ 只有满足上述条件的对。\n所以，我们可以通过（另一种）DFS（方式）求出 $to$ 到 ( 所有 $to$ 及其子树内的点 ) 之间的距离（加上 $x \\to to$ 的边权）的集合 $T$。\n并维护当前所有遍历过的儿子（不包含当前遍历的儿子）的 $T$ 集合的并集 $S$。\n接下来，只用看是否存在：\n一个在 $S$ 中出现过的元素 $x$。 一个在 $T$ 中出现过的元素 $y$。 满足 $x+y=k$（其中 $k$ 为询问的值）即可。\n这一点可以用标记数组解决。\n具体而言，我们维护一个标记数组，表示每个元素是否出现于 $S$ 内。\n但现在唯一的问题就在于，$T$ 集合只能暴力求出，但如果真的暴力，复杂度是炸裂的（可以被一条链的数据卡掉）。\n优化算法 我们考虑，不优化求出 $T$ 集合的暴力DFS算法，转而优化外层DFS（枚举 $\\text{lca}$ 值用的）。\n我们先对于每个 $to$，暴力做DFS，并更新答案。\n然后再枚举每个 $to$，此时 $to$ 及其子树无论以谁为根，都不会影响答案，显然。\n而由于我们对于每个点，都要遍历两遍子树，所以复杂度是和深度有关的，是一个 $O(2^\\text{dep})$ 的复杂度。\n所以，我们就尝试把深度降到 $\\log n$ 级别即可。\n一种思路就是每次只选择 $to$ 及其子树的重心作为根，因为重心有一个特点：\n如果以重心为根去重构整棵树，那么根节点（重心）的每个儿子及其子树的大小，都不会超过整棵树的大小的一半。 所以深度一定不超过 $\\log n$。\n扩展算法 不过无论如何，点分治只是一个工具类算法，得配合其他算法出现。\n比如，另外一道题P4178，就得把标记数组换成树状数组。\n还比如一些题，得在更新答案的时候用双指针，甚至还要配合优先队列等STL。\n复杂度证明 其实这个证明非常好想。\n上面其实已经说了一点了，就是复杂度是 $O(2^\\text{dep})$ 的，而每次选择重心就可以让这个复杂度达到 $O(n)$。\n对于其他的用点分治的题目的复杂度证明，可以采用以下思路：\n看每个点对复杂度有多少贡献。 那个复杂度 $O(2^\\text{dep})$ 就是这样求出的。\n","permalink":"https://qjwh.github.io/posts/oi/aln/dfz/","summary":"\u003ctext style=\"font-family:Noto Sans SC\"\u003e\r\n\u003cp\u003e点分治和树剖有一个相同点，就是算法都是从暴力经过一小步优化而来，但就是这一小步，让算法复杂度有了质的飞跃。\u003c/p\u003e\n\u003cp\u003e下面来讲一下这个算法的原理。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-概览\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 概览\u003c/h2\u003e\n\u003cp\u003e其实“点分治”也是一个名不副实的算法，看完下面的讲述你就会发现这个算法根“分治”几乎无关。\u003c/p\u003e\n\u003cp\u003e点分治是专门解决树上路径统计的一种算法（树剖则是解决对树上路径的判断的算法）。\u003c/p\u003e\n\u003cp\u003e点分治的思想很朴素，就是DFS一下 $\\text{lca}$ 的节点编号 $x$，然后统计 $\\text{lca}$ 值刚好为 $x$ 的、满足题目条件的路径的数量，并累加到答案。\u003c/p\u003e\n\u003cp\u003e但直接进行统计还是炸裂的，点分治则是对这种统计方式做了一步优化\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-解决题型\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 解决题型\u003c/h2\u003e\n\u003cp\u003e上面说了，「点分治是专门解决树上路径统计的一种算法」，但并不是所有的树上路径统计都可以用点分治解决。\u003c/p\u003e\n\u003cp\u003e其实看完下面的实现，你就能知道它解决什么类问题，不过这里还是说一下。\u003c/p\u003e\n\u003cp\u003e就是首先，这个条件是形如“总和比某个值低”、“总和是某个值的倍数”等“可累加”的条件。\u003c/p\u003e\n\u003cp\u003e其中“可累加”指的是，如果知道了 $A$ 部分的某个值，和 $B$ 部分的某个值，那么 $A$ 和 $B$ 部分合并后的部分是否合法也一定知道。\u003c/p\u003e\n\u003cp\u003e但其他的条件目前还没有太明确，得自己去总结。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-算法实现\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 算法实现\u003c/h2\u003e\n\u003cp\u003e下面说一下点分治的实现。\u003c/p\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-大体思路\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 大体思路\u003c/h3\u003e\n\u003cp\u003e我们拿“路径长度（路径上的边的边权之和）刚好为 $k$”问题举例。\u003c/p\u003e\n\u003cp\u003e注：原题链接\u003ca href=\"https://www.luogu.com.cn/problem/P3806\"\u003eP3806\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e就是我们考虑，当DFS到某个点 $x$ 的时候，就如上所说，设 $x$ 为 $\\text{lca}$ 值。\u003c/p\u003e\n\u003cp\u003e然后，我们按顺序遍历所有子节点 $to$。\u003c/p\u003e\n\u003cp\u003e由于只要两个点 $y$、$z$ 满足 $y$ 和 $z$ 分别在 $x$ 的两个不同儿子及其子树内，那么 $\\text{lca}(y,z)=x$。\u003c/p\u003e\n\u003cp\u003e并且所有满足条件 $\\text{lca}(y,z)=x$ 的对 $(y,z)$ 只有满足上述条件的对。\u003c/p\u003e\n\u003cp\u003e所以，我们可以通过（另一种）DFS（方式）求出 $to$ 到 ( 所有 $to$ 及其子树内的点 ) 之间的距离（加上 $x \\to to$ 的边权）的集合 $T$。\u003c/p\u003e","title":"点分治"},{"content":"基尔霍夫矩阵是用来求解生成树计数、求（权值）和相关题目的利器。\n0. 求完全图的生成树数量（Prufer序列） 要说基尔霍夫矩阵，就要从一道题目说起：\n给你 $n$，问 $n$ 个节点组成的无向无根树有多少种。\n这道题可以用Prufer序列去做。\n这里简单说一下Prufer序列的求法：\n对于一张无向无根树，重复执行以下操作直到只剩 $2$ 个或更少的点，最后得到的那个序列 $a$ 就是这棵树的Prufer序列：\n我们找到此时度为 $1$ 的节点，若有多个，找编号最小的，设找到的节点编号为 $x$。 在 $a$ 的末尾添加：与 $x$ 有连边的那个唯一节点。 删除 $x$。 Prufer序列别看求法非常简单，也没啥容易发现的性质，其实用处很大。\nPrufer序列满足一个性质，就是，所有无向无根树，都可以唯一地对应一个Prufer序列；所有Prufer序列都可以唯一地对应一棵树。\n所以，这道题就有解了，答案其实就是长为 $n-2$ 的Prufer序列有多少种。\n由于Prufer序列的每个元素的值都是从 $1$ 到 $n$ 的，所以答案就是 $n^{n-2}$，显然。\n1.1. 求任意无向图的生成树数量（基尔霍夫矩阵） 但如果把题目变化一下，就不能用Prufer序列去求了：\n给你一张 $n$ 个节点 $m$ 条边的无向图，问这张图的生成树有多少个。\n这题要用基尔霍夫矩阵。\n具体地，我们定义 $D$ 矩阵，求法：\n$ D_{i,j}= \\begin{cases} 0 \u0026amp; i \\not= j \\ \\text{deg}(i) \u0026amp; i=j \\end{cases} $\n其中，$\\text{deg}(i)$ 代表这张图上 $i$ 的度是多少。\n我们再定义 $A$ 矩阵，求法：\n$ A_{i,j}= \\begin{cases} \\text{ecnt}(i,j) \u0026amp; i \\not= j \\ 0 \u0026amp; i=j \\end{cases} $\n其中，$\\text{ecnt}(i,j)$ 代表这张图上点 $i$ 和点 $j$ 之间的边数。\n然后，我们再定义基尔霍夫矩阵 $K=D-A$，即：\n$ K_{i,j}= \\begin{cases} -\\text{ecnt}(i,j) \u0026amp; i \\not= j \\ \\text{deg}(i) \u0026amp; i=j \\end{cases} $\n最后，我们同时删掉 $K$ 中的一行和一列（一般是删掉最后一行和最后一列，但删掉哪一行、哪一列答案都不变），此时 $K$ 的行列式即为本题答案。\n（以下所有 $D$、$A$、$K$ 的求法都是一样的，答案求法也是一样的，所以只说 $\\text{deg}$ 函数和 $\\text{ecnt}$ 函数的求法）\n*注：\n如果是有向图生成树相关题目，且题目指定了根，那么删除的那一行和那一列的编号，必须是根节点的编号。\n如，题目要求 $1$ 节点为根，那么删除的必须要是第一行和第一列，否则会WA。\n此外，以下所有题里，在求 $\\text{deg}$ 函数和 $\\text{ecnt}$ 函数时，都要忽略自环。\n并且，如果说下面构造的方阵没有行列式，那么就说明没有生成树，要输出 $0$。\n1.2. 求任意无向带权图的生成树权值之和（基尔霍夫矩阵） 这题还有变种：\n给你一张 $n$ 个节点 $m$ 条边的无向带权图，问这张图所有生成树的权值之和。\n一棵生成树的权值定义为这棵生成树内所有边权之和。\n$\\text{deg}(i)$ 代表这张图上 $i$ 的所有出边的边权之和，$\\text{ecnt}(i,j)$ 代表这张图上点 $i$ 和点 $j$ 之间所有边的边权和。\n2.1.1. 求任意有向图的生成外向树数量（基尔霍夫矩阵） 但还没完，还有题目：\n给你一张 $n$ 个节点 $m$ 条边的有向图，问这张图的生成树有多少个。\n此处，生成树要求是外向树。\n所谓外向树，就是一棵有向树，满足每条边都是从父亲指向儿子的。\n$\\text{deg}(i)$ 代表这张图上 $i$ 的入度，$\\text{ecnt}(i,j)$ 代表这张图上从点 $i$ 连向点 $j$ 的边的数量。\n2.1.2. 求任意有向带权图的生成外向树权值之和（基尔霍夫矩阵） 但还没完，还有题目：\n给你一张 $n$ 个节点 $m$ 条边的有向带权图，问这张图的生成树的权值之和。\n此处，生成树要求是外向树。\n$\\text{deg}(i)$ 代表这张图内连向 $i$ 的边权之和，$\\text{ecnt}(i,j)$ 代表这张图上从点 $i$ 连向点 $j$ 的边权之和。\n2.2.1. 求任意有向图的生成内向树数量（基尔霍夫矩阵） 但还没完，还有题目：\n给你一张 $n$ 个节点 $m$ 条边的有向图，问这张图的生成树有多少个。\n此处，生成树要求是内向树。\n所谓内向树，就是一棵有向树，满足每条边都是从儿子指向父亲的。\n$\\text{deg}(i)$ 代表这张图上 $i$ 的出度，$\\text{ecnt}(i,j)$ 代表这张图上从点 $i$ 连向点 $j$ 的边的数量。\n2.2.2. 求任意有向带权图的生成内向树权值之和（基尔霍夫矩阵） 但还没完，还有题目：\n给你一张 $n$ 个节点 $m$ 条边的有向带权图，问这张图的生成树的权值之和。\n此处，生成树要求是内向树。\n$\\text{deg}(i)$ 代表这张图内 $i$ 的出边边权之和，$\\text{ecnt}(i,j)$ 代表这张图上从点 $i$ 连向点 $j$ 的边权之和。\n3. 求完全二分图的生成树个数（基尔霍夫矩阵拓展） 但还没完，还有题目：\n给你两个数 $n$、$m$，问左边 $n$ 个点，右边 $m$ 个点的完全二分图的生成树个数。\n这个问题可以被转化为问题1.1，所以我们就可以得到基尔霍夫矩阵：\n$ \\begin{bmatrix} m \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; -1 \u0026amp; -1 \u0026amp; \\cdots \u0026amp; -1 \\ 0 \u0026amp; m \u0026amp; \\cdots \u0026amp; 0 \u0026amp; -1 \u0026amp; -1 \u0026amp; \\cdots \u0026amp; -1 \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; m \u0026amp; -1 \u0026amp; -1 \u0026amp; \\cdots \u0026amp; -1 \\ -1 \u0026amp; -1 \u0026amp; \\cdots \u0026amp; -1 \u0026amp; n \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \\ -1 \u0026amp; -1 \u0026amp; \\cdots \u0026amp; -1 \u0026amp; 0 \u0026amp; n \u0026amp; \\cdots \u0026amp; 0 \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ -1 \u0026amp; -1 \u0026amp; \\cdots \u0026amp; -1 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; n \\ \\end{bmatrix} $\n标一些参数：\n（图1）\n然后，可以发现，在上面的划分方案中，左上部分和右下部分其实都是方阵，所以我们只要让左下部分全部变为 $0$ 就可以用行列式性质转化问题了。\n进而，既然求这个矩阵的行列式，我们就先把最后一行和最后一列去掉，即把图1的参数内的两个 $m$ 改成 $m-1$。\n我们既然要把左下部分变成 $0$，我们就要变化矩阵。\n我们首先把矩阵前 $n$ 行全部除以 $m$，得到：\n$ \\large \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; \\frac{-1}{m} \u0026amp; \\frac{-1}{m} \u0026amp; \\cdots \u0026amp; \\frac{-1}{m} \\ 0 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; \\frac{-1}{m} \u0026amp; \\frac{-1}{m} \u0026amp; \\cdots \u0026amp; \\frac{-1}{m} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 1 \u0026amp; \\frac{-1}{m} \u0026amp; \\frac{-1}{m} \u0026amp; \\cdots \u0026amp; \\frac{-1}{m} \\ -1 \u0026amp; -1 \u0026amp; \\cdots \u0026amp; -1 \u0026amp; n \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \\ -1 \u0026amp; -1 \u0026amp; \\cdots \u0026amp; -1 \u0026amp; 0 \u0026amp; n \u0026amp; \\cdots \u0026amp; 0 \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ -1 \u0026amp; -1 \u0026amp; \\cdots \u0026amp; -1 \u0026amp; 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; n \\ \\end{bmatrix} $\n其次，算出前 $n$ 行矩阵之和：\n$ \\large \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \u0026amp; \\frac{-n}{m} \u0026amp; \\frac{-n}{m} \u0026amp; \\cdots \u0026amp; \\frac{-n}{m} \\end{bmatrix} $\n然后，对于后 $m-1$ 行，每一行都加上前 $n$ 行之和：\n$ \\large \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; \\frac{-1}{m} \u0026amp; \\frac{-1}{m} \u0026amp; \\cdots \u0026amp; \\frac{-1}{m} \\ 0 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; \\frac{-1}{m} \u0026amp; \\frac{-1}{m} \u0026amp; \\cdots \u0026amp; \\frac{-1}{m} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 1 \u0026amp; \\frac{-1}{m} \u0026amp; \\frac{-1}{m} \u0026amp; \\cdots \u0026amp; \\frac{-1}{m} \\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; n-\\frac{n}{m} \u0026amp; -\\frac{n}{m} \u0026amp; \\cdots \u0026amp; -\\frac{n}{m} \\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; -\\frac{n}{m} \u0026amp; n-\\frac{n}{m} \u0026amp; \\cdots \u0026amp; -\\frac{n}{m} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; -\\frac{n}{m} \u0026amp; -\\frac{n}{m} \u0026amp; \\cdots \u0026amp; n-\\frac{n}{m} \\ \\end{bmatrix} $\n最后，把前 $n$ 行重新都乘上 $m$：\n$ \\large \\begin{bmatrix} m \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; -1 \u0026amp; -1 \u0026amp; \\cdots \u0026amp; -1 \\ 0 \u0026amp; m \u0026amp; \\cdots \u0026amp; 0 \u0026amp; -1 \u0026amp; -1 \u0026amp; \\cdots \u0026amp; -1 \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; m \u0026amp; -1 \u0026amp; -1 \u0026amp; \\cdots \u0026amp; -1 \\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; n-\\frac{n}{m} \u0026amp; -\\frac{n}{m} \u0026amp; \\cdots \u0026amp; -\\frac{n}{m} \\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; -\\frac{n}{m} \u0026amp; n-\\frac{n}{m} \u0026amp; \\cdots \u0026amp; -\\frac{n}{m} \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \u0026amp; -\\frac{n}{m} \u0026amp; -\\frac{n}{m} \u0026amp; \\cdots \u0026amp; n-\\frac{n}{m} \\ \\end{bmatrix} $\n此时左下角都是 $0$ 了。\n于是乎，问题就转化为了以下两个矩阵的行列式之积：\n$ D_1= \\large \\begin{bmatrix} m \u0026amp; 0 \u0026amp; \\cdots \u0026amp; 0 \\ 0 \u0026amp; m \u0026amp; \\cdots \u0026amp; 0 \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; m \\end{bmatrix} $\n$ D_2= \\large \\begin{bmatrix} n-\\frac{n}{m} \u0026amp; -\\frac{n}{m} \u0026amp; \\cdots \u0026amp; -\\frac{n}{m} \\\\ -\\frac{n}{m} \u0026amp; n-\\frac{n}{m} \u0026amp; \\cdots \u0026amp; -\\frac{n}{m} \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ -\\frac{n}{m} \u0026amp; -\\frac{n}{m} \u0026amp; \\cdots \u0026amp; n-\\frac{n}{m} \\end{bmatrix} $\n（注意，$D_2$ 是个 $(m-1) \\times (m-1)$ 的矩阵，而不是 $m \\times m$ 的）\n$D_1$ 由于本身就是上三角矩阵，根据行列式性质，$\\det D_1=m^n$。\n但 $D_2$ 并不是，所以还要转化。\n（以下都针对 $D_2$ 矩阵进行转化）\n我们首先求出这 $m-1$ 行的和：\n$ \\begin{bmatrix} n-(m-1) \\times \\frac{n}{m} \u0026amp; n-(m-1) \\times \\frac{n}{m} \u0026amp; \\cdots \u0026amp; n-(m-1) \\times \\frac{n}{m} \\end{bmatrix} $\n其次把上述矩阵直接替换到第一行：\n$ \\begin{bmatrix} n-(m-1) \\times \\frac{n}{m} \u0026amp; n-(m-1) \\times \\frac{n}{m} \u0026amp; \\cdots \u0026amp; n-(m-1) \\times \\frac{n}{m} \\\\ -\\frac{n}{m} \u0026amp; n-\\frac{n}{m} \u0026amp; \\cdots \u0026amp; -\\frac{n}{m} \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ -\\frac{n}{m} \u0026amp; -\\frac{n}{m} \u0026amp; \\cdots \u0026amp; n-\\frac{n}{m} \\end{bmatrix} $\n发现第一行都是一样的，所以我们就把第一行统一除以 $n-(m-1) \\times \\frac{n}{m}$，行列式也除以了 $n-(m-1) \\times \\frac{n}{m}$，所以 $D_2$ 的行列式其实是下述矩阵的行列式乘上 $n-(m-1) \\times \\frac{n}{m}$：\n$ T= \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\\\ -\\frac{n}{m} \u0026amp; n-\\frac{n}{m} \u0026amp; \\cdots \u0026amp; -\\frac{n}{m} \\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ -\\frac{n}{m} \u0026amp; -\\frac{n}{m} \u0026amp; \\cdots \u0026amp; n-\\frac{n}{m} \\end{bmatrix} $\n（以下暂时换为针对 $T$ 矩阵进行转化）\n我们把第一行全部乘上 $\\frac{m}{n}$，然后加到下面每一行：（即把下面每一行内的 $-\\frac{n}{m}$ 都删掉）\n$ \\begin{bmatrix} 1 \u0026amp; 1 \u0026amp; \\cdots \u0026amp; 1 \\ 0 \u0026amp; n \u0026amp; \\cdots \u0026amp; 0 \\ \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ 0 \u0026amp; 0 \u0026amp; \\cdots \u0026amp; n \\end{bmatrix} $\n此时就是个上三角矩阵了，这个矩阵的行列式 $\\det T=n^{m-2}$，显然。\n但 $\\det D_2=(n-(m-1) \\times \\frac{n}{m}) \\times (\\det T)$，所以我们转化一下式子：\n（以下省略 $\\det D_2=$）\n带入 $\\det T$：\n$(n-(m-1) \\times \\frac{n}{m}) \\times n^{m-2}$\n拆括号：\n$n \\times n^{m-2}-(m-1) \\times \\frac{n}{m} \\times n^{m-2}$\n简化式子：\n$n^{m-1}-(m-1) \\times \\frac{n}{m} \\times n^{m-2}$\n拆开分数：\n$n^{m-1}-(m-1) \\times \\frac{1}{m} \\times n \\times n^{m-2}$\n即：\n$n^{m-1}-(m-1) \\times \\frac{1}{m} \\times n^{m-1}$\n拆括号：\n$n^{m-1}-(m \\times \\frac{1}{m}-\\frac{1}{m}) \\times n^{m-1}$\n即：\n$n^{m-1}-(1-\\frac{1}{m}) \\times n^{m-1}$\n拆括号：\n$n^{m-1}-(n^{m-1}-\\frac{1}{m} \\times n^{m-1})$\n拆括号：\n$n^{m-1}-n^{m-1}+\\frac{1}{m} \\times n^{m-1}$\n即：\n$\\frac{1}{m} \\times n^{m-1}$\n但还没完，答案是 $(\\det D_1) \\times (\\det D_2)$，所以需要推导一下：\n带入：\n$(m^n) \\times (\\frac{1}{m} \\times n^{m-1})$\n拆括号：\n$m^n \\times \\frac{1}{m} \\times n^{m-1}$\n即：\n$m^{n-1} \\times n^{m-1}$\n所以其实这题的代码很短，只用算 $m^{n-1} \\times n^{m-1}$ 的值即可。\n*注：这道题原题是M2733，另一种用Prufer序列证明这个答案的方法见本题写的题解，在题解文件夹内。\n","permalink":"https://qjwh.github.io/posts/oi/aln/kirchhoffmatrix/","summary":"\u003cp\u003e基尔霍夫矩阵是用来求解生成树计数、求（权值）和相关题目的利器。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-0-求完全图的生成树数量prufer序列\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 0. 求完全图的生成树数量（Prufer序列）\u003c/h3\u003e\n\u003cp\u003e要说基尔霍夫矩阵，就要从一道题目说起：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e给你 $n$，问 $n$ 个节点组成的无向无根树有多少种。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e这道题可以用Prufer序列去做。\u003c/p\u003e\n\u003cp\u003e这里简单说一下Prufer序列的求法：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e对于一张无向无根树，重复执行以下操作直到只剩 $2$ 个或更少的点，最后得到的那个序列 $a$ 就是这棵树的Prufer序列：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e我们找到此时度为 $1$ 的节点，若有多个，找编号最小的，设找到的节点编号为 $x$。\u003c/li\u003e\n\u003cli\u003e在 $a$ 的末尾添加：与 $x$ 有连边的那个唯一节点。\u003c/li\u003e\n\u003cli\u003e删除 $x$。\u003c/li\u003e\n\u003c/ul\u003e\u003c/blockquote\u003e\n\u003cp\u003ePrufer序列别看求法非常简单，也没啥容易发现的性质，其实用处很大。\u003c/p\u003e\n\u003cp\u003ePrufer序列满足一个性质，就是，所有无向无根树，都可以唯一地对应一个Prufer序列；所有Prufer序列都可以唯一地对应一棵树。\u003c/p\u003e\n\u003cp\u003e所以，这道题就有解了，答案其实就是长为 $n-2$ 的Prufer序列有多少种。\u003c/p\u003e\n\u003cp\u003e由于Prufer序列的每个元素的值都是从 $1$ 到 $n$ 的，所以答案就是 $n^{n-2}$，显然。\u003c/p\u003e\n\u003chr\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-11-求任意无向图的生成树数量基尔霍夫矩阵\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 1.1. 求任意无向图的生成树数量（基尔霍夫矩阵）\u003c/h3\u003e\n\u003cp\u003e但如果把题目变化一下，就不能用Prufer序列去求了：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e给你一张 $n$ 个节点 $m$ 条边的无向图，问这张图的生成树有多少个。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e这题要用基尔霍夫矩阵。\u003c/p\u003e\n\u003cp\u003e具体地，我们定义 $D$ 矩阵，求法：\u003c/p\u003e\n\u003cp\u003e$\nD_{i,j}=\n\\begin{cases}\n0 \u0026amp; i \\not= j \\\n\\text{deg}(i) \u0026amp; i=j\n\\end{cases}\n$\u003c/p\u003e\n\u003cp\u003e其中，$\\text{deg}(i)$ 代表这张图上 $i$ 的度是多少。\u003c/p\u003e","title":"基尔霍夫矩阵"},{"content":"\r按照正常的思路我们都直接将算法，但这会先讲一道题，然后再讲它的定义和求法。\n参考：\nABC335G题解 阶和原根 背景 是一场ABC335里的G题，当时在赛场上大概留了一个多小时的时间，但一直都在想用BSGS，但显然最后没想出来。\n而这题的瓶颈就在下面问题：\n对于两个数 $a,b$，是否存在一个 $x$ 使得同余方程 $a^x \\equiv b \\pmod p$ 有解。\n$a,b,p \\leq 10^{13}$（原题数据范围）\n大家看到的第一眼显然可以用BSGS求。\n但这个算法是 $O(\\sqrt p)$ 的（如果涉及到具体实现的话，可能还得乘个 $\\log \\sqrt p$，就是set、lower_bound查找的复杂度），比较适用于单组询问，很难推广应用。\n所以还有另外一种方式，比较适用于多组询问。\n是我们求出来 $a$ 和 $b$ 的阶，即 $\\text{ord}_p a$ 和 $\\text{ord}_p b$，看 $\\text{ord}_p b$ 是否是 $\\text{ord}_p a$ 的因子（$\\text{ord}_p b \\mid \\text{ord}_p a$）即可。\n这里先不证这个结论是否正确，但相信大家第一次看到“阶”的时候定然是一头雾水的，下面我就来说一下它的定义和求法。\n定义 阶 阶的话，跟逆元相似，还是需要两个值，只不过这里叫做“$a$ 在模 $p$ 意义下的阶”而已，换汤不换料。\n这个表示方法就是 $\\text{ord}_p a$。\n它的定义是：\n给你整数 $a$、$p$。 找到最小的 $x$，使得同余方程 $a^x \\equiv 1 \\pmod p$ 成立。 这个 $x$，就是$a$ 在模 $p$ 意义下的阶。 原根 但说到阶，我们定要讲一下它的孪生兄弟，原根了。\n原根的定义就是若 $\\text{ord}_p a=\\varphi(p)$，则称“$a$ 是 $p$ 的原根”。\n性质 阶和原根的定义都很简单，接下来说一下它们的性质。\n阶 首先，根据欧拉定理：\n对于任意两个互质的数 $a$ 和 $p$，$a^x \\equiv 1 \\pmod p$ 方程必然有解 $x=\\varphi(p)$。\n在 $a$ 和 $p$ 互质的时候，阶显然存在。\n但阶不一定是欧拉给出的解，但一定满足一个条件：\n$\\text{ord}_p a$ 是 $\\varphi(p)$ 的因子（$\\text{ord}_p a \\mid \\varphi(p)$）。 根据阶的定义，我们还可以得到两个推论：\n$a^1,a^2,a^3, \\dots a^{\\text{ord}_p a}$ 在模 $p$ 意义下互不相等。 $a^x \\equiv a^y \\pmod p \\Leftrightarrow x \\equiv y \\pmod {\\text{ord}_p a}$，充分必要条件。 还有很多的结论，具体可以看第二个参考文章。\n原根 这里的性质认为不太会考，所以没写。\n还是看第二个参考文章，里面也有证明。\n求值 最后就是求值。\n阶 由于 $\\text{ord}_p a \\mid \\varphi(p)$，所以只要求出 $\\varphi(p)$（多数时候 $p$ 都保证是质数，直接带 $p-1$ 即可），遍历其所有因子验证即可。\n但这里也有个技巧，就是因子不用一个一个遍历，显然 $\\text{ord}_p a$ 具有因子上的单调关系。\n说一下，正常情况下二分等算法都是“值上的单调关系”，就是 $x$ 成立，$x+k$（$k \\geq 0$）也一定成立。\n而“倍数上的单调关系”意思是 $x$ 成立，那么 $xk$（$k \\geq 1$）也成立。\n这里的“因子上的单调关系”意思是 $x$ 成立，那么 $\\dfrac{x}{k}$（$k \\geq 1$）也成立。\n所以只要做一下因式分解，然后从 $\\varphi(p)$ 开始，将这些质因子一个一个尝试除以即可。\n具体可以看参考文章，里面有代码。\n另外，阶还有一个特性，就是种类特别少，其实也能理解，因为本来因子就少。\n所以完全可以把所有的阶取出来后，去个重再计算。\n原根 由于原根数量很多，分布均匀，所以直接暴力求即可。\n","permalink":"https://qjwh.github.io/posts/oi/aln/orderandpr/","summary":"\u003ctext style=\"font-family:Noto Sans SC\"\u003e\r\n\u003cp\u003e按照正常的思路我们都直接将算法，但这会先讲一道题，然后再讲它的定义和求法。\u003c/p\u003e\n\u003cp\u003e参考：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/676549667\"\u003eABC335G题解\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.cnblogs.com/ac-evil/p/12809289.html\"\u003e阶和原根\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-背景\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 背景\u003c/h2\u003e\n\u003cp\u003e是一场\u003ca href=\"https://atcoder.jp/contests/abc335\"\u003eABC335\u003c/a\u003e里的\u003ca href=\"https://atcoder.jp/contests/abc335/tasks/abc335_g\"\u003eG题\u003c/a\u003e，当时在赛场上大概留了一个多小时的时间，但一直都在想用\u003ca href=\"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BSGS%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%9D%E7%89%88%EF%BC%89.md\"\u003eBSGS\u003c/a\u003e，但显然最后没想出来。\u003c/p\u003e\n\u003cp\u003e而这题的瓶颈就在下面问题：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e对于两个数 $a,b$，是否存在一个 $x$ 使得同余方程 $a^x \\equiv b \\pmod p$ 有解。\u003c/p\u003e\n\u003cp\u003e$a,b,p \\leq 10^{13}$（原题数据范围）\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e大家看到的第一眼显然可以用\u003ca href=\"/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BSGS%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%9D%E7%89%88%EF%BC%89.md\"\u003eBSGS\u003c/a\u003e求。\u003c/p\u003e\n\u003cp\u003e但这个算法是 $O(\\sqrt p)$ 的（如果涉及到具体实现的话，可能还得乘个 $\\log \\sqrt p$，就是\u003ccode\u003eset\u003c/code\u003e、\u003ccode\u003elower_bound\u003c/code\u003e查找的复杂度），比较适用于单组询问，很难推广应用。\u003c/p\u003e\n\u003cp\u003e所以还有另外一种方式，比较适用于多组询问。\u003c/p\u003e\n\u003cp\u003e是我们求出来 $a$ 和 $b$ 的阶，即 $\\text{ord}_p a$ 和 $\\text{ord}_p b$，看 $\\text{ord}_p b$ 是否是 $\\text{ord}_p a$ 的因子（$\\text{ord}_p b \\mid \\text{ord}_p a$）即可。\u003c/p\u003e\n\u003cp\u003e这里先不证这个结论是否正确，但相信大家第一次看到“阶”的时候定然是一头雾水的，下面我就来说一下它的定义和求法。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-定义\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 定义\u003c/h2\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-阶\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 阶\u003c/h3\u003e\n\u003cp\u003e阶的话，跟逆元相似，还是需要两个值，只不过这里叫做“$a$ 在模 $p$ 意义下的\u003cstrong\u003e阶\u003c/strong\u003e”而已，换汤不换料。\u003c/p\u003e\n\u003cp\u003e这个表示方法就是 $\\text{ord}_p a$。\u003c/p\u003e\n\u003cp\u003e它的定义是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e给你整数 $a$、$p$。\u003c/li\u003e\n\u003cli\u003e找到最小的 $x$，使得同余方程 $a^x \\equiv 1 \\pmod p$ 成立。\u003c/li\u003e\n\u003cli\u003e这个 $x$，就是$a$ 在模 $p$ 意义下的阶。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-原根\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 原根\u003c/h3\u003e\n\u003cp\u003e但说到阶，我们定要讲一下它的孪生兄弟，原根了。\u003c/p\u003e","title":"阶和原根"},{"content":"二维决策单调性 对于形如 $d_{i,j}=\\min\\limits_{k=0}^{i-1} \\Big( d_{k,j-1}+w(k+1,i) \\Big)$ 的方程，我们尝试记录 $f_{i,j}$ 代表 $d_{i,j}$ 的最优转移点（$k$ 变量），如果有 $f_{i,j-1} \\leq f_{i,j} \\leq f_{i+1,j}$，那么就是经典的四边形不等式优化，复杂度为 $O(n^2)$，证明此处略（在\u0026quot;四边形不等式相关.md\u0026quot;里有）。\n但是，如果只有 $f_{i,j} \\leq f_{i+1,j}$，那么就不能用四边形不等式优化了，需要用分治的方式优化。\n具体地，我们从小到大枚举 $j$，然后转移所有的 $d_{i,j}$。\n定义分治函数dp(l,r,jl,jr)代表我们要转移所有的 $d_{i,j}$（$l \\leq i \\leq r$），并且保证所有在本次分治转移范围内的 $d_{i,j}$ 的转移点 $f_{i,j}$ 都在 $[jl,jr]$ 内。\n我们可以先求出 $[l,r]$ 的中点 $mid$，然后转移 $d_{mid,j}$：暴力枚举转移点 $k$（当然，要在 $[jl,jr]$ 内）进行转移，并递归dp(l,mid-1,jl,最终转移点)和dp(mid+1,r,最终转移点,jr)。\n该算法复杂度为 $O(n^2 \\log n)$，证明：\n首先，枚举 $j$ 的复杂度 $O(n)$。\n其次，只看 $[jl,jr]$，$[jl,jr]$ 在递归的过程中就形成了个线段树的类似结构，只不过单层内可能有部分重叠位置，而且划分点（上面说的“最终转移点”）可能不是中点，不过无关紧要。\n然后，再看 $[l,r]$，$[l,r]$ 在递归过程中也形成了类似于线段树的结构，并且易证这个递归树深度是不会超过 $\\log n$ 的。\n有了深度的保证，而且一层内的 $[jl,jr]$ 区间长度和最多只有 $O(n)$ 级别，所以一次分治的复杂度就是 $O(n \\log n)$。\n一共 $n$ 次分治，总复杂度为 $O(n^2 \\log n)$。\n一维决策单调性 如果是一维的转移方程 $d_i=\\min\\limits_{j=0}^{i-1} \\Big( d_j+w(j+1,i) \\Big)$，如果也满足决策单调性（记 $d_i$ 的最优转移点为 $f_i$，那么就是说满足 $f_i \\leq f_{i+1}$），那么如何优化呢，可以用决策二分栈（说是用栈，但我看其他人大多都写的是队列）。\n下面统一设 $g(j,i)=d_j+w(j+1,i)$，并设 $c(x,y)$ 代表 $g(x,\\dots)$ 大于等于 $g(y,\\dots)$ 的最小下标，即 $c(x,y)$ 是满足 $g(x,p) \\geq g(y,p)$ 的最小 $p$，满足单调性，可以二分实现。\n这里说一下 $c(x,y)$ 的二段性证明，就是决策单调性有一个显然的推论，就是如果 $g(x,\\dots)$ 在某一刻超过（大于等于）了另外一个 $g(y,\\dots)$，且 $x\u0026lt;y$，那么 $g(y,\\dots)$ 就不可能再反超（大于等于）$g(x,\\dots)$ 了。\n（下述做法为假）\n我们用一个队列来维护若干个三元组 $[l,r,x]$，代表说照目前看来，$[l,r]$ 内的 $d$ 值都是从点 $x$ 转移最优。\n设当前要转移 $d_i$：\n首先，如果仍然满足 $g(队头,i) \\geq g(队头后面一个元素,i)$（队头较劣），那么弹出队头。 其次，如果队头的管辖范围仍然不包括 $i$（队头的 $[l,r]$ 不包含当前的 $i$），那么弹出队头。 拿队头的 $x$ 来转移 $d_i$。 然后，不断弹出队尾，找到 $g(i,\\dots)$ 超过或等于 $g(队尾的x,\\dots)$ 的最小下标（易证满足单调性，所以可以用二分来实现）$k$，然后弹出队尾，插入 $[原本队尾的l,k-1,原本队尾的x]$（如果这个三元组的区间为空或者已经无用，那么就不用插入了）和 $[k,n,i]$。 我们用一个队列 $q$（注意，这里的队列是手写队列）来维护若干个转移点，同时设 $k_i=c(q_i,q_{i+1})$。\n然后，就可以转移了：（设当前要转移 $d_i$，当前队列的第一个元素下标为 $h$，最后一个元素下标为 $t$）\n首先，只要队列大小大于等于 $2$ 且满足条件 $k_h \\leq i$（$g(q_h,i)$ 已经大于 $g(q_{h+1},i)$ 了，即前者已经比后者要劣了，并且后面不可能反转局面了），那么弹出队首。 其次，拿 $q_h$ 作为 $d_i$ 的转移点。 然后，只要队列大小大于等于 $2$ 且满足条件 $k_{t-1} \\geq c(q_t,i)$（这个条件可以自己画图理解），那么弹出队尾。 最后，将 $i$ 加入队尾并更新 $k$ 数组即可。 ","permalink":"https://qjwh.github.io/posts/oi/aln/juecedandiaoxing/","summary":"\u003ch2 id=\"二维决策单调性\"\u003e二维决策单调性\u003c/h2\u003e\n\u003cp\u003e对于形如 $d_{i,j}=\\min\\limits_{k=0}^{i-1} \\Big( d_{k,j-1}+w(k+1,i) \\Big)$ 的方程，我们尝试记录 $f_{i,j}$ 代表 $d_{i,j}$ 的最优转移点（$k$ 变量），如果有 $f_{i,j-1} \\leq f_{i,j} \\leq f_{i+1,j}$，那么就是经典的四边形不等式优化，复杂度为 $O(n^2)$，证明此处略（在\u0026quot;四边形不等式相关.md\u0026quot;里有）。\u003c/p\u003e\n\u003cp\u003e但是，如果只有 $f_{i,j} \\leq f_{i+1,j}$，那么就不能用四边形不等式优化了，需要用分治的方式优化。\u003c/p\u003e\n\u003cp\u003e具体地，我们从小到大枚举 $j$，然后转移所有的 $d_{i,j}$。\u003c/p\u003e\n\u003cp\u003e定义分治函数\u003ccode\u003edp(l,r,jl,jr)\u003c/code\u003e代表我们要转移所有的 $d_{i,j}$（$l \\leq i \\leq r$），并且保证所有在本次分治转移范围内的 $d_{i,j}$ 的转移点 $f_{i,j}$ 都在 $[jl,jr]$ 内。\u003c/p\u003e\n\u003cp\u003e我们可以先求出 $[l,r]$ 的中点 $mid$，然后转移 $d_{mid,j}$：暴力枚举转移点 $k$（当然，要在 $[jl,jr]$ 内）进行转移，并递归\u003ccode\u003edp(l,mid-1,jl,最终转移点)\u003c/code\u003e和\u003ccode\u003edp(mid+1,r,最终转移点,jr)\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e该算法复杂度为 $O(n^2 \\log n)$，证明：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e首先，枚举 $j$ 的复杂度 $O(n)$。\u003c/p\u003e\n\u003cp\u003e其次，只看 $[jl,jr]$，$[jl,jr]$ 在递归的过程中就形成了个线段树的类似结构，只不过单层内可能有部分重叠位置，而且划分点（上面说的“最终转移点”）可能不是中点，不过无关紧要。\u003c/p\u003e\n\u003cp\u003e然后，再看 $[l,r]$，$[l,r]$ 在递归过程中也形成了类似于线段树的结构，并且易证这个递归树深度是不会超过 $\\log n$ 的。\u003c/p\u003e\n\u003cp\u003e有了深度的保证，而且一层内的 $[jl,jr]$ 区间长度和最多只有 $O(n)$ 级别，所以一次分治的复杂度就是 $O(n \\log n)$。\u003c/p\u003e","title":"决策单调性"},{"content":"\r来源：ABC372G官方题解\n贡献：OI Wiki\n这个算法确实挺妙的，所以我就写个笔记。\n定义 这个算法需要用到一个函数：\n$$ f(a,b,c,n)=\\sum\\limits_{i=0}^n \\left\\lfloor \\dfrac{\\color{red}a\\color{default}i+\\color{blue}b\\color{default}}{\\color{green}c\\color{default}} \\right\\rfloor $$\n在下面参数 $a$、$b$、$c$ 都会用三种颜色标出，以便于区分。\n因为 $a$、$b$、$c$、$n$ 都很大，所以我们没法直接暴力求。\n数论分块显然也不彳亍。\n所以我们只能另辟蹊径了。\n求值 咱从简单到复杂走。\n1 首先，我们可以知道：\n$$ \\begin{aligned} f(a,b,c,n)\u0026amp;=\\sum\\limits_{i=0}^n \\left\\lfloor \\dfrac{\\color{red}a\\color{default}i+\\color{blue}b\\color{default}}{\\color{green}c\\color{default}} \\right\\rfloor \\ \u0026amp;=\\sum\\limits_{i=0}^n \\left\\lfloor \\dfrac{(\\lfloor \\frac{a}{c} \\rfloor c + a \\bmod c)i+(\\lfloor \\frac{b}{c} \\rfloor c + b \\bmod c)}{c} \\right\\rfloor \\ \u0026amp;=\\sum\\limits_{i=0}^n \\left\\lfloor \\dfrac{\\lfloor \\frac{a}{c} \\rfloor c \\cdot i + a \\bmod c \\cdot i+\\lfloor \\frac{b}{c} \\rfloor c + b \\bmod c}{c} \\right\\rfloor \\ \u0026amp;=\\sum\\limits_{i=0}^n \\left( \\left\\lfloor \\frac{a}{c} \\right\\rfloor i + \\left\\lfloor \\frac{b}{c} \\right\\rfloor + \\left\\lfloor \\dfrac{a \\bmod c \\cdot i+b \\bmod c}{c} \\right\\rfloor \\right) \\ \u0026amp;=\\dfrac{n(n+1)}{2} \\left\\lfloor \\frac{a}{c} \\right\\rfloor + (n+1) \\left\\lfloor \\frac{b}{c} \\right\\rfloor + \\sum\\limits_{i=0}^n \\left\\lfloor \\dfrac{\\color{red}a \\bmod c\\color{default} \\cdot i+\\color{blue}b \\bmod c\\color{default}}{\\color{green}c\\color{default}} \\right\\rfloor \\ \u0026amp;=\\dfrac{n(n+1)}{2} \\left\\lfloor \\frac{a}{c} \\right\\rfloor + (n+1) \\left\\lfloor \\frac{b}{c} \\right\\rfloor + f(a \\bmod c,b \\bmod c,c,n) \\ \\end{aligned} $$\n所以经过一番推导，我们就可以把 $f(a,b,c,n)$ 转换到 $a,b\u0026lt;c$ 的形式。\n2 但光是这样也不彳亍，我们并不知道这种形式如何处理，所以我们继续推导。\n考虑贡献转换：（公式看不清的话可以放大）\n$$ \\begin{aligned} f(a,b,c,n)\u0026amp;=\\sum\\limits_{i=0}^n \\left\\lfloor \\dfrac{\\color{red}a\\color{default}i+\\color{blue}b\\color{default}}{\\color{green}c\\color{default}} \\right\\rfloor \\ \u0026amp;=\\sum\\limits_{i=0}^n \\sum\\limits_{j=0}^{\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor-1} 1 \\ \u0026amp;=\\sum\\limits_{j=0}^{\\left\\lfloor \\frac{an+b}{c} \\right\\rfloor-1} \\sum\\limits_{i=0}^n \\left[ ~ j\u0026lt;\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor ~ \\right] \\ \\end{aligned} $$\n此时我们考虑把向下取整符号去掉：（$j \\in \\mathbb{Z}$）\n$$ j\u0026lt;\\lfloor x \\rfloor \\iff j+1 \\leq \\lfloor x \\rfloor \\iff j+1 \\leq x $$\n然后继续：（灰色是上面已有部分）\n$$ \\begin{aligned} f(a,b,c,n)\u0026amp;\\color{gray}=\\sum\\limits_{i=0}^n \\left\\lfloor \\dfrac{ai+b}{c} \\right\\rfloor \\ \u0026amp;\\color{gray}=\\sum\\limits_{i=0}^n \\sum\\limits_{j=0}^{\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor-1} 1 \\ \u0026amp;\\color{gray}=\\sum\\limits_{j=0}^{\\left\\lfloor \\frac{an+b}{c} \\right\\rfloor-1} \\sum\\limits_{i=0}^n \\left[ ~ j\u0026lt;\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor ~ \\right] \\ \u0026amp;=\\sum\\limits_{j=0}^{\\left\\lfloor \\frac{an+b}{c} \\right\\rfloor-1} \\sum\\limits_{i=0}^n \\left[ ~ j+1 \\leq \\frac{ai+b}{c} ~ \\right] \\ \u0026amp;=\\sum\\limits_{j=0}^{\\left\\lfloor \\frac{an+b}{c} \\right\\rfloor-1} \\sum\\limits_{i=0}^n \\left[ ~ jc+c \\leq ai+b ~ \\right] \\ \u0026amp;=\\sum\\limits_{j=0}^{\\left\\lfloor \\frac{an+b}{c} \\right\\rfloor-1} \\sum\\limits_{i=0}^n \\left[ ~ jc+c-b \\leq ai ~ \\right] \\ \u0026amp;=\\sum\\limits_{j=0}^{\\left\\lfloor \\frac{an+b}{c} \\right\\rfloor-1} \\sum\\limits_{i=0}^n \\left[ ~ jc+c-b-1\u0026lt;ai ~ \\right] \\ \u0026amp;=\\sum\\limits_{j=0}^{\\left\\lfloor \\frac{an+b}{c} \\right\\rfloor-1} \\sum\\limits_{i=0}^n \\left[ ~ \\left\\lfloor \\dfrac{jc+c-b-1}{a} \\right\\rfloor \u0026lt;i ~ \\right] \\ \\end{aligned} $$\n这下向下取整里面的东西和 $i$ 没关系了，消了。\n我们设 $m=\\left\\lfloor \\frac{an+b}{c} \\right\\rfloor$，继续：（灰色是上面已有部分）\n$$ \\begin{aligned} f(a,b,c,n)\u0026amp;\\color{gray}=\\sum\\limits_{i=0}^n \\left\\lfloor \\dfrac{ai+b}{c} \\right\\rfloor \\ \u0026amp;\\color{gray}=\\sum\\limits_{i=0}^n \\sum\\limits_{j=0}^{\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor-1} 1 \\ \u0026amp;\\color{gray}=\\sum\\limits_{j=0}^{m-1} \\sum\\limits_{i=0}^n \\left[ ~ j\u0026lt;\\left\\lfloor \\frac{ai+b}{c} \\right\\rfloor ~ \\right] \\ \u0026amp;\\color{gray}=\\sum\\limits_{j=0}^{m-1} \\sum\\limits_{i=0}^n \\left[ ~ j+1 \\leq \\frac{ai+b}{c} ~ \\right] \\ \u0026amp;\\color{gray}=\\sum\\limits_{j=0}^{m-1} \\sum\\limits_{i=0}^n \\left[ ~ jc+c \\leq ai+b ~ \\right] \\ \u0026amp;\\color{gray}=\\sum\\limits_{j=0}^{m-1} \\sum\\limits_{i=0}^n \\left[ ~ jc+c-b \\leq ai ~ \\right] \\ \u0026amp;\\color{gray}=\\sum\\limits_{j=0}^{m-1} \\sum\\limits_{i=0}^n \\left[ ~ jc+c-b-1\u0026lt;ai ~ \\right] \\ \u0026amp;\\color{gray}=\\sum\\limits_{j=0}^{m-1} \\sum\\limits_{i=0}^n \\left[ ~ \\left\\lfloor \\dfrac{jc+c-b-1}{a} \\right\\rfloor \u0026lt;i ~ \\right] \\ \u0026amp;=\\sum\\limits_{j=0}^{m-1} \\left( n-\\left\\lfloor \\dfrac{jc+c-b-1}{a} \\right\\rfloor \\right) \\ \u0026amp;=nm-\\sum\\limits_{j=0}^{m-1} \\left\\lfloor \\dfrac{j\\color{red}c\\color{default}+\\color{blue}c-b-1\\color{default}}{\\color{green}a\\color{default}} \\right\\rfloor \\ \u0026amp;=nm-f(c,c-b-1,a,m-1) \\ \\end{aligned} $$\n所以我们就可以通过一车操作把 $a$ 和 $c$ 交换。\n接下来我们继续像上面一样让 $a$ 模 $c$，以此往复，就像欧几里得算法一样。\n所以最终复杂度就是 $O(\\log)$ 级别的。\n总结 式子：\n$$ f(a,b,c,n)=\\dfrac{n(n+1)}{2} \\left\\lfloor \\frac{a}{c} \\right\\rfloor + (n+1) \\left\\lfloor \\frac{b}{c} \\right\\rfloor + f(a \\bmod c,b \\bmod c,c,n) $$\n设 $m=\\left\\lfloor \\frac{an+b}{c} \\right\\rfloor$：\n$$ f(a,b,c,n)=nm-f(c,c-b-1,a,m-1) $$\n递归即可。\n","permalink":"https://qjwh.github.io/posts/oi/aln/similargcd/","summary":"\u003ctext style=\"font-family:Noto Sans SC\"\u003e\r\n\u003cp\u003e来源：\u003ca href=\"https://atcoder.jp/contests/abc372/tasks/abc372_g\"\u003eABC372G\u003c/a\u003e\u003ca href=\"https://atcoder.jp/contests/abc372/editorial/10988\"\u003e官方题解\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e贡献：\u003ca href=\"https://oi-wiki.org/math/number-theory/euclidean\"\u003eOI Wiki\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e这个算法确实挺妙的，所以我就写个笔记。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-定义\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 定义\u003c/h2\u003e\n\u003cp\u003e这个算法需要用到一个函数：\u003c/p\u003e\n\u003cp\u003e$$\nf(a,b,c,n)=\\sum\\limits_{i=0}^n \\left\\lfloor \\dfrac{\\color{red}a\\color{default}i+\\color{blue}b\\color{default}}{\\color{green}c\\color{default}} \\right\\rfloor\n$$\u003c/p\u003e\n\u003cp\u003e在下面参数 $a$、$b$、$c$ 都会用三种颜色标出，以便于区分。\u003c/p\u003e\n\u003cp\u003e因为 $a$、$b$、$c$、$n$ 都很大，所以我们没法直接暴力求。\u003c/p\u003e\n\u003cp\u003e数论分块显然也不彳亍。\u003c/p\u003e\n\u003cp\u003e所以我们只能另辟蹊径了。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-求值\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 求值\u003c/h2\u003e\n\u003cp\u003e咱从简单到复杂走。\u003c/p\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-1\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 1\u003c/h3\u003e\n\u003cp\u003e首先，我们可以知道：\u003c/p\u003e\n\u003cp\u003e$$\n\\begin{aligned}\nf(a,b,c,n)\u0026amp;=\\sum\\limits_{i=0}^n \\left\\lfloor \\dfrac{\\color{red}a\\color{default}i+\\color{blue}b\\color{default}}{\\color{green}c\\color{default}} \\right\\rfloor \\\n\u0026amp;=\\sum\\limits_{i=0}^n \\left\\lfloor \\dfrac{(\\lfloor \\frac{a}{c} \\rfloor c + a \\bmod c)i+(\\lfloor \\frac{b}{c} \\rfloor c + b \\bmod c)}{c} \\right\\rfloor \\\n\u0026amp;=\\sum\\limits_{i=0}^n \\left\\lfloor \\dfrac{\\lfloor \\frac{a}{c} \\rfloor c \\cdot i + a \\bmod c \\cdot i+\\lfloor \\frac{b}{c} \\rfloor c + b \\bmod c}{c} \\right\\rfloor \\\n\u0026amp;=\\sum\\limits_{i=0}^n \\left( \\left\\lfloor \\frac{a}{c} \\right\\rfloor i + \\left\\lfloor \\frac{b}{c} \\right\\rfloor + \\left\\lfloor \\dfrac{a \\bmod c \\cdot i+b \\bmod c}{c} \\right\\rfloor \\right) \\\n\u0026amp;=\\dfrac{n(n+1)}{2} \\left\\lfloor \\frac{a}{c} \\right\\rfloor + (n+1) \\left\\lfloor \\frac{b}{c} \\right\\rfloor + \\sum\\limits_{i=0}^n \\left\\lfloor \\dfrac{\\color{red}a \\bmod c\\color{default} \\cdot i+\\color{blue}b \\bmod c\\color{default}}{\\color{green}c\\color{default}} \\right\\rfloor \\\n\u0026amp;=\\dfrac{n(n+1)}{2} \\left\\lfloor \\frac{a}{c} \\right\\rfloor + (n+1) \\left\\lfloor \\frac{b}{c} \\right\\rfloor + f(a \\bmod c,b \\bmod c,c,n) \\\n\\end{aligned}\n$$\u003c/p\u003e","title":"类欧几里得算法"},{"content":"\r马拉车算法其实就是解决一个字符串中由某个位置为中心的最大回文串长度：（下图中蓝色部分为字符串，绿色框中的值就是以这个位置为中心的最大回文串长度）\n其次，我们发现最底下的一排绿色数字涉及到空隙，所以我们可以把字符串扩展一下：\n比如，原字符串是 $\\texttt{abccabbc}$，那么扩展之后就是：\n（LaTeX炸了） $\\texttt{\\color{RoyalBlue}@\\color{default}#\\color{default}a\\color{RoyalBlue}#\\color{default}b\\color{RoyalBlue}#\\color{default}c\\color{RoyalBlue}#\\color{default}c\\color{RoyalBlue}#\\color{default}a\\color{RoyalBlue}#\\color{default}b\\color{RoyalBlue}#\\color{default}b\\color{RoyalBlue}#\\color{default}c\\color{RoyalBlue}#\\color{RoyalBlue}\u0026amp;}$\n第一个和最后一个字符可以自己定，但是最好不要和原字符串中的字符、中间插入的字符冲突（相等）。\n注：其实还有第二种扩展方法：\n$\\texttt{\\color{RoyalBlue}#\\color{default}a\\color{RoyalBlue}#\\color{default}b\\color{RoyalBlue}#\\color{default}c\\color{RoyalBlue}#\\color{default}c\\color{RoyalBlue}#\\color{default}a\\color{RoyalBlue}#\\color{default}b\\color{RoyalBlue}#\\color{default}b\\color{RoyalBlue}#\\color{default}c\\color{RoyalBlue}#\\color{default}}$\n还是，中间字符不能与原串字符相等。\n下面统一设「以下标 $i$ 为中心的最大回文串长度除以 $2$ 并下取整」后的答案为 $p_i$。\n然后，我们就开始求 $p$ 数组了，当我们求到 $p_i$ 的时候，我们看前面求出的 $p_j+j$ 的最大值是多少（设为 $r$），即 $\\max\\limits_{j=1}^{i-1} { p_j+j }$，同时求出最大的 $p_j+j$ 对应的 $j$（设为 $c$）。\n并且，我们求出 $i$ 的对称点 $i\u0026rsquo;$，对称中心为 $c$，显然 $i\u0026rsquo;=2c-i$。\n然后，分类讨论：\n注：图中 $r$ 的意思与上面说的 $r$ 的意思有冲突，统一以上面说的定义为准。\n$i\u0026gt;r$，那么暴力算 $p_i$。 $r-i \\geq p_{i\u0026rsquo;}$，那么 $p_i=p_{i\u0026rsquo;}$。 $r-i\u0026lt;p_{i\u0026rsquo;}$，那么让 $p_i=r-i$，继续暴力扩展。 最后就是时间复杂度问题了。\n关于时间复杂度的证明，我们可以分类讨论 $p_i$ 是用那种情况求值的：\n用情况1转移：$r$ 肯定会增加。 用情况2转移：复杂度忽略。 用情况3转移：$r$ 也肯定会增加。 由于每时每刻，$r$ 都小于等于 $n$，所以总复杂度就是 $O(n)$ 的。\n这里解释一个代码细节，我的模板中，可以发现 $p_i$ 赋的初始值是 $\\min(r-i,p_{i\u0026rsquo;})$，有人会问，如果最小值最后取的是 $p_{i\u0026rsquo;}$，会不会多复杂度（继续扩展）？答案是否定的，因为 $p_{i\u0026rsquo;}$ 是极大值，如果能继续扩展，那么 $p_{i\u0026rsquo;}$ 也会增大，证毕。\n","permalink":"https://qjwh.github.io/posts/oi/aln/manacher/","summary":"\u003ctext style=\"font-family:Lato,楷体\"\u003e\r\n\u003cp\u003e马拉车算法其实就是解决一个字符串中由某个位置为中心的最大回文串长度：（下图中蓝色部分为字符串，绿色框中的值就是以这个位置为中心的最大回文串长度）\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.luogu.com.cn/upload/image_hosting/z9ugcm59.png\"\u003e\u003c/p\u003e\n\u003cp\u003e其次，我们发现最底下的一排绿色数字涉及到空隙，所以我们可以把字符串扩展一下：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e比如，原字符串是 $\\texttt{abccabbc}$，那么扩展之后就是：\u003c/p\u003e\n\u003cp\u003e（LaTeX炸了）\n$\\texttt{\\color{RoyalBlue}@\\color{default}#\\color{default}a\\color{RoyalBlue}#\\color{default}b\\color{RoyalBlue}#\\color{default}c\\color{RoyalBlue}#\\color{default}c\\color{RoyalBlue}#\\color{default}a\\color{RoyalBlue}#\\color{default}b\\color{RoyalBlue}#\\color{default}b\\color{RoyalBlue}#\\color{default}c\\color{RoyalBlue}#\\color{RoyalBlue}\u0026amp;}$\u003c/p\u003e\n\u003cp\u003e第一个和最后一个字符可以自己定，但是最好不要和原字符串中的字符、中间插入的字符冲突（相等）。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e注：其实还有第二种扩展方法：\u003c/p\u003e\n\u003cp\u003e$\\texttt{\\color{RoyalBlue}#\\color{default}a\\color{RoyalBlue}#\\color{default}b\\color{RoyalBlue}#\\color{default}c\\color{RoyalBlue}#\\color{default}c\\color{RoyalBlue}#\\color{default}a\\color{RoyalBlue}#\\color{default}b\\color{RoyalBlue}#\\color{default}b\\color{RoyalBlue}#\\color{default}c\\color{RoyalBlue}#\\color{default}}$\u003c/p\u003e\n\u003cp\u003e还是，中间字符不能与原串字符相等。\u003c/p\u003e\u003c/blockquote\u003e\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e下面统一设「以下标 $i$ 为中心的最大回文串长度\u003cstrong\u003e除以 $2$ 并下取整\u003c/strong\u003e」后的答案为 $p_i$。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e然后，我们就开始求 $p$ 数组了，当我们求到 $p_i$ 的时候，我们看前面求出的 $p_j+j$ 的最大值是多少（设为 $r$），即 $\\max\\limits_{j=1}^{i-1} { p_j+j }$，同时求出最大的 $p_j+j$ 对应的 $j$（设为 $c$）。\u003c/p\u003e\n\u003cp\u003e并且，我们求出 $i$ 的对称点 $i\u0026rsquo;$，对称中心为 $c$，显然 $i\u0026rsquo;=2c-i$。\u003c/p\u003e\n\u003cp\u003e然后，分类讨论：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e注：图中 $r$ 的意思与上面说的 $r$ 的意思有冲突，统一以上面说的定义为准。\u003c/p\u003e\u003c/blockquote\u003e\n\u003col\u003e\n\u003cli\u003e$i\u0026gt;r$，那么暴力算 $p_i$。\n\u003cimg loading=\"lazy\" src=\"https://cdn.luogu.com.cn/upload/image_hosting/cqrtkobp.png\"\u003e\u003c/li\u003e\n\u003cli\u003e$r-i \\geq p_{i\u0026rsquo;}$，那么 $p_i=p_{i\u0026rsquo;}$。\n\u003cimg loading=\"lazy\" src=\"https://cdn.luogu.com.cn/upload/image_hosting/muq7kao8.png\"\u003e\u003c/li\u003e\n\u003cli\u003e$r-i\u0026lt;p_{i\u0026rsquo;}$，那么让 $p_i=r-i$，继续暴力扩展。\n\u003cimg loading=\"lazy\" src=\"https://cdn.luogu.com.cn/upload/image_hosting/zzacfutp.png\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e最后就是时间复杂度问题了。\u003c/p\u003e\n\u003cp\u003e关于时间复杂度的证明，我们可以分类讨论 $p_i$ 是用那种情况求值的：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e用情况1转移：$r$ 肯定会增加。\u003c/li\u003e\n\u003cli\u003e用情况2转移：复杂度忽略。\u003c/li\u003e\n\u003cli\u003e用情况3转移：$r$ 也肯定会增加。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e由于每时每刻，$r$ 都小于等于 $n$，所以总复杂度就是 $O(n)$ 的。\u003c/p\u003e","title":"马拉车算法"},{"content":"欧拉函数记为 $\\varphi$，$\\varphi(n)$ 代表 $1 \\sim n$ 内与 $n$ 互质的数的个数。\n欧拉函数有两种求法，下面分别说：\n直接求 我们设 $p$ 为 $n$ 的质因子集合（非可重集），那么 $\\varphi(n)=n \\times \\prod\\limits_{x \\in p} \\left( \\dfrac{x-1}{x} \\right)$，原理：\n我们设 $s$ 为目前与 $n$ 互质的数的集合，初始为 ${ 1,2,\\dots,n }$。\n每次遍历到一个 $p$ 中的数 $x$，就会筛掉这个集合中 $\\dfrac{1}{x}$ 的数，即那些是 $x$ 的倍数的数，由于 $p$ 是去重后的质因子集合，所以当前集合的大小总是 $x$ 的倍数。\n所以这个做法就能证明了，每乘一次 $\\dfrac{x-1}{x}$，都相当于筛掉当前集合内 $\\dfrac{1}{x}$ 的数，集合大小动态维护。\n模板代码：（代码中的 $p$ 数组是提前筛出来的质数集合，$ind$ 为其大小）\nLL phi(LL n){ if(n == 0) return 0; LL ret = n; rep(i, 1, ind){ if(n % p[i] == 0) ret = ret * 1 - ret / p[i], n /= p[i]; while(n % p[i] == 0) n /= p[i]; } if(n \u0026gt; 1) ret = ret * 1 - ret / n; return ret; } 通过线性筛预处理 线性筛模板：\nvoid shai(LL n){ f[0] = f[1] = true; rep(i, 2, n){ if(!f[i]) p[++ind] = i; for(LL j = 1;i * p[j] \u0026lt;= n;j++){ f[i * p[j]] = true; if(i % p[j] == 0) break; } } } 线性筛有一个性质，就是在第二重循环里，每次都会筛掉数 $i \\times p_j$，而 $p_j$ 正是这个数（$i \\times p_j$）的最小质因子。\n而欧拉函数是一个积性函数（定义一个函数 $f$ 是个积性函数有且仅当对于所有互质的对 $(i,j)$ 都满足 $f(i \\times j)=f(i) \\times f(j)$，而定义一个函数 $f$ 是个完全积性函数有且仅当对于所有的对 $(i,j)$ 都满足 $f(i \\times j)=f(i) \\times f(j)$，显然完全积性函数就是积性函数），所以我们就可以在线性筛模板的基础上改一下就是求欧拉函数的函数了：\nvoid shai(LL n){ f[0] = f[1] = true; rep(i, 2, n){ if(!f[i]){ p[++ind] = i; //显然 phi[i] = i - 1; } for(LL j = 1;i * p[j] \u0026lt;= n;j++){ f[i * p[j]] = true; if(i % p[j] == 0){ //由于i%p[j]=0，所以i中也存在质因子p[j] //所以，i*p[j]和i的质因子集合并没有变化，只是值乘了p[j]而已 //简单想一下可以发现，其实phi[i*p[j]]就是phi[i]的p[j]倍 phi[i * p[j]] = phi[i] * p[j]; break; } //积性函数性质 phi[i * p[j]] = phi[i] * phi[p[j]]; } } } ","permalink":"https://qjwh.github.io/posts/oi/aln/eulerfunc/","summary":"\u003cp\u003e欧拉函数记为 $\\varphi$，$\\varphi(n)$ 代表 $1 \\sim n$ 内与 $n$ 互质的数的个数。\u003c/p\u003e\n\u003cp\u003e欧拉函数有两种求法，下面分别说：\u003c/p\u003e\n\u003ch3 id=\"直接求\"\u003e直接求\u003c/h3\u003e\n\u003cp\u003e我们设 $p$ 为 $n$ 的质因子集合（非可重集），那么 $\\varphi(n)=n \\times \\prod\\limits_{x \\in p} \\left( \\dfrac{x-1}{x} \\right)$，原理：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e我们设 $s$ 为目前与 $n$ 互质的数的集合，初始为 ${ 1,2,\\dots,n }$。\u003c/p\u003e\n\u003cp\u003e每次遍历到一个 $p$ 中的数 $x$，就会筛掉这个集合中 $\\dfrac{1}{x}$ 的数，即那些是 $x$ 的倍数的数，由于 $p$ 是去重后的质因子集合，所以当前集合的大小总是 $x$ 的倍数。\u003c/p\u003e\n\u003cp\u003e所以这个做法就能证明了，每乘一次 $\\dfrac{x-1}{x}$，都相当于筛掉当前集合内 $\\dfrac{1}{x}$ 的数，集合大小动态维护。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e模板代码：（代码中的 $p$ 数组是提前筛出来的质数集合，$ind$ 为其大小）\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eLL\u003c/span\u003e \u003cspan class=\"nf\"\u003ephi\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eLL\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eLL\u003c/span\u003e \u003cspan class=\"n\"\u003eret\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003erep\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eind\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eret\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eret\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003eret\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e/=\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e/=\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eret\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eret\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003eret\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eret\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"通过线性筛预处理\"\u003e通过线性筛预处理\u003c/h3\u003e\n\u003cp\u003e线性筛模板：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eshai\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eLL\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003etrue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003erep\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e])\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"n\"\u003eind\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eLL\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e]]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003etrue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e线性筛有一个性质，就是在第二重循环里，每次都会筛掉数 $i \\times p_j$，而 $p_j$ 正是这个数（$i \\times p_j$）的最小质因子。\u003c/p\u003e","title":"欧拉函数"},{"content":"\r我们现在要解决一个问题，就如标题所说，我们要判断一个DAG的拓扑序是否唯一。\n以下说两种做法。\n做法1（推荐） 在拓扑排序时，我们只要每时每刻都判断一下，此时的队列大小是否大于 $1$ 即可。\n因为，如果队列大小大于 $1$，则选择任何一个元素都可以加入到拓扑序的最后下标，所以拓扑序不唯一。\n做法2 （以下是我考试时想出来的做法，思维难度较高，但整个构思过程中都没有思维跳跃）\n1 首先，我们建出这个DAG，然后我们考虑，其实一个DAG唯一，有且仅当对于所有点对 $(u,v)$（$1 \\leq u,v \\leq n$），都满足以下两点之一：\n点 $u$ 可以到达点 $v$。 点 $v$ 可以到达点 $u$。 此处证明一下。\n其实，如果存在一个不满足上述条件的点对 $(u,v)$，那么整张图可能会张这样：（下面标记的 $(u,v)$ 只是其中一个）\n在这种情况里，我们直接把红色集合和蓝色集合里的拓扑序“交换”，变成：\n于是乎，就得到了另一个合法的拓扑序，证毕。\n关于如果满足条件，则拓扑序唯一，此处不多赘述，自行脑补。\n2 上述条件还可以继续变化，变成：\n对于所有点对 $(u,v)$（$1 \\leq u,v \\leq n$，且 $v$ 的拓扑序比 $u$ 的要大），都满足点 $u$ 可以到达点 $v$。 3 我们考虑定义函数 $f(x)$ 代表拓扑序为 $x$ 的节点，是否能到达所有拓扑序为 $y$（$x\u0026lt;y$）的点。\n4 我们考虑求 $f(x)$，我们可以枚举拓扑序为 $x$ 的节点 $u$ 的所有出点 $v$（设其拓扑序为 $y$，且排除 $y \\leq x$ 的所有点）。\n然后，如果说 $f(y)$ 已经表示不可行了，输出无解。\n否则，拓扑序为 $y \\sim n$ 的点全部都可以被遍历到。\n5 然后，我们求出 $y$ 的最小值 $y_{\\min}$。\n那么，我们可以直接遍历到拓扑序在 $y_{\\min} \\sim n$ 内的所有点。\n所以，能遍历到 $x+1 \\sim n$ 内的所有点，有且仅当 $y_{\\min}$ 刚好等于 $x+1$，显然。\n而这个条件，就相当于说存在一个当前 $u$ 的出点 $v$，其拓扑序刚好比 $u$ 的拓扑序要大 $1$。\n6 有了这个条件，我们就可以直接判断了。\n但还没完，我们要判断两点特殊情况：\n如果入度为 $0$ 的点超过 $1$ 个，拓扑序不唯一。 如果出度为 $0$ 的点超过 $1$ 个，拓扑序不唯一。 ","permalink":"https://qjwh.github.io/posts/oi/aln/judgetopounique/","summary":"\u003ctext style=\"font-family:Lato,楷体\"\u003e\r\n\u003cp\u003e我们现在要解决一个问题，就如标题所说，我们要判断一个DAG的拓扑序是否唯一。\u003c/p\u003e\n\u003cp\u003e以下说两种做法。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-做法1推荐\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 做法1（推荐）\u003c/h2\u003e\n\u003cp\u003e在拓扑排序时，我们只要每时每刻都判断一下，此时的队列大小是否大于 $1$ 即可。\u003c/p\u003e\n\u003cp\u003e因为，如果队列大小大于 $1$，则选择任何一个元素都可以加入到拓扑序的最后下标，所以拓扑序不唯一。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-做法2\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 做法2\u003c/h2\u003e\n\u003cp\u003e（以下是我考试时想出来的做法，思维难度较高，但整个构思过程中都没有思维跳跃）\u003c/p\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-1\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 1\u003c/h3\u003e\n\u003cp\u003e首先，我们建出这个DAG，然后我们考虑，其实一个DAG唯一，有且仅当对于所有点对 $(u,v)$（$1 \\leq u,v \\leq n$），都满足以下两点之一：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e点 $u$ 可以到达点 $v$。\u003c/li\u003e\n\u003cli\u003e点 $v$ 可以到达点 $u$。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e此处证明一下。\u003c/p\u003e\n\u003cp\u003e其实，如果存在一个不满足上述条件的点对 $(u,v)$，那么整张图可能会张这样：（下面标记的 $(u,v)$ 只是其中一个）\u003c/p\u003e\n\u003cp\u003e在这种情况里，我们直接把红色集合和蓝色集合里的拓扑序“交换”，变成：\u003c/p\u003e\n\u003cp\u003e于是乎，就得到了另一个合法的拓扑序，证毕。\u003c/p\u003e\n\u003cp\u003e关于如果满足条件，则拓扑序唯一，此处不多赘述，自行脑补。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-2\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 2\u003c/h3\u003e\n\u003cp\u003e上述条件还可以继续变化，变成：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对于所有点对 $(u,v)$（$1 \\leq u,v \\leq n$，且 $v$ 的拓扑序比 $u$ 的要大），都满足点 $u$ 可以到达点 $v$。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-3\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 3\u003c/h3\u003e\n\u003cp\u003e我们考虑定义函数 $f(x)$ 代表拓扑序为 $x$ 的节点，是否能到达所有拓扑序为 $y$（$x\u0026lt;y$）的点。\u003c/p\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-4\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 4\u003c/h3\u003e\n\u003cp\u003e我们考虑求 $f(x)$，我们可以枚举拓扑序为 $x$ 的节点 $u$ 的所有出点 $v$（设其拓扑序为 $y$，且排除 $y \\leq x$ 的所有点）。\u003c/p\u003e","title":"判断拓扑序是否唯一"},{"content":"\r说到平衡树，很多人的第一印象就是：\n难学（知识点真多） 难懂（特别是“旋转”和证明） 难调（我的某个教练刚学平衡树的时候调了七个小时） 下面我们就来从0开始讲平衡树。\n（注：网上大多数人说到“平衡树”默认指的是“Splay”而不是其他算法）\n定义 其实平衡树（Balance Tree，简称BT）不算一种算法，而是一种统称。\n平衡树顾名思义就是非常平衡的树。\n比如说这棵树就非常不平衡：\n而这棵树就比较平衡：\n如果说的更形式化，平衡就意味着，对于每个点，其所有子树的大小差都不超过 $1$。\n具体而言，对于每个点 $x$，如果我们把其所有儿子 $to$ 的子树大小都列出来，那么这个数组内最大值和最小值差不超过 $1$。\n而且，大多数平衡树都是二叉树，这一点是为了方便操作和设计算法。\n种类 听完上面的定义，你就知道了，平衡树就是一类树状数据结构的统称。\n下面就来列举一下这类数据结构都有哪些，以及这些数据结构的简介。\n二叉搜索树（Binary Search Tree，简称BST） 大多数平衡树的前置算法，这也就意味着，大多数的平衡树都是基于BST并进行优化、扩展后得到的算法。\n而BST也是线段树（Segment Tree，部分情况下会简称为ST）进行扩展后的算法。\n具体而言，权值线段树和BST都可以维护有序集合，但有时候只能用BST解决。\nBST其实就是把权值“当做”节点编号（讲的时候一般就这么讲，但写的时候不能这么写，是把权值存入该节点的结构体内）。\n然后对于每个点，它都有最多 $2$ 个儿子，左儿子权值 $\u0026lt;$ 当前点权值 $\u0026lt;$ 右儿子权值。\n这样就可以方便查找。\n优点：代码好写，容易讲明白\n缺点：解决题型少，需要写定期重构（又被称作“替罪羊树思想”），复杂度高\nTreap（名字不是一个单词，而是两个单词Tree和Heap的结合） 这个算法给每个节点都添加了一个“优先级”，并让“优先级”满足小/大根堆的性质。\n并且，这里还通过“旋转”操作（最头疼的地方来了）让树尽量平衡，这样会让树高稳定在 $O(\\log n)$ 级别。\n（不过注意，在最坏情况下，复杂度会达到 $O(n)$，所以 $O(\\log n)$ 只是期望）\n这样，复杂度就降下来了。\n优点：复杂度低，比较容易理解，解决题型多，且容易被识别出\n缺点：比较难写，细节较多，复杂度难证明\nSplay（本意为“张开”但这里不是这个意思） 这个算法对上面的“旋转”操作又做了一遍扩展，让其能够解决子串翻转问题。\n而且，由于它也会让整棵树尽量平衡，所以树高还是会稳定在 $O(\\log n)$ 级别。\n（这里的 $O(\\log n)$ 应该也是期望）\n优点：复杂度低，解决题型多，且容易被识别出\n缺点：非常难写，细节贼多，非常难理解，复杂度依然很难证明\n依次讲解 接下来来分别看每种算法的实现与解决题型\n解决题型 下面默认都要解决P3369这道题。\n这种题型就是上面说的“维护集合”的题目。\n下面来看如何解决。\n权值线段树 看到这道题，很多人都会想到权值线段树（不过要先离散化）。\n我们就维护当前每个值域内的值个数。\n然后，可以发现，每种询问分别可以这样解决：\n单点修改 单点修改 区间求和 线段树上二分 线段树上二分 线段树上二分 具体细节这里不多说，可以看代码。\n时间复杂度：$O(n \\log n)$\n代码 递交到P3369即可AC const LL N = 1e5 + 10, Q = 1e5 + 10; LL qc; LL opt; LL x; struct Query{ LL opt; LL x; }; Query q[Q]; bs\u0026lt;LL\u0026gt; alls; #define find(x) (lower_bound(all(alls), x) - alls.begin() + 1) LL n; #define lc ((x) * 2) #define rc ((x) * 2 + 1) #define mid ((l) + ((r) - (l)) / 2) LL cnt[N * 4]; #define pushup(x) (cnt[x] = cnt[lc] + cnt[rc]) void updadd(LL x, LL l, LL r, LL mx, LL mv){ if(l == r){ cnt[x] += mv; return; } if(mx \u0026lt;= mid) updadd(lc, l, mid, mx, mv); else updadd(rc, mid + 1, r, mx, mv); pushup(x); } LL getsum(LL x, LL l, LL r, LL ql, LL qr){ if(ql \u0026gt; qr) return 0; if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return cnt[x]; LL ret = 0; if(ql \u0026lt;= mid) ret += getsum(lc, l, mid, ql, qr); if(mid + 1 \u0026lt;= qr) ret += getsum(rc, mid + 1, r, ql, qr); return ret; } LL getrkx(LL x, LL l, LL r, LL qx){ if(l == r) return alls[l - 1]; if(cnt[lc] \u0026gt;= qx) return getrkx(lc, l, mid, qx); else return getrkx(rc, mid + 1, r, qx - cnt[lc]); } #undef lc #undef rc #undef mid void solve(){ rd(qc); rep(i, 1, qc){ rd(opt), rd(x); q[i] = {opt, x}; if(opt != 4) alls += x; } sort(all(alls)); alls.erase(unique(all(alls)), alls.end()); n = sz(alls); rep(i, 1, qc){ LL opt = q[i].opt, \u0026amp;x = q[i].x; if(opt != 4) x = find(x); } rep(i, 1, qc){ LL opt = q[i].opt, x = q[i].x; if(opt == 1) updadd(1, 1, n, x, 1); else if(opt == 2) updadd(1, 1, n, x, -1); else if(opt == 3) printf(\u0026#34;%lld\\n\u0026#34;, getsum(1, 1, n, 1, x - 1) + 1); else if(opt == 4) printf(\u0026#34;%lld\\n\u0026#34;, getrkx(1, 1, n, x)); else if(opt == 5) printf(\u0026#34;%lld\\n\u0026#34;, getrkx(1, 1, n, getsum(1, 1, n, 1, x - 1))); else printf(\u0026#34;%lld\\n\u0026#34;, getrkx(1, 1, n, getsum(1, 1, n, 1, x) + 1)); } } 动态开点权值线段树 不过，像P6136这样，强制在线了，怎么搞？很简单，加个动态开点即可。\n就是动态开点可能不太好写，且常数、空间更大。\n其他的没变，只是用的是“动态开点权值线段树”而已。\n上联：可持久化带懒标记离线线段树\n下联：有限状态乌姆尼克权值自动机\n时间复杂度：$O(n \\log n)$\n代码 由于P6136过于卡空间，所以下面代码递交上去并不能AC，而是获得64分，所以仅供参考 const LL N = 1e5 + 10; LL n, qc; LL opt; LL x; #define lc (tlc[x]) #define rc (trc[x]) #define mid ((l) + ((r) - (l)) / 2) LL cnt[N * 77]; LL tlc[N * 77], trc[N * 77]; LL ind; #define pushup(x) (cnt[x] = cnt[lc] + cnt[rc]) LL newnode(){ ind++; cnt[ind] = 0; tlc[ind] = trc[ind] = 0; return ind; } void updadd(LL \u0026amp;x, LL l, LL r, LL mx, LL mv){ if(x == 0) x = newnode(); if(l == r){ cnt[x] += mv; return; } if(mx \u0026lt;= mid) updadd(lc, l, mid, mx, mv); else updadd(rc, mid + 1, r, mx, mv); pushup(x); } LL getsum(LL x, LL l, LL r, LL ql, LL qr){ if(ql \u0026gt; qr) return 0; if(ql \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= qr) return cnt[x]; LL ret = 0; if(ql \u0026lt;= mid \u0026amp;\u0026amp; lc) ret += getsum(lc, l, mid, ql, qr); if(mid + 1 \u0026lt;= qr \u0026amp;\u0026amp; rc) ret += getsum(rc, mid + 1, r, ql, qr); return ret; } LL getrkx(LL x, LL l, LL r, LL qx){ if(l == r) return l; if(cnt[lc] \u0026gt;= qx) return getrkx(lc, l, mid, qx); else return getrkx(rc, mid + 1, r, qx - cnt[lc]); } #undef lc #undef rc #undef mid LL ans; LL lans; void solve(){ rd(n), rd(qc); LL rt = 0; cir(n){ rd(x); updadd(rt, 0, (1 \u0026lt;\u0026lt; 30) - 1, x, 1); } rep(i, 1, qc){ rd(opt), rd(x); x ^= lans; if(opt == 1) updadd(rt, 0, (1 \u0026lt;\u0026lt; 30) - 1, x, 1); else if(opt == 2) updadd(rt, 0, (1 \u0026lt;\u0026lt; 30) - 1, x, -1); else if(opt == 3) ans ^= (lans = getsum(rt, 0, (1 \u0026lt;\u0026lt; 30) - 1, 1, x - 1) + 1 ); else if(opt == 4) ans ^= (lans = getrkx(rt, 0, (1 \u0026lt;\u0026lt; 30) - 1, x) ); else if(opt == 5) ans ^= (lans = getrkx(rt, 0, (1 \u0026lt;\u0026lt; 30) - 1, getsum(rt, 0, (1 \u0026lt;\u0026lt; 30) - 1, 1, x - 1))); else ans ^= (lans = getrkx(rt, 0, (1 \u0026lt;\u0026lt; 30) - 1, getsum(rt, 0, (1 \u0026lt;\u0026lt; 30) - 1, 1, x) + 1)); } printf(\u0026#34;%lld\\n\u0026#34;, ans); } 二叉搜索树 有人问，既然这题标题是“平衡树”，这题怎么修改，才能让这题没法用线段树解决？\n其实非常简单，这题是对数字做维护，我们改成维护pair、double、高精度整数，就无法用线段树解决，或者复杂度炸裂。\n这时候，我们就要引入一个新算法——二叉搜索树（BST）了。\n概览 正如简介中所说，BST是个左 $\u0026lt;$ 中 $\u0026lt;$ 右（指权值）结构的二叉树。\n而这样的结构，就是为了方便插入和删除而设的。\n初始化 如果给你一个序列，通过合理的方式，可以让BST的深度达到 $O(\\log n)$ 级别。\n其实现方式很简单，把这个序列从小到大排序，每次选择中间的元素 $\\text{mid}$ 作为根，把比 $\\text{mid}$ 小的作为左子树，大的作为右子树。\n这样就是一个“类线段树结构”，树高一定是 $O(\\log n)$ 的。\n插入节点 接下来考虑插入。\n其实很简单，如果当前节点权值比插入权值大，就递归左儿子，否则递归右儿子。\n如果没有，则新建并退出函数。\n删除节点 然后考虑删除。\n如果删除节点 $x$ 是叶子节点，那么可以直接删除。\n否则，如果直接删除 $x$ 的话，就会导致整棵树分裂。\n为了防止分裂，我们必须找一个节点出来，来代替节点 $x$，这样就可以直接删除 $x$ 点了。\n为了保证BST的性质仍然满足，我们可以找到节点 $x$ 左子树中权值最大的那个，或者右子树中权值最小的。\n找到这个点的话很简单，可以直接暴力。\n由于BST要求左子树内的所有权值 $\u0026lt;$ 右子树内的所有权值，所以我们可以贪心。\n递归过程中，无脑一直往左/右儿子走，如果都没有则返回。\n然后，我们把这个节点和 $x$ 交换，并删除此时的 $x$ 点即可。\n其他四种操作 类似于线段树上二分。\n复杂度证明 时间复杂度：$O(?)$\n看见那个“$?$”就说明我们得证明一下复杂度才能定结论。\n可以发现，无论是删除、查询排名、查询前驱后继，这个复杂度其实都是和树高有关的。\n而且，似乎插入对树高没什么影响啊，直接 $O(n \\log n)$，用啥平衡树。\n但是，这种做法复杂度并不是 $O(n \\log n)$。\n我们考虑一个极限数据。\n我们依次插入 $1$、$2$、$3$、$4$、$\\dots$、$5 \\times 10^4$，这样就会让树高达到 $5 \\times 10^4$ 而不是理想的 $\\log n$。\n这样的话，只要我们 $5 \\times 10^4$ 次操作里，每次都查询一下 $5 \\times 10^4$（最大数）的前驱，或者 $1$（最小数）的后继。\n那么，复杂度就会达到 $O \\left( \\left( 5 \\times 10^4 \\right)^2 \\right)$，爆炸。\n所以我们考虑优化。\n定期重构 其实上面的简介里也剧透了一点，就是我们考虑定期重构。\n有一种算法叫“替罪羊树”，就是用定期重构来实现定期重构的平衡树，所以定期重构又被我称为“替罪羊树思想”。\n而且，定期重构一般是每 $\\sqrt n$ 次变化重构一次。\n但这题里，只有插入操作会让树高变高，所以我们只要每加入 $\\sqrt n$ 个数进行重构即可。\n重构就是上面说的“初始化操作”，复杂度是 $O(n)$ 的。\n所以总复杂度是 $O(n \\sqrt n)$，因为瓶颈在于重构而不是查询。\n这下复杂度就是大概率能接受的了。\n代码 做法假了，因为删除操作里，顶替的那个点不一定为叶子节点，目前还没有解决该bug的思路 Treap 但这个复杂度还不够优，我们得把它优化成 $O(n \\log n)$。\n不过我们已经无法在算法上优化了，我们得换一种做法。\n我们考虑Treap。\n概览 其实Treap就是BST的扩展版。\nBST是单单维护权值，但Treap还要维护一个“优先级”。\n这个优先级是随机的，这也是它树高的保证。（这个证明过于复杂难懂，这里就不说了）\n并且，在简介里也说了，优先级是满足小/大根堆性质的。\n正是因为这一点，Treap的结构才是唯一的。（这个容易证明，随便找一个构造方式你就知道为啥了）\n旋转 （最头疼的地方来了）\n不过我们发现，不像BST，Treap的插入并不一定找到一个插入的地方。\n所以，我们得尝试变化一下结构。\n变化结构的方式被称为“旋转”\n传入参数是一个 $x$，我们尝试把 $x$ 平移到 $x$ 的父亲的父亲位置。\n这里的“平移”可以这么理解，我们设 $fa$ 为 $x$ 的父亲，那么：\n如果 $x$ 是 $fa$ 的左儿子，则旋转后 $fa$ 要作为 $x$ 的右儿子。 如果 $x$ 是 $fa$ 的右儿子，则旋转后 $fa$ 要作为 $x$ 的左儿子。 但这个旋转也不那么简单。\n因为 $x$ 的两个儿子的子树，还有 $fa$ 的某个子树，其排列位置可能会改变。\n具体而言，它们会这么变化：\n这种变化方式可以用代码实现：\nvoid rotate(LL x){ if(fa(x) == rt) rt = x; //根节点特判 LL y = fa(x), z = fa(y), p = sp(x); //x的父亲、x的祖父、x是哪个儿子 sons(y, p) = sons(x, !p), sons(x, !p) = y, fa(sons(y, p)) = y; //交换子树 fa(x) = fa(y), fa(y) = x; //更换父亲节点 pushup(x), pushup(y); //pushup if(z){ //如果x的祖父存在 sons(z, rc(z) == y) = x; //则变化其的儿子节点为x pushup(z); //然后重新pushup } } 注：\n上面图里有两个操作，“左旋（Left Rotation）”和“右旋（Left Rotation）”。\n但这里只写了一个函数，有人问这个函数实现的是什么旋？其实这个函数其实既实现了左旋，又实现了右旋。\n而这一点怎么理解呢？可以发现，用哪种旋法，只取决于这个点是左还是右儿子。\n如果是左儿子，那么就得用右旋，否则用左旋。\n所以上面代码既实现了左旋（节点 $x$ 为右儿子），也实现了右旋（节点 $x$ 为左儿子）。\n在Splay里，会对“旋转”做升级（添加了一个splay操作，但rotate操作没变），这时候会更头疼。\n附：\nTreap要维护的信息：\nstruct Node{ LL val; //权值 LL pri; //优先级 LL sz; //子树大小 LL fath; //父亲节点 LL sons[2]; //两个儿子 }; Treap的#define有：\n#define val(x) (a[x].val) #define pri(x) (a[x].pri) #define sz(x) (a[x].sz) #define fa(x) (a[x].fath) #define sons(x, p) (a[x].sons[p]) #define lc(x) sons(x, 0) #define rc(x) sons(x, 1) #define sp(x) (rc(fa(x)) == x) //x的在哪个儿子上 #define pushup(x) (sz(x) = sz(lc(x)) + sz(rc(x))) //pushup操作 这些信息只是为了方便理解代码，不用全抄。\n插入 在插入操作里，我们先忽略优先级，按BST的性质找到插入点。\n然后，从该点遍历到根。\n遍历到某个点的时候，如果该点的优先级比它的父亲的要小（假设要求优先级满足大根堆性质）。\n那么，我们就得调用旋转操作，把当前点旋上去。\n由于Treap的结构唯一且期望高度为 $O(\\log n)$，并且最后整棵树必然满足Treap性质。\n所以，插入操作不会对树高产生影响。\n删除 删除的话，如果是叶子节点那么直接删。\n否则，我们找到删除节点编号，并从这个地方开始往下递归。\n每次我们看当前点的两个子节点，选择优先级较大的点，将其旋转到父亲那里，并递归到这个子节点。\n这样不断旋转，就会使得删除节点为叶子，就直接删即可。\n最后树结构满足Treap性质，所以不会对树高产生影响。\n其他四种操作 可参考BST。\n复杂度 复杂度还是与树高有关。\n由于优先级随机，期望树高是 $O(\\log n)$，所以复杂度就是 $O(q \\log n)$。\n代码 不合并相同权值版：\n递交到P6136即可AC const LL N = 1e5 + 10, Q = 1e6 + 10; random_device rand_seed; mt19937_64 _rand(time(0) ^ clock() ^ rand_seed()); #define random(l, r) (_rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l)) LL n, qc; LL opt; LL x; struct Node{ LL val; //权值 LL pri; //优先级 LL sz; //子树大小 LL ma; //子树内权值最大值 LL fath; //父亲节点 LL sons[2]; //两个儿子 }; #define val(x) (a[x].val) #define pri(x) (a[x].pri) #define sz(x) (a[x].sz) #define ma(x) (a[x].ma) #define fa(x) (a[x].fath) #define sons(x, p) (a[x].sons[p]) #define lc(x) sons(x, 0) #define rc(x) sons(x, 1) Node a[N + Q]; LL ind; LL rt; //由于涉及交换，所以这里要专门存储根节点编号 bool flag = false; //根节点是否被删掉 #define sp(x) (rc(fa(x)) == x) #define pushup(x) (sz(x) = sz(lc(x)) + 1 + sz(rc(x)), ma(x) = max({ma(lc(x)), val(x), ma(rc(x))})) void rotate(LL x){ if(fa(x) == rt) rt = x; //如果是把某个根节点的儿子rotate上去，则这个儿子要作为新的根节点 LL y = fa(x), z = fa(y), p = sp(x); //x的父亲、x的祖父、x是哪个儿子 sons(y, p) = sons(x, !p), sons(x, !p) = y, fa(sons(y, p)) = y; //交换子树 fa(x) = fa(y), fa(y) = x; //更换父亲节点 pushup(y), pushup(x) /* 这里要注意顺序，先对y点做pushup，然后才对其父亲x做pushup，这样才能让信息传达正确 */; //pushup if(z){ //如果x的祖父存在 sons(z, rc(z) == y) = x; //则变化其的儿子节点为x pushup(z); //然后重新pushup } } LL newnode(LL v, LL fa){ ind++; val(ind) = v; pri(ind) = random(1, 1e18); sz(ind) = 1; ma(ind) = v; fa(ind) = fa; lc(ind) = rc(ind) = 0; return ind; } void add(LL x){ if(ind == 0){ rt = newnode(x, 0); return; } if(flag){ ind = 0, flag = false, rt = newnode(x, 0); return; } LL p = rt, ip = 0; while(true){ LL \u0026amp;to = (x \u0026lt;= val(p) ? lc(p) : rc(p)); if(to == 0){ ip = to = newnode(x, p); break; } else p = to; } while(ip \u0026gt; 1) if(pri(ip) \u0026lt; /* 如果要求pri为大根堆，这里应该写\u0026gt;，但代码里要求pri为小根堆 */ pri(fa(ip))) rotate(ip); //这里rotate之后，底下不用把ip再设成fa(ip)，因为rotate已经把fa值更新了 else break; while(ip) pushup(ip), ip = fa(ip); } void delnode(LL x){ if(x == rt) flag = true; val(x) = 0; pri(x) = 0; sz(x) = 0; ma(x) = 0; sons(fa(x), sp(x)) = 0; fa(x) = 0; lc(x) = rc(x) = 0; } void del(LL x){ LL p = rt; while(true){ LL lc = lc(p), rc = rc(p); if(x == val(p)) break; else if(x \u0026lt; val(p)) p = lc; else p = rc; } if(lc(p) == 0 \u0026amp;\u0026amp; rc(p) == 0){ LL t = fa(p); delnode(p); p = t; while(p) pushup(p), p = fa(p); //这里要记得pushup //这里要return，因为如果涉及到这种情况，那么执行完while循环，p一定为0，这时候下面代码就很可能会死循环 //具体原因不详，但能大概确定是0有儿子导致的死循环 return; } while(true){ LL lc = lc(p), rc = rc(p); //还是，下面p不用专门设成lc或rc if(lc == 0 \u0026amp;\u0026amp; rc == 0) break; else if(rc == 0) rotate(lc); else if(lc == 0) rotate(rc); else{ if(pri(lc) \u0026gt;= pri(rc)) rotate(lc); else rotate(rc); } } LL t = fa(p); delnode(p); p = t; while(p) pushup(p), p = fa(p); //这里要记得pushup } LL getsm(LL x){ if(ind == 0 || flag) return 0; //此处要判断树为空的情况，这时候要及时返回0 LL p = rt; LL ret = 0; while(true){ if(val(p) \u0026lt;= x) ret++; LL lc = lc(p), rc = rc(p); if(lc == 0 \u0026amp;\u0026amp; rc == 0) break; else if(rc == 0) p = lc; else if(lc == 0) p = rc; else{ if(x \u0026lt; ma(lc)) p = lc; else ret += sz(lc), p = rc; } } return ret; } LL getrk(LL x){ LL p = rt; while(true){ LL lc = lc(p), rc = rc(p); if(lc == 0 \u0026amp;\u0026amp; rc == 0){ if(x == 1) return val(p); else return -1; }else if(rc == 0){ if(x == sz(lc) + 1) return val(p); else if(1 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= sz(lc)) p = lc; else return -2; }else if(lc == 0){ if(x == 1) return val(p); else if(2 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= sz(rc) + 1) x--, p = rc; else return -3; }else{ if(x \u0026lt;= sz(lc)) p = lc; else if(x == sz(lc) + 1) return val(p); else x -= sz(lc) + 1, p = rc; } } return -4; } LL ans; LL lans; void solve(){ rd(n), rd(qc); rep(i, 1, n){ rd(x); add(x); } rep(i, 1, qc){ rd(opt), rd(x); x ^= lans; if(opt == 1) add(x); else if(opt == 2) del(x); else if(opt == 3) ans ^= (lans = getsm(x - 1) + 1 ); else if(opt == 4) ans ^= (lans = getrk(x) ); else if(opt == 5) ans ^= (lans = getrk(getsm(x - 1))); else ans ^= (lans = getrk(getsm(x) + 1)); } printf(\u0026#34;%lld\\n\u0026#34;, ans); } 合并相同权值版：\n递交到P6136即可AC const LL N = 1e5 + 10, Q = 1e6 + 10; random_device rand_seed; mt19937_64 _rand(time(0) ^ clock() ^ rand_seed()); #define random(l, r) (_rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l)) LL n, qc; LL opt; LL x; struct Node{ LL val; //权值 LL cnt; //权值出现次数（这也就意味着我们把相同的权值都合并到一个点上了） LL pri; //优先级 LL sz; //子树大小 LL ma; //子树内权值最大值 LL fath; //父亲节点 LL sons[2]; //两个儿子 }; #define val(x) (a[x].val) #define vcnt(x) (a[x].cnt) #define pri(x) (a[x].pri) #define sz(x) (a[x].sz) #define ma(x) (a[x].ma) #define fa(x) (a[x].fath) #define sons(x, p) (a[x].sons[p]) #define lc(x) sons(x, 0) #define rc(x) sons(x, 1) Node a[N + Q]; LL ind; LL rt; //由于涉及交换，所以这里要专门存储根节点编号 bool flag = false; //根节点是否被删掉 #define sp(x) (rc(fa(x)) == x) #define pushup(x) (sz(x) = sz(lc(x)) + vcnt(x) + sz(rc(x)), ma(x) = max({ma(lc(x)), val(x), ma(rc(x))})) void rotate(LL x){ if(fa(x) == rt) rt = x; //如果是把某个根节点的儿子rotate上去，则这个儿子要作为新的根节点 LL y = fa(x), z = fa(y), p = sp(x); //x的父亲、x的祖父、x是哪个儿子 sons(y, p) = sons(x, !p), sons(x, !p) = y, fa(sons(y, p)) = y; //交换子树 fa(x) = fa(y), fa(y) = x; //更换父亲节点 pushup(y), pushup(x) /* 这里要注意顺序，先对y点做pushup，然后才对其父亲x做pushup，这样才能让信息传达正确 */; //pushup if(z){ //如果x的祖父存在 sons(z, rc(z) == y) = x; //则变化其的儿子节点为x pushup(z); //然后重新pushup } } LL newnode(LL v, LL fa){ ind++; val(ind) = v; vcnt(ind) = 1; pri(ind) = random(1, 1e18); sz(ind) = 1; ma(ind) = v; fa(ind) = fa; lc(ind) = rc(ind) = 0; return ind; } void add(LL x){ if(ind == 0){ rt = newnode(x, 0); return; } if(flag){ ind = 0, flag = false, rt = newnode(x, 0); return; } LL p = rt, ip = 0; while(true){ if(x == val(p)){ vcnt(p)++; while(p) sz(p)++, p = fa(p); //这里要把sz值一并变化，并且不止变化p return; } LL \u0026amp;to = (x \u0026lt; val(p) ? lc(p) : rc(p)); if(to == 0){ ip = to = newnode(x, p); break; } else p = to; } while(ip \u0026gt; 1) if(pri(ip) \u0026lt; /* 如果要求pri为大根堆，这里应该写\u0026lt;，但代码里要求pri为小根堆 */ pri(fa(ip))) rotate(ip); //这里rotate之后，底下不用把ip再设成fa(ip)，因为rotate已经把fa值更新了 else break; while(ip) pushup(ip), ip = fa(ip); } void delnode(LL x){ val(x) = 0; vcnt(x) = 0; pri(x) = 0; sz(x) = 0; ma(x) = 0; sons(fa(x), sp(x)) = 0; fa(x) = 0; lc(x) = rc(x) = 0; } void del(LL x){ LL p = rt; while(true){ LL lc = lc(p), rc = rc(p); if(x == val(p)) break; else if(x \u0026lt; val(p)) p = lc; else p = rc; } if(vcnt(p) \u0026gt; 1){ vcnt(p)--; while(p) sz(p)--, p = fa(p); //这里要把sz值一并变化，并且不止变化p return; } if(lc(p) == 0 \u0026amp;\u0026amp; rc(p) == 0){ LL t = fa(p); delnode(p); p = t; while(p) pushup(p), p = fa(p); //这里要记得pushup //这里要return，因为如果涉及到这种情况，那么执行完while循环，p一定为0，这时候下面代码就很可能会死循环 //具体原因不详，但能大概确定是0有儿子导致的死循环 return; } while(true){ LL lc = lc(p), rc = rc(p); //还是，下面p不用专门设成lc或rc if(lc == 0 \u0026amp;\u0026amp; rc == 0) break; else if(rc == 0) rotate(lc); else if(lc == 0) rotate(rc); else{ if(pri(lc) \u0026gt;= pri(rc)) rotate(lc); else rotate(rc); } } LL t = fa(p); delnode(p); p = t; while(p) pushup(p), p = fa(p); //这里要记得pushup } LL getsm(LL x){ if(ind == 0 || flag) return 0; //此处要判断树为空的情况，这时候要及时返回0 LL p = rt; LL ret = 0; while(true){ if(val(p) \u0026lt;= x) ret += vcnt(p); LL lc = lc(p), rc = rc(p); if(lc == 0 \u0026amp;\u0026amp; rc == 0) break; else if(rc == 0) p = lc; else if(lc == 0) p = rc; else{ if(x \u0026lt; ma(lc)) p = lc; else ret += sz(lc), p = rc; } } return ret; } LL getrk(LL x){ LL p = rt; while(true){ LL lc = lc(p), rc = rc(p); if(lc == 0 \u0026amp;\u0026amp; rc == 0){ if(1 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= vcnt(p)) return val(p); else return -1; }else if(rc == 0){ if(1 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= sz(lc)) p = lc; else if(sz(lc) + 1 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= sz(lc) + vcnt(p)) return val(p); else return -2; }else if(lc == 0){ if(1 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= vcnt(p)) return val(p); else if(vcnt(p) + 1 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= vcnt(p) + sz(rc)) x -= vcnt(p), p = rc; else return -3; }else{ if(1 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= sz(lc)) p = lc; else if(sz(lc) + 1 \u0026lt;= x \u0026amp;\u0026amp; x \u0026lt;= sz(lc) + vcnt(p)) return val(p); else x -= sz(lc) + vcnt(p), p = rc; } } return -4; } LL ans; LL lans; void solve(){ rd(n), rd(qc); rep(i, 1, n){ rd(x); add(x); } rep(i, 1, qc){ rd(opt), rd(x); x ^= lans; if(opt == 1) add(x); else if(opt == 2) del(x); else if(opt == 3) ans ^= (lans = getsm(x - 1) + 1 ); else if(opt == 4) ans ^= (lans = getrk(x) ); else if(opt == 5) ans ^= (lans = getrk(getsm(x - 1))); else ans ^= (lans = getrk(getsm(x) + 1)); } printf(\u0026#34;%lld\\n\u0026#34;, ans); } Splay 不过如果出现更多种类的修改、查询呢？我们可以考虑Splay。\n概览 接下来是Splay，其实Splay能解决所有Treap能解决的问题，同时还可以解决区间修改、翻转、查询问题。\n不过其缺点上面也说了，非常难写、细节贼多、非常难理解、复杂度很难证明，不过这些缺点是因人而异的。\n并且，在比赛里，能用权值线段树就用，不能用就用Treap，如果仍然不能用再用Splay。\n因为Splay本身常数就不算小，并且有时候写挂一个小点可能连对拍都拍不出来。\n旋转 上面剧透了一下，就是Splay里会对旋转做升级，这里说一下是如何升级的。\n其实上面说的添加的splay操作，并不是什么很高深的操作，其原理就是把传入的那个点，一路旋转到根。\n我们假设传入的点为 $x$ 号点，且设：\n$y$ 为 $x$ 的父亲 $z$ 为 $x$ 的祖父，即 $y$ 的父亲 那么我们就考虑先通过若干次rotate操作，让 $x$ 在 $x$、$y$、$z$ 三点中深度最浅。\n我们可以分两种情况：\n$x$ 和 $y$ 是一个儿子方向： $x$ 和 $y$ 不是一个儿子方向： （图源网络，在这篇博客里）\n不过前提 $z$ 是存在的。\n这样，我们就可以写出splay操作的代码：\nvoid splay(LL x){ //将一个点x旋转到根 //如果x和fa（x的父亲）的子节点关系一致，则旋转fa后旋转x //否则，旋转两次x for(LL fa = fa(x);fa;rotate(x) /* rotate完后不用把x赋值为其父亲 */, fa = fa(x)) if(fa(fa)) rotate(sp(x) == sp(fa) ? fa : x); rt = x; } （提前剧透一下，在底下splay操作的实现会变）\n插入 如果树为空，直接新建节点加入树中即可。\n否则我们仿照Treap的“合并相同权值版本”代码实现即可。\n不过注意，在找到加入位置后，一定要把插入的位置旋转到根。\n放代码：\nvoid add(LL x){ //添加数x（且将数x旋转到根） //特判树为空 if(rt == 0){ ind = 0; rt = newnode(x, 0); return; } //找到添加点 LL p = rt; while(true){ //如果有相同的权值，直接cnt++即可 if(val(p) == x){ cnt(p)++; pushup(fa(p)); splay(p); return; } //否则找到去哪个儿子 LL \u0026amp;to = sons(p, x \u0026gt; /* 这里是大于 */ val(p)); //如果该儿子没有 if(to == 0){ //则新增 to = newnode(x, p); pushup(p); splay(to); return; //否则走到该儿子 }else p = to; } exit(1); } 查询x的排名 仿照Treap的实现即可。\n这里也要把我们找到的点旋转到根。\n有人问为啥每次都要旋转，有两个原因：\n有时候旋转到根有别用。 旋转操作是复杂度的保证，这也就意味着旋转操作多多益善，少了可能会挂。 放代码：\nLL getrnk(LL x){ //查询数x的排名（且将数x旋转到根） LL p = rt; LL ret = 0; while(p) //如果x比当前权值小，则说明答案都在左子树 if(x \u0026lt; val(p)) p = lc(p); //否则就是整个左子树、当前节点，和部分右子树 else{ //将左子树整个累加 ret += sz(lc(p)); //如果找到了x所在节点 if(x == val(p)){ //则把该节点旋转到根 splay(p); //此时的ret为比x小的元素个数，所以要加1后返回 return ret + 1; } //否则当前节点也在答案范围内 ret += cnt(p); //去右儿子更新答案 p = rc(p); } exit(2); } 查询排名为x的数 差不多的思路。\n还是要旋转到根。\n（剧透一下，看到底下就会发现，splay操作不能放到函数内实现了）\n放代码：\nLL getkth(LL x){ //查询第x名的数（且将该数旋转到根） LL p = rt; while(p) //如果左儿子存在，且x比左儿子大小要小（或等于），则说明答案在左儿子内 if(lc(p) \u0026amp;\u0026amp; x \u0026lt;= sz(lc(p))) p = lc(p); //否则就在当前节点，或者右子树内 else{ //先假设在右子树内 x -= sz(lc(p)) + cnt(p); //如果减之后比0小，则答案一定是当前节点 if(x \u0026lt;= 0){ //旋转到根 splay(p); //返回 return val(p); } //否则，就在右子树内 p = rc(p); } exit(3); } 查询x的前驱 先把 $x$ 插入，此时 $x$ 已经默认旋转到根了。\n于是我们跳左儿子，然后不断跳右儿子即可。\n找到位置之后，splay到根即可。\n放代码：\nLL getpre(LL x){ //查询数x的前驱节点编号（且将前驱旋转到根，保证在调用前x一定存在于树中，且是作为根出现） //保证是根 LL p = rt; //先向左（走到左儿子内）一下 p = lc(p); //如果左儿子不存在，就说明无解 if(p == 0) exit(4); //否则，无脑往右走（走到右儿子内）即可 while(rc(p)) p = rc(p); //直到没有右儿子的时候，就旋转 splay(p); //并返回p节点 return p; } 查询x的后继 类似的，只不过是先跳右儿子，然后跳左儿子。\n还是要旋转到根。\n放代码：\nLL getnxt(LL x){ //查询数x的后继节点编号（且将后继旋转到根，保证在调用前x一定存在于树中，且是作为根出现） //保证是根 LL p = rt; //先向右（走到右儿子内）一下 p = rc(p); //如果右儿子不存在，就说明无解 if(p == 0) exit(5); //否则，无脑往左走（走到左儿子内）即可 while(lc(p)) p = lc(p); //直到没有左儿子的时候，就旋转 splay(p); //并返回p节点 return p; } 删除 删除操作最后讲，是因为删除涉及到上面的操作。\n我们首先找到删除的数（假设为 $x$）所在位置，然后把这个位置旋转到根。\n之后，如果我们发现 $x$ 出现过不止一次，就直接把出现次数自减即可。\n否则，我们分类讨论：\n如果此时的根（数 $x$）没有任何儿子： 那么就说明整个树内就只有一个点，直接删除即可。 如果只有左儿子： 直接把左儿子当根即可。 如果只有右儿子： 直接把右儿子当根即可。 如果左右儿子都有： 则我们找到数 $x$ 的前驱。 此时前驱就默认旋转到根了，且数 $x$ 是作为根节点的右儿子的。 并且根节点的右儿子（数 $x$）是没有左儿子的，显然。 于是我们把数 $x$ 的右儿子街道根节点上即可。 于是即可写出代码：\nvoid del(LL x){ //删除数x //找到删除位置 LL p = rt; while(true){ if(p == 0) exit(6); //找到了 if(val(p) == x) break; //继续跳儿子 p = sons(p, x \u0026gt; /* 这里是大于 */ val(p)); } //把删除位置旋转到根 splay(p); //如果有多于一个权值为x的 if(cnt(rt) \u0026gt; 1){ //则直接cnt--即可 cnt(rt)--; pushup(rt); return; } //如果根没有左右儿子（整棵树就只有rt一个点） if(lc(rt) == 0 \u0026amp;\u0026amp; rc(rt) == 0){ delnode(rt); //如果根只有左儿子 }else if(rc(rt) == 0){ //则拿左儿子作为根，并删除原根 LL t = rt; rt = lc(rt); fa(rt) = 0; delnode(t); //如果根只有右儿子 }else if(lc(rt) == 0){ //则拿右儿子作为根，并删除原根 LL t = rt; rt = rc(rt); fa(rt) = 0; delnode(t); //如果左右儿子都有 }else{ //则把此时根节点的前驱旋转到根 LL t = rt; getpre(val(rt)); //把旧根删掉即可 //此时旧根t一定是新根rt的右儿子 //并且不可能存在权值在val(t)与val(rt)之间（不包括两端点val(t)和val(rt)的值）的节点 //这也就意味着此时t没有左儿子 //只用把右儿子连到新根上去即可 rc(rt) = rc(t); fa(rc(rt)) = rt; fa(t) = 0; //为了防止在delnode的时候把此时的根（t的父亲rt）的某个儿子清零，这里要把t的父亲指向0 delnode(t /* BBE++，原为rt */); pushup(rt); //并更新此时rt的信息 } } 复杂度 这个复杂度是可以证明的，其均摊复杂度为 $O(\\log n)$，其中 $n$ 为节点数。\n证明：\n（暑假的时候补）\n不过有时候少旋转了，可能会导致复杂度增加，所以建议比赛的时候（特别是OI赛制比赛）造几个边界数据看是否能过。\n代码 递交到P3369即可AC const LL Q = 1e5 + 10; LL q; LL opt, x; struct Node{ //对于单点而言 LL val; //节点权值 LL cnt; //权值出现次数 //对于邻边而言 LL fa; //父亲节点 LL sons[2]; //两个儿子节点 //对于子树而言 LL sz; //子树大小 }; #define val(x) (a[x].val) #define cnt(x) (a[x].cnt) #define fa(x) (a[x].fa) #define sons(x, p) (a[x].sons[p]) #define lc(x) sons(x, 0) #define rc(x) sons(x, 1) #define sz(x) (a[x].sz) Node a[Q]; //所有节点的信息 LL ind; //目前编号到几了 LL rt; //根节点编号（由于有删除、旋转操作，所以根会不断变化） #define sp(x) (rc(fa(x)) == x) //x是哪个儿子 #define pushup(x) (sz(x) = sz(lc(x)) + cnt(x) + sz(rc(x))) //上传信息 LL newnode(LL v, LL fa){ //新增一个权值为v、父亲节点为fa的点 ind++; val(ind) = v; cnt(ind) = 1; fa(ind) = fa; lc(ind) = rc(ind) = 0; sz(ind) = 1; return ind; } void delnode(LL x){ //删除节点x（如果x为根，则将根编号赋值为0） if(x == rt) rt = 0; val(x) = 0; cnt(x) = 0; sons(fa(x), sp(x)) = 0; fa(x) = 0; lc(x) = rc(x) = 0; sz(x) = 0; } void rotate(LL x){ //旋转操作 LL y = fa(x), z = fa(y), p = sp(x); sons(y, p) = sons(x, !p), sons(x, !p) = y, fa(sons(y, p)) = y; fa(x) = fa(y), fa(y) = x; pushup(y), pushup(x); if(z){ sons(z, rc(z) == y) = x; pushup(z); } } void splay(LL x){ //将一个点x旋转到根 //如果x和fa（x的父亲）的子节点关系一致，则旋转fa后旋转x //否则，旋转两次x for(LL fa = fa(x);fa;rotate(x) /* rotate完后不用把x赋值为其父亲 */, fa = fa(x)) if(fa(fa)) rotate(sp(x) == sp(fa) ? fa : x); rt = x; } void add(LL x){ //添加数x（且将数x旋转到根） //特判树为空 if(rt == 0){ ind = 0; rt = newnode(x, 0); return; } //找到添加点 LL p = rt; while(true){ //如果有相同的权值，直接cnt++即可 if(val(p) == x){ cnt(p)++; pushup(fa(p)); splay(p); return; } //否则找到去哪个儿子 LL \u0026amp;to = sons(p, x \u0026gt; /* 这里是大于 */ val(p)); //如果该儿子没有 if(to == 0){ //则新增 to = newnode(x, p); pushup(p); splay(to); return; //否则走到该儿子 }else p = to; } exit(1); } LL getrnk(LL x){ //查询数x的排名（且将数x旋转到根） LL p = rt; LL ret = 0; while(p) //如果x比当前权值小，则说明答案都在左子树 if(x \u0026lt; val(p)) p = lc(p); //否则就是整个左子树、当前节点，和部分右子树 else{ //将左子树整个累加 ret += sz(lc(p)); //如果找到了x所在节点 if(x == val(p)){ //则把该节点旋转到根 splay(p); //此时的ret为比x小的元素个数，所以要加1后返回 return ret + 1; } //否则当前节点也在答案范围内 ret += cnt(p); //去右儿子更新答案 p = rc(p); } exit(2); } LL getkth(LL x){ //查询第x名的数（且将该数旋转到根） LL p = rt; while(p) //如果左儿子存在，且x比左儿子大小要小（或等于），则说明答案在左儿子内 if(lc(p) \u0026amp;\u0026amp; x \u0026lt;= sz(lc(p))) p = lc(p); //否则就在当前节点，或者右子树内 else{ //先假设在右子树内 x -= sz(lc(p)) + cnt(p); //如果减之后比0小，则答案一定是当前节点 if(x \u0026lt;= 0){ //旋转到根 splay(p); //返回 return val(p); } //否则，就在右子树内 p = rc(p); } exit(3); } LL getpre(LL x){ //查询数x的前驱节点编号（且将前驱旋转到根，保证在调用前x一定存在于树中，且是作为根出现） //保证是根 LL p = rt; //先向左（走到左儿子内）一下 p = lc(p); //如果左儿子不存在，就说明无解 if(p == 0) exit(4); //否则，无脑往右走（走到右儿子内）即可 while(rc(p)) p = rc(p); //直到没有右儿子的时候，就旋转 splay(p); //并返回p节点 return p; } LL getnxt(LL x){ //查询数x的后继节点编号（且将后继旋转到根，保证在调用前x一定存在于树中，且是作为根出现） //保证是根 LL p = rt; //先向右（走到右儿子内）一下 p = rc(p); //如果右儿子不存在，就说明无解 if(p == 0) exit(5); //否则，无脑往左走（走到左儿子内）即可 while(lc(p)) p = lc(p); //直到没有左儿子的时候，就旋转 splay(p); //并返回p节点 return p; } void del(LL x){ //删除数x //找到删除位置 LL p = rt; while(true){ if(p == 0) exit(6); //找到了 if(val(p) == x) break; //继续跳儿子 p = sons(p, x \u0026gt; /* 这里是大于 */ val(p)); } //把删除位置旋转到根 splay(p); //如果有多于一个权值为x的 if(cnt(rt) \u0026gt; 1){ //则直接cnt--即可 cnt(rt)--; pushup(rt); return; } //如果根没有左右儿子（整棵树就只有rt一个点） if(lc(rt) == 0 \u0026amp;\u0026amp; rc(rt) == 0){ delnode(rt); //如果根只有左儿子 }else if(rc(rt) == 0){ //则拿左儿子作为根，并删除原根 LL t = rt; rt = lc(rt); fa(rt) = 0; delnode(t); //如果根只有右儿子 }else if(lc(rt) == 0){ //则拿右儿子作为根，并删除原根 LL t = rt; rt = rc(rt); fa(rt) = 0; delnode(t); //如果左右儿子都有 }else{ //则把此时根节点的前驱旋转到根 LL t = rt; getpre(val(rt)); //把旧根删掉即可 //此时旧根t一定是新根rt的右儿子 //并且不可能存在权值在val(t)与val(rt)之间（不包括两端点val(t)和val(rt)的值）的节点 //这也就意味着此时t没有左儿子 //只用把右儿子连到新根上去即可 rc(rt) = rc(t); fa(rc(rt)) = rt; fa(t) = 0; //为了防止在delnode的时候把此时的根（t的父亲rt）的某个儿子清零，这里要把t的父亲指向0 delnode(t /* BBE++，原为rt */); pushup(rt); //并更新此时rt的信息 } } void solve(){ rd(q); rep(i, 1, q){ rd(opt), rd(x); if(opt == 1) add(x); else if(opt == 2) del(x); else if(opt == 3) printf(\u0026#34;%lld\\n\u0026#34;, getrnk(x) ) ; else if(opt == 4) printf(\u0026#34;%lld\\n\u0026#34;, getkth(x) ) ; else if(opt == 5) add(x), printf(\u0026#34;%lld\\n\u0026#34;, val(getpre(x))), del(x); else add(x), printf(\u0026#34;%lld\\n\u0026#34;, val(getnxt(x))), del(x); } } 区间操作、查询 不过这还没完，上面说“Splay能解决更多种类的操作、查询”，而具体是哪些呢？其实就是对区间的操作。\n比如，最经典的就是对一段区间做翻转。\n此时，我们设操作区间为 $[l,r]$，我们就考虑把这段区间提取为一个子树。\n一种可行的思路是，我们把 $l-1$ 旋转到根，把 $r+1$ 旋转到根的右儿子。\n有人说，这一步直接把 $r+1$ 旋转到根，随后把 $l-1$ 旋转到根不就彳亍了吗？事实并非如此。\n实测在绝大部分情况下，这样都不能正确的提取 $[l,r]$ 这段区间。\n所以，我们只能变化一下splay操作：\nvoid splay(LL x, LL tar = 0){ //tar表示旋转到哪个点为止 for(LL fa = fa(x);fa != tar;rotate(x), fa = fa(x)) if(fa(fa) != tar) rotate(sp(x) == sp(fa) ? fa : x); if(tar == 0) /* 只有在tar=0的时候根节点才会变化 */ rt = x; } 具体调用可以看底下的代码。\n于是，此时根节点的右儿子的左儿子，就是 $[l,r]$ 这段区间对应子树的根。\n我们只要在这个根上打标记即可。\n或者如果是询问，就访问其权值即可。\n注意在引入标记后，必须要时刻记得pushdown。\n代码 只有旋转：\n递交到P3391即可AC const LL Q = 1e5 + 10; LL n, q; LL l, r; struct Node{ LL val; LL fa; LL sons[2]; LL sz; bool rev; }; #define val(x) (a[x].val) #define fa(x) (a[x].fa) #define sons(x, p) (a[x].sons[p]) #define lc(x) sons(x, 0) #define rc(x) sons(x, 1) #define sz(x) (a[x].sz) #define rev(x) (a[x].rev) Node a[Q]; LL ind; LL rt; #define sp(x) (rc(fa(x)) == x) #define pushup(x) (sz(x) = sz(lc(x)) + 1 + sz(rc(x))) LL newnode(LL v, LL fa){ ind++; val(ind) = v; fa(ind) = fa; lc(ind) = rc(ind) = 0; sz(ind) = 1; rev(ind) = false; return ind; } LL build(LL l, LL r, LL fa){ if(l \u0026gt; r) return 0; LL mid = l + (r - l) / 2; LL x = newnode(mid, fa); lc(x) = build(l, mid - 1, x), rc(x) = build(mid + 1, r, x); pushup(x); return x; } #define lazy_rev(x) (swap(lc(x), rc(x)), rev(x) ^= 1) void pushdown(LL x){ if(rev(x)){ lazy_rev(lc(x)); lazy_rev(rc(x)); rev(x) = false; } } void rotate(LL x){ LL y = fa(x), z = fa(y), p = sp(x); pushdown(z), pushdown(y), pushdown(x); sons(y, p) = sons(x, !p), sons(x, !p) = y, fa(sons(y, p)) = y; fa(x) = fa(y), fa(y) = x; pushup(y), pushup(x); if(z){ sons(z, rc(z) == y) = x; pushup(z); } } void splay(LL x, LL tar = 0){ //tar表示旋转到哪个点为止 for(LL fa = fa(x);fa != tar;rotate(x), fa = fa(x)) if(fa(fa) != tar) rotate(sp(x) == sp(fa) ? fa : x); if(tar == 0) /* 只有在tar=0的时候根节点才会变化 */ rt = x; } LL getkth(LL x){ LL p = rt; while(p){ pushdown(p); if(lc(p) \u0026amp;\u0026amp; x \u0026lt;= sz(lc(p))) p = lc(p); else{ x -= sz(lc(p)) + 1; if(x \u0026lt;= 0) return p; //不用着急在这里splay，在主程序里有详细处理 p = rc(p); } } exit(1); } void dfs(LL x){ if(x == 0) return; pushdown(x); dfs(lc(x)); if(1 \u0026lt;= val(x) \u0026amp;\u0026amp; val(x) \u0026lt;= n) printf(\u0026#34;%lld \u0026#34;, val(x)); dfs(rc(x)); } void solve(){ rd(n), rd(q); build(0, n + 1, 0); rt = 1; cir(q){ rd(l), rd(r); LL vl = getkth((l - 1) + 1); splay(vl); LL vr = getkth((r + 1) + 1); splay(vr, vl); lazy_rev(lc(rc(rt))); } dfs(rt); puts(\u0026#34;\u0026#34;); } 旋转、区间加、区间查询最大值：（重写的，函数化了，会更加好看一些）\n递交到P4146即可AC const LL N = 5e4 + 10; LL n, q; LL opt; LL l, r, v; struct Node{ LL val; LL fa; LL sons[2]; LL sz; LL ma; LL add; bool rev; }; #define val(x) (a[x].val) #define fa(x) (a[x].fa) #define sons(x, p) (a[x].sons[p]) #define lc(x) sons(x, 0) #define rc(x) sons(x, 1) #define sz(x) (a[x].sz) #define ma(x) (a[x].ma) #define add(x) (a[x].add) #define rev(x) (a[x].rev) Node a[N]; LL ind; LL rt; #define sp(x) (rc(fa(x)) == x) #define pushup(x) (sz(x) = sz(lc(x)) + 1 + sz(rc(x)), ma(x) = max({ma(lc(x)), val(x), ma(rc(x))})) void rotate(LL x){ LL y = fa(x), z = fa(y), p = sp(x); sons(y, p) = sons(x, !p), sons(x, !p) = y, fa(sons(y, p)) = y; fa(x) = fa(y), fa(y) = x; pushup(y), pushup(x); if(z){ sons(z, rc(z) == y) = x; pushup(z); } } void splay(LL x, LL tar = 0){ for(LL fa = fa(x);fa != tar;rotate(x), fa = fa(x)) if(fa(fa) != tar) rotate(sp(x) == sp(fa) ? fa : x); if(tar == 0) rt = x; } LL newnode(LL v, LL fa){ ind++; val(ind) = v; fa(ind) = fa; lc(ind) = rc(ind) = 0; sz(ind) = 1; ma(ind) = v; add(ind) = 0; rev(ind) = false; return ind; } LL build(LL l, LL r, LL fa){ if(l \u0026gt; r) return 0; LL mid = l + (r - l) / 2; LL cur = newnode(0, fa); lc(cur) = build(l, mid - 1, cur); rc(cur) = build(mid + 1, r, cur); pushup(cur); return cur; } void upd_lazy(LL x, LL add, bool rev){ if(add){ val(x) += add; ma(x) += add; add(x) += add; } if(rev){ swap(lc(x), rc(x)); rev(x) ^= rev; } } void pushdown(LL x){ upd_lazy(lc(x), add(x), rev(x)); upd_lazy(rc(x), add(x), rev(x)); add(x) = 0, rev(x) = false; } LL getkth(LL x){ LL p = rt; while(p){ pushdown(p); if(lc(p) \u0026amp;\u0026amp; x \u0026lt;= sz(lc(p))) p = lc(p); else{ x -= sz(lc(p)) + 1; if(x \u0026lt;= 0) return p; p = rc(p); } } exit(1); } LL lock_range(LL l, LL r){ LL xl = getkth((l - 1) + 1); splay(xl); LL xr = getkth((r + 1) + 1); splay(xr, xl); return lc(rc(rt)); } void add_range(LL l, LL r, LL v){ upd_lazy(lock_range(l, r), v, false); } void rev_range(LL l, LL r){ upd_lazy(lock_range(l, r), 0, true); } LL max_range(LL l, LL r){ return ma(lock_range(l, r)); } void solve(){ rd(n), rd(q); ma(0) = -INF; //这里要把0节点的ma值设为-INF，防止权值为负，且某个儿子不存在（为0）的情况 build(0, n + 1, 0); rt = 1; cir(q){ rd(opt); if(opt == 1) rd(l), rd(r), rd(v), add_range(l, r, v); else if(opt == 2) rd(l), rd(r), rev_range(l, r); else rd(l), rd(r), printf(\u0026#34;%lld\\n\u0026#34;, max_range(l, r)); } } ","permalink":"https://qjwh.github.io/posts/oi/aln/balancedtree/","summary":"\u003ctext style=\"font-family:Noto Sans SC\"\u003e\r\n\u003cp\u003e说到平衡树，很多人的第一印象就是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e难学（知识点真多）\u003c/li\u003e\n\u003cli\u003e难懂（特别是“旋转”和证明）\u003c/li\u003e\n\u003cli\u003e难调（我的某个教练刚学平衡树的时候调了七个小时）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e下面我们就来从0开始讲平衡树。\u003c/p\u003e\n\u003cp\u003e（注：网上大多数人说到“平衡树”默认指的是“Splay”而不是其他算法）\u003c/p\u003e\n\u003ch1 id=\"text-stylecolorrgb0150136-定义\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 定义\u003c/h1\u003e\n\u003cp\u003e其实平衡树（Balance Tree，简称BT）不算一种算法，而是一种统称。\u003c/p\u003e\n\u003cp\u003e平衡树顾名思义就是非常平衡的树。\u003c/p\u003e\n\u003cp\u003e比如说这棵树就非常不平衡：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.luogu.com.cn/upload/image_hosting/88bai0mt.png\"\u003e\u003c/p\u003e\n\u003cp\u003e而这棵树就比较平衡：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.luogu.com.cn/upload/image_hosting/w7w8hynq.png\"\u003e\u003c/p\u003e\n\u003cp\u003e如果说的更形式化，平衡就意味着，对于每个点，其所有子树的大小差都不超过 $1$。\u003c/p\u003e\n\u003cp\u003e具体而言，对于每个点 $x$，如果我们把其所有儿子 $to$ 的子树大小都列出来，那么这个数组内最大值和最小值差不超过 $1$。\u003c/p\u003e\n\u003cp\u003e而且，大多数平衡树都是二叉树，这一点是为了方便操作和设计算法。\u003c/p\u003e\n\u003ch1 id=\"text-stylecolorrgb0150136-种类\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 种类\u003c/h1\u003e\n\u003cp\u003e听完上面的定义，你就知道了，平衡树就是一类树状数据结构的统称。\u003c/p\u003e\n\u003cp\u003e下面就来列举一下这类数据结构都有哪些，以及这些数据结构的简介。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-二叉搜索树binary-search-tree简称bst\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 二叉搜索树（Binary Search Tree，简称BST）\u003c/h2\u003e\n\u003cp\u003e大多数平衡树的前置算法，这也就意味着，大多数的平衡树都是基于BST并进行优化、扩展后得到的算法。\u003c/p\u003e\n\u003cp\u003e而BST也是线段树（Segment Tree，部分情况下会简称为ST）进行扩展后的算法。\u003c/p\u003e\n\u003cp\u003e具体而言，权值线段树和BST都可以维护有序集合，但有时候只能用BST解决。\u003c/p\u003e\n\u003cp\u003eBST其实就是把权值“当做”节点编号（讲的时候一般就这么讲，但写的时候不能这么写，是把权值存入该节点的结构体内）。\u003c/p\u003e\n\u003cp\u003e然后对于每个点，它都有最多 $2$ 个儿子，左儿子权值 $\u0026lt;$ 当前点权值 $\u0026lt;$ 右儿子权值。\u003c/p\u003e\n\u003cp\u003e这样就可以方便查找。\u003c/p\u003e\n\u003cp\u003e优点：代码好写，容易讲明白\u003c/p\u003e\n\u003cp\u003e缺点：解决题型少，需要写定期重构（又被称作“替罪羊树思想”），复杂度高\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-treap名字不是一个单词而是两个单词tree和heap的结合\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e Treap（名字不是一个单词，而是两个单词Tree和Heap的结合）\u003c/h2\u003e\n\u003cp\u003e这个算法给每个节点都添加了一个“优先级”，并让“优先级”满足小/大根堆的性质。\u003c/p\u003e\n\u003cp\u003e并且，这里还通过“旋转”操作（最头疼的地方来了）让树尽量平衡，这样会让树高稳定在 $O(\\log n)$ 级别。\u003c/p\u003e\n\u003cp\u003e（不过注意，在最坏情况下，复杂度会达到 $O(n)$，所以 $O(\\log n)$ 只是期望）\u003c/p\u003e\n\u003cp\u003e这样，复杂度就降下来了。\u003c/p\u003e\n\u003cp\u003e优点：复杂度低，比较容易理解，解决题型多，且容易被识别出\u003c/p\u003e\n\u003cp\u003e缺点：比较难写，细节较多，复杂度难证明\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-splay本意为张开但这里不是这个意思\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e Splay（本意为“张开”但这里不是这个意思）\u003c/h2\u003e\n\u003cp\u003e这个算法对上面的“旋转”操作又做了一遍扩展，让其能够解决子串翻转问题。\u003c/p\u003e\n\u003cp\u003e而且，由于它也会让整棵树尽量平衡，所以树高还是会稳定在 $O(\\log n)$ 级别。\u003c/p\u003e","title":"平衡树"},{"content":"参考\n引用头文件（常用） #include \u0026lt;stdlib.h\u0026gt; //生成随机数、设定随机数种子 #include \u0026lt;ctime\u0026gt; //生成随机数种子（1） #include \u0026lt;time.h\u0026gt; //生成随机数种子（2） #include \u0026lt;unistd.h\u0026gt; //等待（sleep(...)或usleep(...)），该头文件现在不常用 随机种子 srand(time(0) ^ clock()); 注：随机种子为time(0) ^ clock()，这个随机种子可以再毫秒级别内生成（大概率）不同的随机种子。\n取 $[l,r]$ 内的随机数 #define random(l, r) (rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l)) 注：rand函数只能生成 $[1,32767]$ 内的随机数（见宏RAND_MAX），大概只能生成位数 $\\leq 5$ 的随机数；测试程序：\nLL ma = 0; for(LL i = 1;i \u0026lt;= 200;i++){ srand(time(0) ^ clock()); LL t = rand(); cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt;endl; ma = max(ma, t); usleep(10000); } cout \u0026lt;\u0026lt; ma \u0026lt;\u0026lt;endl; 所以此处引用一个新方法：mt19937（2022/12/24：现在开始使用mt19937_64了，它可以生成 $[1,2^{64})$ 内的随机数，大一倍）。\n其实它的语法和rand的语法差不多 （才怪），是这样的：\n引用头文件（常用） #include \u0026lt;random\u0026gt; //生成随机数、设定随机数种子 #include \u0026lt;ctime\u0026gt; //生成随机数种子（1） #include \u0026lt;time.h\u0026gt; //生成随机数种子（2） #include \u0026lt;unistd.h\u0026gt; //等待（sleep(...)或usleep(...)），该头文件现在不常用 随机种子 mt19937 _rand(time(0) ^ clock()); 注：这个随机种子也可以再毫秒级别内生成（大概率）不同的随机种子\n取 $[l,r]$ 内的随机数 （就差一个字符_而已） #define random(l, r) (_rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l)) 据测试，这个函数可以生成在unsigned int范围内的随机数（即可以生成 $[1,2^{32})$ 内的随机数），测试程序：\nLL ma = 0; for(LL i = 1;i \u0026lt;= 200;i++){ mt19937 _rand(time(0) ^ clock()); LL t = _rand(); cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt;endl; ma = max(ma, t); usleep(10000); } cout \u0026lt;\u0026lt; ma \u0026lt;\u0026lt;endl; 那就有人问了，很多人会把mt19937（这是一个类，即class）类型的_rand定义到外面，此时clock()=0，不就相当于随机种子是time(0)吗？那怎么样更好地取随机种子呢？其实C++里实现了这个类的。\n这个类名叫random_device，用法如下：\nrandom_device rand_seed; mt19937 _rand(rand_seed()); 这样随机种子就可以更好地生成了。\nrandom_shuffle介绍 （待补）\nshuffle介绍 （待补）\n上面是一些语法，下面是一些模板和应用。\n（下述文章需完善）\n取一个长度在 $[milen,malen]$ 内的随机小写字母字符串 string get_rand_string_lower(LL milen, LL malen){ string ret; LL len = random(milen, malen); for(LL i = 1;i \u0026lt;= len;i++) ret += \u0026#39;a\u0026#39; + random(0, 25); return ret; } 取一个长度在 $[milen,malen]$ 内的随机大写字母字符串 string get_rand_string_upper(LL milen, LL malen){ string ret; LL len = random(milen, malen); for(LL i = 1;i \u0026lt;= len;i++) ret += \u0026#39;A\u0026#39; + random(0, 25); return ret; } 取一个长度在 $[milen,malen]$ 内的随机大小写字母+数字+下划线字符串 string get_rand_string_alpha_number_underline(LL milen, LL malen){ string ret; LL len = random(milen, malen); for(LL i = 1;i \u0026lt;= len;i++){ LL val = random(1, 63); if(val \u0026lt;= 26) ret += \u0026#39;A\u0026#39; + val - 1; else if(val \u0026lt;= 52) ret += \u0026#39;a\u0026#39; + val - 27; else if(val \u0026lt;= 62) ret += \u0026#39;0\u0026#39; + val - 53; else ret += \u0026#39;_\u0026#39;; } return ret; } 取一个长度在 $[milen,malen]$ 内的随机字符字符串 string get_rand_string_char(LL milen, LL malen){ string ret; LL len = random(milen, malen); for(LL i = 1;i \u0026lt;= len;i++) ret += random(32, 126); return ret; } 每 $0.01$ 秒（非严格）输出一个随机“密码”（包含大小写字母、数字、下划线） while(true){ mt19937 _rand(time(0) ^ clock()); cout \u0026lt;\u0026lt; get_rand_string_alpha_number_underline(5, 10) \u0026lt;\u0026lt;endl; usleep(10000); } 输出严格单调递增序列（值域在 $[l,r]$ 内，一共要生成 $1 \\leq x \\leq r - l + 1$ 个数） //PriNT Strictly Monotonically Increasing Sequence void pnt_smis(LL l, LL r, LL x){ LL last = l - 1, cur; for(LL i = 1;i \u0026lt;= x;i++){ cur = random(last + 1, r - (x - i)); printf(\u0026#34;%lld \u0026#34;, cur); last = cur; } puts(\u0026#34;\u0026#34;); } 输出非严格单调递增序列（值域在 $[l,r]$ 内，一共要生成 $x$ 个数） //PriNT Non Strictly Monotonic Increasing Sequence void pnt_nsmis(LL l, LL r, LL x){ LL last = l, cur; for(LL i = 1;i \u0026lt;= x;i++){ cur = random(last, r); printf(\u0026#34;%lld \u0026#34;, cur); last = cur; } puts(\u0026#34;\u0026#34;); } 输出“随机树”（点数为 $n$） PII e[EDGES]; void pnt_random_tree(LL n){ printf(\u0026#34;%lld\\n\u0026#34;, n); for(LL i = 2;i \u0026lt;= n;i++) e[i - 1] = {random(1, i - 1), i}; random_shuffle(e + 1, e + (n - 1) + 1); for(LL i = 1;i \u0026lt; n;i++){ LL t = random(0, 1); if(t) swap(e[i].first, e[i].second); } for(LL i = 1;i \u0026lt; n;i++) printf(\u0026#34;%lld %lld\\n\u0026#34;, e[i].first, e[i].second); } 输出随机DAG（点数为 $n$）\n方法1（未经过测试，而且此处只用于纪念，可以直接忽略）： LL n; struct Node{ LL from, to, next; }; Node a[M]; LL ind; LL pre[N]; void add(LL u, LL v){ ind++; a[ind] = {u, v, pre[u]}; pre[u] = ind; } bool flag = true, ret_flag = false; bool vis[N]; void dfs(LL x){ if(ret_flag) return; vis[x] = true; for(LL i = pre[x];i;i = a[i].next){ LL to = a[i].to; if(vis[to]){ flag = false, ret_flag = true; return; } dfs(to); if(ret_flag) return; } } bool check(){ flag = true, ret_flag = false; for(LL i = 1;i \u0026lt;= n;i++){ if(!vis[i]) dfs(i); if(!flag) return false; } return true; } void pnt_random_DAG(){ while(true){ ind = 0; memset(pre, 0, sizeof(pre)); memset(vis, false, sizeof(vis)); n = random(1, 10); printf(\u0026#34;%lld\\n\u0026#34;, n); for(LL i = 1;i \u0026lt;= n;i++){ LL s = random(1, 5); printf(\u0026#34;%lld \u0026#34;, s); while(s--){ LL to = random(1, n); printf(\u0026#34;%lld \u0026#34;, to); add(i, to); } puts(\u0026#34;\u0026#34;); } if(check()) break; else system(\u0026#34;cls\u0026#34;); } } 方法2 （推荐）： void pnt_random_DAG(){ LL n = random(1, 1e5); printf(\u0026#34;%lld %lld\\n\u0026#34;, n, random(1, 10)); for(LL i = 1;i \u0026lt;= n;i++){ LL s = random(1, 5); printf(\u0026#34;%lld \u0026#34;, s); while(s--){ LL to = random(i + 1, n); printf(\u0026#34;%lld \u0026#34;, to); } puts(\u0026#34;\u0026#34;); } } ","permalink":"https://qjwh.github.io/posts/oi/aln/genrandomnumber/","summary":"\u003cp\u003e\u003ca href=\"https://blog.csdn.net/LU_ZHAO/article/details/104305240\"\u003e参考\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e引用头文件（常用）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;stdlib.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e//生成随机数、设定随机数种子\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;ctime\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e//生成随机数种子（1）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;time.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e//生成随机数种子（2）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;unistd.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e//等待（sleep(...)或usleep(...)），该头文件现在不常用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e随机种子\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003esrand\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e^\u003c/span\u003e \u003cspan class=\"n\"\u003eclock\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e注：随机种子为\u003ccode\u003etime(0) ^ clock()\u003c/code\u003e，这个随机种子可以再毫秒级别内生成（大概率）不同的随机种子。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e取 $[l,r]$ 内的随机数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#define random(l, r) (rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e注：\u003ccode\u003erand\u003c/code\u003e函数只能生成 $[1,32767]$ 内的随机数（见宏\u003ccode\u003eRAND_MAX\u003c/code\u003e），大概只能生成位数 $\\leq 5$ 的随机数；测试程序：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eLL\u003c/span\u003e \u003cspan class=\"n\"\u003ema\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eLL\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan class=\"mi\"\u003e200\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003esrand\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e^\u003c/span\u003e \u003cspan class=\"n\"\u003eclock\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eLL\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003erand\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003ema\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emax\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ema\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eusleep\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e10000\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003ema\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e所以此处引用一个新方法：\u003ccode\u003emt19937\u003c/code\u003e（2022/12/24：现在开始使用\u003ccode\u003emt19937_64\u003c/code\u003e了，它可以生成 $[1,2^{64})$ 内的随机数，大一倍）。\u003c/p\u003e\n\u003cp\u003e其实它的语法和\u003ccode\u003erand\u003c/code\u003e的语法差不多 \u003cdel\u003e（才怪）\u003c/del\u003e，是这样的：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e引用头文件（常用）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;random\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e//生成随机数、设定随机数种子\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;ctime\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e//生成随机数种子（1）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;time.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e//生成随机数种子（2）\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;unistd.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e  \u003c/span\u003e\u003cspan class=\"c1\"\u003e//等待（sleep(...)或usleep(...)），该头文件现在不常用\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e随机种子\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003emt19937\u003c/span\u003e \u003cspan class=\"nf\"\u003e_rand\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e^\u003c/span\u003e \u003cspan class=\"n\"\u003eclock\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e注：这个随机种子也可以再毫秒级别内生成（大概率）不同的随机种子\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e取 $[l,r]$ 内的随机数 \u003cdel\u003e（就差一个字符\u003ccode\u003e_\u003c/code\u003e而已）\u003c/del\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#define random(l, r) (_rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l))\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e据测试，这个函数可以生成在\u003ccode\u003eunsigned int\u003c/code\u003e范围内的随机数（即可以生成 $[1,2^{32})$ 内的随机数），测试程序：\u003c/p\u003e","title":"生成随机数（未完工）"},{"content":"\r第一次看到树链剖分（简称树剖）可能觉得它非常的深奥，但其实树剖的原理非常简单，下面先说树剖大概的实现思路和解决题型。\n概览 其实树剖就是把一棵树分成若干条链，使得每个点都出现在了刚好一条链上。\n并且，我们称在某条链上的边为“重（zhòng）边”，不在任何一条链上的边为“轻边”。\n然后，我们按某种规则去DFS，求出新的DFS序，然后解决对树上路径询问的问题。\n而且，通过合理的设计每条边的轻重，可以把复杂度控制在 $O(\\log n)$ 级别。\n解决题型 上面也提到了，树剖就是用来解决对树上路径进行询问的问题的算法，当然也可以解决对子树询问的问题，不过属于大材小用了。\n此外，树剖属于工具类算法，所以往往会配合树状数组、线段树、分块等算法出现。\n我把算法分为了两类，“材料类算法”和“工具类算法”，其中：\n材料类算法可以单独考，比如： 数论 推公式 DP 树状数组 线段树 \u0026hellip; 工具类算法里面必须要套材料类算法才能考出来，比如： 二分 01分数规划（二分的一个分支） CDQ分治（需要配合树状数组） 整体二分（需要配合树状数组） 树剖（这里讲的） \u0026hellip; 往往一些较难的题目，都是要用较难的材料类算法（比如DP），或者工具类算法配合材料类算法才能解决的题目。\n而对于后者，难度会更大一些，因为后者的关键在于转化后使用工具类算法解决。\n算法实现 下面说一下树剖的实现。\n两遍DFS 我们考虑DFS，当递归到点 $x$ 的时候，找到 $x$ 的儿子中，子树大小最大的那个儿子 $to$。\n然后，我们把 $x \\to to$ 这条边设为重边，其他边设为轻边。\n得到每条边的轻重后，我们再做一遍DFS。\n而这一遍DFS是为了找到DFS序。\n而且，DFS序有一个要求，我们要先遍历有重边连接的儿子。\n这样的话，对于任意一条树上的链，链上所有点的DFS序连续，而且是由深度从浅到深依次递增。\n同时，我们还要求出，从一个点开始，不经过任何轻边，最多到哪个点。\n解决询问 而对于一次路径上某值的询问，我们可以把这个路径拆成若干条链。\n可以证明链数不超过 $O(\\log n)$，这一点会在下面“复杂度证明”中证明。\n而这些拆出的链，都是原树中的链的“子集”（一条链 $L_1$ 是另外一条链 $L_2$ 的子集，有且仅当 $L_1$ 中的点，$L_2$ 中也有，边同理）。\n所以，可以把一条路径，拆成最多 $O(\\log n)$ 个DFS序区间。\n既然如此，我们就可以拿DFS序作为下标，用数据结构维护题目中的信息，询问就是区间查询。\n当然，很多时候都有修改，所以一般都是用线段树维护。\n复杂度证明 首先，对于任意一个点 $x$，它最多只有一个子节点 $to$（当然，也可能没有），满足 $sz_{to} \\geq sz_x \\div 2$。\n由于我们选择的是子树大小最大的子节点，让该子节点为“重子节点”。\n所以，其他“轻子节点”的大小一定不超过 $sz_x \\div 2$，显然。\n也就是说，如果一个点 $x$ 到其父亲 $fa$ 之间的边是轻边，那么 $sz_{fa} \\geq sz_x \\times 2$ 一定满足，显然。\n而由于 $sz$ 值最多为 $n$，所以从一条路径 $(x,y)$ 的某一端点，走到 $\\text{lca}$，最多只会经过 $\\log n$ 个重链。\n所以单次询问最多分成 $O(\\log n)$ 个重链。\n总复杂度在 $O(q \\log n) \\sim O(q \\log^3 n)$ 内不等，依据题目和实现决定。\n","permalink":"https://qjwh.github.io/posts/oi/aln/treechaindivision/","summary":"\u003ctext style=\"font-family:Noto Sans SC\"\u003e\r\n\u003cp\u003e第一次看到树链剖分（简称树剖）可能觉得它非常的深奥，但其实树剖的原理非常简单，下面先说树剖大概的实现思路和解决题型。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-概览\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 概览\u003c/h2\u003e\n\u003cp\u003e其实树剖就是把一棵树分成若干条链，使得每个点都出现在了刚好一条链上。\u003c/p\u003e\n\u003cp\u003e并且，我们称在某条链上的边为“重（zhòng）边”，不在任何一条链上的边为“轻边”。\u003c/p\u003e\n\u003cp\u003e然后，我们按某种规则去DFS，求出新的DFS序，然后解决对树上路径询问的问题。\u003c/p\u003e\n\u003cp\u003e而且，通过合理的设计每条边的轻重，可以把复杂度控制在 $O(\\log n)$ 级别。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-解决题型\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 解决题型\u003c/h2\u003e\n\u003cp\u003e上面也提到了，树剖就是用来解决对树上路径进行询问的问题的算法，当然也可以解决对子树询问的问题，不过属于大材小用了。\u003c/p\u003e\n\u003cp\u003e此外，树剖属于工具类算法，所以往往会配合树状数组、线段树、分块等算法出现。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e我把算法分为了两类，“材料类算法”和“工具类算法”，其中：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e材料类算法可以单独考，比如：\n\u003cul\u003e\n\u003cli\u003e数论\u003c/li\u003e\n\u003cli\u003e推公式\u003c/li\u003e\n\u003cli\u003eDP\u003c/li\u003e\n\u003cli\u003e树状数组\u003c/li\u003e\n\u003cli\u003e线段树\u003c/li\u003e\n\u003cli\u003e\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e工具类算法里面必须要套材料类算法才能考出来，比如：\n\u003cul\u003e\n\u003cli\u003e二分\u003c/li\u003e\n\u003cli\u003e01分数规划（二分的一个分支）\u003c/li\u003e\n\u003cli\u003eCDQ分治（需要配合树状数组）\u003c/li\u003e\n\u003cli\u003e整体二分（需要配合树状数组）\u003c/li\u003e\n\u003cli\u003e树剖（这里讲的）\u003c/li\u003e\n\u003cli\u003e\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e往往一些较难的题目，都是要用较难的材料类算法（比如DP），或者工具类算法配合材料类算法才能解决的题目。\u003c/p\u003e\n\u003cp\u003e而对于后者，难度会更大一些，因为后者的关键在于\u003cstrong\u003e转化\u003c/strong\u003e后使用工具类算法解决。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-算法实现\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 算法实现\u003c/h2\u003e\n\u003cp\u003e下面说一下树剖的实现。\u003c/p\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-两遍dfs\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 两遍DFS\u003c/h3\u003e\n\u003cp\u003e我们考虑DFS，当递归到点 $x$ 的时候，找到 $x$ 的儿子中，子树大小最大的那个儿子 $to$。\u003c/p\u003e\n\u003cp\u003e然后，我们把 $x \\to to$ 这条边设为重边，其他边设为轻边。\u003c/p\u003e\n\u003cp\u003e得到每条边的轻重后，我们再做一遍DFS。\u003c/p\u003e\n\u003cp\u003e而这一遍DFS是为了找到DFS序。\u003c/p\u003e\n\u003cp\u003e而且，DFS序有一个要求，我们要先遍历有重边连接的儿子。\u003c/p\u003e\n\u003cp\u003e这样的话，对于任意一条树上的链，链上所有点的DFS序连续，而且是由深度从浅到深依次递增。\u003c/p\u003e\n\u003cp\u003e同时，我们还要求出，从一个点开始，不经过任何轻边，最多到哪个点。\u003c/p\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-解决询问\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 解决询问\u003c/h3\u003e\n\u003cp\u003e而对于一次路径上某值的询问，我们可以把这个路径拆成若干条链。\u003c/p\u003e\n\u003cp\u003e可以证明链数不超过 $O(\\log n)$，这一点会在下面“复杂度证明”中证明。\u003c/p\u003e\n\u003cp\u003e而这些拆出的链，都是原树中的链的“子集”（一条链 $L_1$ 是另外一条链 $L_2$ 的子集，有且仅当 $L_1$ 中的点，$L_2$ 中也有，边同理）。\u003c/p\u003e\n\u003cp\u003e所以，可以把一条路径，拆成最多 $O(\\log n)$ 个DFS序区间。\u003c/p\u003e","title":"树链剖分"},{"content":"（四边形不等式看标题可能觉得很难，其实比较简单）\n四边形不等式是一种DP优化的技巧，一般针对二维DP进行优化。\n在DP中，往往会有多个决策点，而其中就有一个是最优的，设 $d_{i,j}$ 的最优决策点为 $f_{i,j}$。\n（以下假设DP枚举决策点的复杂度为 $O(n)$，DP状态数为 $O(n^2)$）\n而四边形不等式就是说，如果满足 $f_{i,j-1} \\leq f_{i,j} \\leq f_{i+1,j}$，那么可以把DP枚举决策点的范围降至 $[f_{i,j-1},f_{i+1,j}]$，然后DP的复杂度就从 $O(n^3)$ 降到了 $O(n^2)$。\n而这个（复杂度）怎么证明呢？我们画一下 $f$ 数组的表：\n（此处，我们以 $i$ 为行号，以 $j$ 为列号，行、列号都从 $1$ 开始编号）\n然后，画几个标记：\n这些标记指的是，在转移 $d_{1,2}$ 的时候，转移点枚举的左右端点分别就是红箭头指向的两个数。\n同时，为了方便观察，此处还画了个蓝色的虚线。\n同理，还可以画出 $d_{2,3}$ 对应的标记：\n以此类推：\n可以发现，其实这时候所有蓝线的长度（蓝线连接的两个数字的差值定义为这个蓝线的长度）之和，最多只有 $n$。\n而对于 $d_{1,3}$ 一“类”的标记：\n可以发现，其实那些蓝线的长度之和也是最多只有 $n$。\n在画出所有蓝线之后：\n可以发现，一共就有 $n$ “类”蓝线，一“类”蓝线的长度之和最多 $n$，至此，可以证明复杂度（所有蓝线的长度之和）为 $O(n^2)$。\n接下来讲几类四边形不等式解决的经典题型：\n第一类：$d_{l,r}=\\min { d_{l,k}+d_{k+1,r} | l \\leq k \\leq r }+w_{l,r}$，合并石子类。 第二类：$d_{i,j}=\\min { d_{k,j-1}+w_{k+1,i} | 0 \\leq k \\leq i }$，区间分割类。 （这两类对应的公式里的 $\\min$ 也可以替换成 $\\max$）\n而一个结论就是，如果说 $w$ 同时满足以下两个条件，那么就可以直接用四边形不等式优化：\n区间包含单调性：如果对于所有 $l \\leq l\u0026rsquo; \\leq r\u0026rsquo; \\leq r$，都满足 $w_{l\u0026rsquo;,r\u0026rsquo;} \\leq w_{l,r}$ 交叉小于等于包含（四边形不等式）：如果对于所有 $l \\leq l\u0026rsquo; \\leq r \\leq r\u0026rsquo;$，都满足 $w_{l,r}+w_{l\u0026rsquo;,r\u0026rsquo;} \\leq w_{l,r\u0026rsquo;}+w_{l\u0026rsquo;,r}$ 这个是可以证明的，但此处略。\n","permalink":"https://qjwh.github.io/posts/oi/aln/quadrangleinequality/","summary":"\u003cp\u003e（四边形不等式看标题可能觉得很难，其实比较简单）\u003c/p\u003e\n\u003cp\u003e四边形不等式是一种DP优化的技巧，一般针对二维DP进行优化。\u003c/p\u003e\n\u003cp\u003e在DP中，往往会有多个决策点，而其中就有一个是最优的，设 $d_{i,j}$ 的最优决策点为 $f_{i,j}$。\u003c/p\u003e\n\u003cp\u003e（以下假设DP枚举决策点的复杂度为 $O(n)$，DP状态数为 $O(n^2)$）\u003c/p\u003e\n\u003cp\u003e而四边形不等式就是说，如果满足 $f_{i,j-1} \\leq f_{i,j} \\leq f_{i+1,j}$，那么可以把DP枚举决策点的范围降至 $[f_{i,j-1},f_{i+1,j}]$，然后DP的复杂度就从 $O(n^3)$ 降到了 $O(n^2)$。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e而这个（复杂度）怎么证明呢？我们画一下 $f$ 数组的表：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.luogu.com.cn/upload/image_hosting/10dvj9bx.png\"\u003e\u003c/p\u003e\n\u003cp\u003e（此处，我们以 $i$ 为行号，以 $j$ 为列号，行、列号都从 $1$ 开始编号）\u003c/p\u003e\n\u003cp\u003e然后，画几个标记：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.luogu.com.cn/upload/image_hosting/by8vj7bj.png\"\u003e\u003c/p\u003e\n\u003cp\u003e这些标记指的是，在转移 $d_{1,2}$ 的时候，转移点枚举的左右端点分别就是红箭头指向的两个数。\u003c/p\u003e\n\u003cp\u003e同时，为了方便观察，此处还画了个蓝色的虚线。\u003c/p\u003e\n\u003cp\u003e同理，还可以画出 $d_{2,3}$ 对应的标记：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.luogu.com.cn/upload/image_hosting/3kxqh955.png\"\u003e\u003c/p\u003e\n\u003cp\u003e以此类推：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.luogu.com.cn/upload/image_hosting/71kjzpi4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e可以发现，其实这时候所有蓝线的长度（蓝线连接的两个数字的差值定义为这个蓝线的长度）之和，最多只有 $n$。\u003c/p\u003e\n\u003cp\u003e而对于 $d_{1,3}$ 一“类”的标记：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.luogu.com.cn/upload/image_hosting/ia0bvgy6.png\"\u003e\u003c/p\u003e\n\u003cp\u003e可以发现，其实那些蓝线的长度之和也是最多只有 $n$。\u003c/p\u003e\n\u003cp\u003e在画出所有蓝线之后：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.luogu.com.cn/upload/image_hosting/d9jiw70y.png\"\u003e\u003c/p\u003e\n\u003cp\u003e可以发现，一共就有 $n$ “类”蓝线，一“类”蓝线的长度之和最多 $n$，至此，可以证明复杂度（所有蓝线的长度之和）为 $O(n^2)$。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e接下来讲几类四边形不等式解决的经典题型：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第一类：$d_{l,r}=\\min { d_{l,k}+d_{k+1,r} \u003cdel\u003e|\u003c/del\u003e l \\leq k \\leq r }+w_{l,r}$，合并石子类。\u003c/li\u003e\n\u003cli\u003e第二类：$d_{i,j}=\\min { d_{k,j-1}+w_{k+1,i} \u003cdel\u003e|\u003c/del\u003e 0 \\leq k \\leq i }$，区间分割类。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（这两类对应的公式里的 $\\min$ 也可以替换成 $\\max$）\u003c/p\u003e","title":"四边形不等式"},{"content":"\r同余最短路看名字感觉很难，但其实非常简单，也好理解，先说一道题：\n题目 原型：洛谷P3403 跳楼机\n有一栋 $h$ 层的大楼（层数编号从 $1$ 到 $h$），有 $n+1$ 种移动方式：\n回到 $1$ 层 向上走 $x_1 \\sim x_n$ 层 楼层不是循环的，你无论如何都无法到达 $h+1$ 层或以上。\n最初你可以在任意一层（但也无关紧要），问你能到达多少个不同的楼层。\n题解 分类 我们按楼层模 $x_1$ 的余数分类，把楼层 $i$ 分到 $i \\bmod x_1$ 类。\n这样分类有什么用呢？见下。\n定义状态 有了这个分类，我们可以定义状态 $d_i$（$i \\in [0,x_1)$）代表不用「向上走 $x_1$ 层」操作能到达的、最小的第 $i$ 类楼层是多少。\n那么，由于有「向上走 $x_1$ 层」操作，所以 $d_i,d_i+x_1,d_i+2x_1,\\dots$（比 $d_i$ 大或相等的第 $i$ 类楼层）都是可达的。\n接下来考虑转移这个状态。\n转移 其实也很好想，比如用一次「向上走 $x_2$ 层」操作，那么 $d_i$ 可以转移到 $d_{(i+x_2) \\bmod x_1}$，转移代价为 $x_2$，所以：\n$d_{(i+x_2) \\bmod x_1}=\\min(d_{(i+x_2) \\bmod x_1},d_i+x_2)$\n修改 但很快就能发现，这个DP不拥有拓扑序，所以必须要用最短路去解决，建图伪代码：\n枚举 $i \\in [0,x_1)$ 枚举 $j \\in [2,n]$ DP转移形如：$d_{(i+x_j) \\bmod x_1}=\\min(d_{(i+x_j) \\bmod x_1},d_i+x_j)$ 于是就建从 $i$ 到 $(i+x_j) \\bmod x_1$ 的有向边，边权为 $x_j$ 易得点数为 $O(x_1)$，边数为 $O(x_1 \\times n)$，以Dijkstra复杂度 $O((n+m) \\log (n+m))$，总复杂度为 $O((x_1 \\times n) \\log (x_1 \\times n))$，在 $n \\leq 2 \\times 10^3,x_1 \\leq 2 \\times 10^3$ 左右是完全稳过的。\n","permalink":"https://qjwh.github.io/posts/oi/aln/modsp/","summary":"\u003ctext style=\"font-family:Lato,楷体\"\u003e\r\n\u003cp\u003e同余最短路看名字感觉很难，但其实非常简单，也好理解，先说一道题：\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-题目\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 题目\u003c/h2\u003e\n\u003cp\u003e原型：\u003ca href=\"https://www.luogu.com.cn/problem/P3403\"\u003e洛谷P3403 跳楼机\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e有一栋 $h$ 层的大楼（层数编号从 $1$ 到 $h$），有 $n+1$ 种移动方式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e回到 $1$ 层\u003c/li\u003e\n\u003cli\u003e向上走 $x_1 \\sim x_n$ 层\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e楼层不是循环的，你无论如何都无法到达 $h+1$ 层或以上。\u003c/p\u003e\n\u003cp\u003e最初你可以在任意一层（但也无关紧要），问你能到达多少个不同的楼层。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-题解\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 题解\u003c/h2\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-分类\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 分类\u003c/h3\u003e\n\u003cp\u003e我们按楼层模 $x_1$ 的余数分类，把楼层 $i$ 分到 $i \\bmod x_1$ 类。\u003c/p\u003e\n\u003cp\u003e这样分类有什么用呢？见下。\u003c/p\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-定义状态\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 定义状态\u003c/h3\u003e\n\u003cp\u003e有了这个分类，我们可以定义状态 $d_i$（$i \\in [0,x_1)$）代表不用「向上走 $x_1$ 层」操作能到达的、最小的第 $i$ 类楼层是多少。\u003c/p\u003e\n\u003cp\u003e那么，由于有「向上走 $x_1$ 层」操作，所以 $d_i,d_i+x_1,d_i+2x_1,\\dots$（比 $d_i$ 大或相等的第 $i$ 类楼层）都是可达的。\u003c/p\u003e\n\u003cp\u003e接下来考虑转移这个状态。\u003c/p\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-转移\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 转移\u003c/h3\u003e\n\u003cp\u003e其实也很好想，比如用一次「向上走 $x_2$ 层」操作，那么 $d_i$ 可以转移到 $d_{(i+x_2) \\bmod x_1}$，转移代价为 $x_2$，所以：\u003c/p\u003e\n\u003cp\u003e$d_{(i+x_2) \\bmod x_1}=\\min(d_{(i+x_2) \\bmod x_1},d_i+x_2)$\u003c/p\u003e","title":"同余最短路"},{"content":"\r前言 首先，网络流不是一个算法，而是一个整合包（玩MC玩的），说白了就是网络流是多个算法的统称：\n最大流 EK Dinic 最小割 费用流 \u0026hellip; 而且，有些不常用的，可能就不会提，粘个OI Wiki的链接就不详细写了。\n接下来就按照这个目录挨个讲一下每个算法。\n最大流 如果有哪里没有说清楚，可以看这里，里面还有我没有说到的最大流类型。\n看到最大流这个名字很多人都很陌生，这里就先从定义说起。\n定义 还是拆词法，“网络流”就可以大致理解为“网络”上的“流”，接下来就挨个说一下这两个的定义。\n网络 先说网络的定义。（当然不是Internet）\n我们在理解的时候可以认为是管道，但实际上它是一张特殊的有向图。\n建设管道的必然知道，管道内流过的水，准确来说是单位时间内流过的水，必然是有上限限制的，否则管道就炸了。\n这里也一样，对于每条边 $x \\to y$，都有一个函数 $c(x,y)$ 表示这条边的限制，又称容量。\n如果在图上没有这条边，则统一规定 $c(x,y)=0$。\n最后，还是跟最短路一样，它有一个起点和一个终点，又称源点 $S$ 和汇点 $T$（$S \\not= T$）。\n流函数 再说流函数。\n流函数就是说，在真实操作中，一个单位时间内一条边 $x \\to y$ 流过的水量 $f(x,y)$。\n这里默认保证每个单位时间内都得流过这么多。\n其实很好理解。\n流函数性质 顺便说一下流函数要满足的性质。\n首先，源点可以无限输出水，汇点可以无限输入水。\n接下来就是一堆性质：\n对于每个 $x,y$，显然 $f(x,y) \\leq c(x,y)$（容量限制）。 对于每个 $x,y$，$f(x,y)=-f(y,x)$（斜对称）。 对于每个 $x$，满足不是源点也不是汇点，$\\sum\\limits_{u \\to x} f(u,x)=\\sum\\limits_{x \\to v} f(x,v)$（流量守恒）。 这里说一下最后一点性质。\n首先，$u \\to x$ 即代表对于每个 $u$ 满足 $u$ 到 $x$ 有边，$x \\to v$ 同理。\n其次，这个翻译过来就是说，对于不是源点不是汇点的任何点，它们都不会凭空产生水，也不会让水凭空消失。\n而源点和汇点呢？源点就没有入，凭空产生水；汇点就没有出，让水凭空消失。\n容易理解\n流量 说到流，那必定要提流量。（当然不是你们家的网络流量）\n其实流量就是上面说的“流过的水量”，说白了就是 $f(x,y)$。\n这里说一下一个细节，$f$ 是流函数，$f(x,y)$ 是该边的流量。\n同时，还有一个反面定义，就是 $c(x,y)-f(x,y)$ 为该边的剩余容量。\n（注意上面两个加粗题的表达）\n但这只是一条边的流量，如果扩展到一张图，根据流量守恒，直接看源点输出了多少水，就是整张图的流量。\n也即汇点输入的水量。\n最大流 最后再说最大流的定义。\n这里说一下，最大流其实是一个函数，就是流函数。\n而与它仅差一个字的最大流量，才是一个数值，即最大流对应方案的流量。\n（不过似乎没有很多人会在乎这两个定义的差别，底下的所谓“求最大流”的算法，应该是“求最大流量”）\n说完这个后，顾名思义就能猜到定义了。\n就是合法的流函数有很多，使得整张图的流量最大的流函数，就是最大流。\nEK（Edmonds Karp） 说完定义，接下来就从最基础的EK算法说起。\n这个算法复杂度很高（至少相对Dinic而言），但它确实是所有网络流算法的基础。\n因为Dinic就是从EK上优化的，最小割、费用流都是以Dinic为基础的。\n接下来先讲实现，再讲原理。\n不过一般没人写EK。\n实现 而且，其实EK和二分图（匈牙利算法）很像，都是求增广路。\n说白了，就是当前解不优，找一个更优的。\n其本质就是反悔贪心。\n而此处的增广其实是这么实现的：\n先建图，带权，同时建一个反向的、边权为 $0$ 的边。 即对于原图中的一条边 $(u \\to v, w)$，建两条边： $(u \\to v,w)$ $(v \\to u,0)$ 注意一下，不要对这里的反向边有“种族歧视”，就把反向边当做是普通的边，人人平等（ 然后，不断做这件事： 从源点开始BFS，中途记录一下当前所有经过的边的边权最小值。 如果BFS到了汇点，答案加上最小值 $val$。 同时对于每条经过的边： 让这条边的边权减去 $val$。 让它反向边边权加上 $val$。 直到从源点开始，无论如何都得经过一条边权为 $0$ 的边才能到汇点为止。 因为如果经过一条边权为 $0$ 的边，此时就不用往下搜了。 最后，直接输出答案，即所有最小值之和即可。 接下来说原理。\n原理 首先，说一下加反向边的大致意思。\n其实就是说，你在反向边上流过 $v$ 的水，就相当于让这条边少流 $v$ 的水。\n其次，说一下BFS这部分的原理。\n还是举具体的例子。\n在这张图里，我们模拟一下，首先一定找的是 $1 \\to 2 \\to 3 \\to 4$ 这条路径。\n随后把反向边更新。\n（注：在边上面，黑色的是原本边的边权；在边下面，红色的是反向边的边权）\n接下来增广的是 $1 \\to 5 \\to 3 \\to 2 \\to 6 \\to 4$ 这条路径。\n此时已经无法继续增广。\n所以最终答案为 $2+2=4$。\n而怎么理解呢？其实只是这个返回的机制很独特而已。\n我先BFS到 $1 \\to 5 \\to 3$，然后把最开始的路径 $3 \\to 4$ 部分拼走了。\n此时最开始的路径中的 $1 \\to 2$ 开始重新寻路，就把增广路径中的 $2 \\to 6 \\to 4$ 拼走了。\n所以最后是两条路径：\n$1 \\to 5 \\to 3 \\to 4$ $1 \\to 2 \\to 6 \\to 4$ 答案为 $4$。\n复杂度 $O(nm^2)$\n其中 $n$ 为点数，$m$ 为边数。\n证明之后补\n网上的证明\nDinic 接下来就是重头戏了，就是Dinic算法。\n这个算法相比而言，复杂度就小了很多。\n并且，在求二分图最大匹配方面，比匈牙利算法跑得更快。\n这次跟上面反过来，先说原理再说实现。\n原理 首先，我们考虑一下EK算法为何复杂度如此之大。\n其实就是因为，它每次都得进行BFS，每次都从源点开始搜到汇点。\n但做了这么多功，不还是只能搜一条增广路吗。\n这就导致花的时间很多，但得到的收益很少。\n所以我们就对症下药。\n也就是我们可以一次搜多条最短路。\n不过准确来说，我们是不一定每次都从源点开始，就像遍历一棵树一样，每次都从当前点开始搜。\n这样的话复杂度就能剩很多。\n实现 原理很好解释清楚，但实现其实细节很多。\n这会虽然也用BFS，但实际上上面已经透露了，Dinic的核心在于DFS，所以BFS只求最短路。\n具体来说，我们是这样实现的：\n只要图还连通，就从源点开始做一遍BFS，求出现在源点到每个点 $i$ 的距离 $dis_i$。 此时就不断做DFS，并进行增广，直到不能增广为止。 一次DFS的返回值是多次增广的结果之和。 将答案加上返回值。 说一下，连通的意思是存在一条路径从源点到汇点且不经过边权为 $0$ 的边；同理，边权为 $0$ 的边是不可经过的。\n接下来就是重头戏了，就是DFS的具体实现。\n首先，上面EK算法里，由于用BFS实现，所以每次增广都是走的当前的最短路。\n显然这也是最优的。\n那在这里，我们也得保证一定要最短。\n咋做呢？我们不是BFS出了距离 $dis_i$ 吗？我们干脆在DFS的时候只遍历最短路图即可。\n即对于一个点 $x$，只遍历满足 $dis_{to}=dis_x+1$ 的出点 $to$。\n还是跟之前差不多（至少有点雷同的思想），直接放实现：\nDFS传入两个参数，一个是当前点 $x$，一个是流到点 $x$ 的水量 $lim$。 遍历 $x$ 的每个满足条件的出点 $to$，设这条边的边权为 $len$。 DFS下去，并且给出点 $to$ 以 $\\min(lim,len)$ 的水。 【优化】如果说发现DFS的返回值（设为 $val$）为 $0$，则说明该子树无法增广，直接将该出点标记不可访问。 这一步有一个很好的实现方式，就是把 $dis_{to}$ 设为 $0$，此时一定不会被遍历到。 更新 $x \\to to$ 及其反向边的边权。 由于 $val$ 的水已经从 $x$ 流出，所以 $lim$ 减去 $val$。 【优化】如果 $lim$ 为 $0$ 了，则水已经不可能再流出了，直接退出循环。 这里注意一个点，就是虽然给 $to$ 提供了 $\\min(lim,len)$ 的水，但其实真正流出去的只有 $val$ 单位的水，所以所有更新都应该用 $val$，完全与 $\\min(lim,len)$ 无关。 【优化】这个优化被称为“当前弧优化”： 我们考虑一下，显然一个点可能被DFS多遍。 而每次我们都遍历一遍所有出点吗？显然不是。 那么我们每次就记录一下遍历到哪个出点了。 下次就直接从这个出点开始遍历。 此处就有两种实现方式了： 使用vector建图，记录当前遍历到的下标。 使用链式前向星建图，不断更新表头。 但要注意一下，第2种方法在更改表头之后，要记得还原回来，否则会出错。 据说还有MPM算法、ISAP之类的，这里就不说了。\n复杂度 $O(n^2m)$\n其中 $n$ 为点数，$m$ 为边数。\n证明之后补\n网上的证明\n但这个只是上界，在一般的网络内，是往往达不到的。\n比如说，在 $n \\leq 10^4,m \\leq 10^5$ 的题目内，用Dinic只跑了 $300~\\text{ms}$。\n二分图 参考：这里\n这里顺便说一下如何用Dinic去求二分图最大匹配。\n既然是图论算法，难点必然在于建图。\n而这里怎么建呢？直接上结论：\n从源点往每个二分图的左侧点连容量为 $1$ 的边。 从每个二分图的右侧点往源点连容量为 $1$ 的边。 二分图的左右侧点之间仿照二分图连法连容量为 $1$ 的边。 然后跑最大流即可。\n由于图的特殊性，此时复杂度最多为 $O(m\\sqrt{n})$，与匈牙利算法的 $O(nm)$ 差了一个根号。\n最小割 如果有哪里没有说清楚，可以看这里。\n说完最大流，再说一个与它息息相关的最小割。\n还是先从定义说起。\n定义 对于一个网络（就是一张有向图）$G=(V,E)$ 来说，如果存在一个边集 $E\u0026rsquo;$ 满足 $E\u0026rsquo; \\subseteq E$。\n且从 $G$ 中删去 $E\u0026rsquo;$ 的边后，该网络的源点和汇点不再连通。\n那么 $E\u0026rsquo;$ 边集被称为割，其中的任意一条边满足 $e \\in E\u0026rsquo;$ 都被称为割边。\n而使得所有割边的容量之和最小的割，被称为是最小割。\n求值 接下来说求值。\n其实可以八个字搞定：\n最小割等于最大流 理论上这个不严谨，我们把它严谨化一下：\n对于任意一个网络，该网络的最大容量，等于该网络的最小割中所有割边的容量之和 所以其实直接求最大流即可。\n证明 之后补\n网上的\n费用流 时隔多年，终于可以补一下费用流的坑了。\n定义 首先我们需要先明白费用流是什么。\n其实就是在网络流的流量限制之外，还多了一个每流过一单位的流量需要花费的代价。\n一般分为两种：\n最小费用最大流，就是说保证最大流的情况下把费用最小化。 最小费用流，就是不用保证最大流，把费用最小化即可。 实现 直接讲实现。\n其实费用流的实现比最大流简单多了。\n最小费用最大流 直接：\n不断按单位代价作为边长跑SPFA。 只要SPFA还能走出来（不经过 $len=0$ 的边），就继续。 然后把SPFA最短路路径上所有边流过“边权的最小值”的流量。 更新答案。 所以最后的复杂度就是 $O($ 增广次数 $\\times$ SPFA复杂度 $)$。\n这个东西一看就很玄学，结果就是这样的。\n增广次数可能会被卡到流量级别（特殊构造数据情况下），SPFA则是 $O(nm)$ 最多。\n所以说一半费用流如果确定要用，且这样建图一定最优，必然是给放过的。\n不过注意一下，有时候一点不同的建图方式就是大相径庭的运行效率。\n最小费用流 稍微改一下。\n既然我们需要通过不断SPFA来增广。\n那么只要SPFA出来的最短路 $\u0026gt;0$，那么最后的费用一定不是最小了。\n于是直接：\n不断按单位代价作为边长跑SPFA。 只要SPFA还能走出来（不经过 $len=0$ 的边），就继续。 如果最短路 $\u0026gt;0$，退出循环。 把SPFA最短路路径上所有边流过“边权的最小值”的流量。 更新答案。 复杂度同上。\n网上的讲解\n","permalink":"https://qjwh.github.io/posts/oi/aln/flow/","summary":"\u003ctext style=\"font-family:Noto Sans SC\"\u003e\r\n\u003ch2 id=\"text-stylecolorrgb0150136-前言\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 前言\u003c/h2\u003e\n\u003cp\u003e首先，网络流不是一个算法，而是一个整合包（玩MC玩的），说白了就是网络流是多个算法的统称：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e最大流\n\u003cul\u003e\n\u003cli\u003eEK\u003c/li\u003e\n\u003cli\u003eDinic\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e最小割\u003c/li\u003e\n\u003cli\u003e费用流\u003c/li\u003e\n\u003cli\u003e\u0026hellip;\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e而且，有些不常用的，可能就不会提，粘个OI Wiki的链接就不详细写了。\u003c/p\u003e\n\u003cp\u003e接下来就按照这个目录挨个讲一下每个算法。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-最大流\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 最大流\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如果有哪里没有说清楚，可以看\u003ca href=\"https://oi-wiki.org/graph/flow/max-flow/\"\u003e这里\u003c/a\u003e，里面还有我没有说到的最大流类型。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e看到最大流这个名字很多人都很陌生，这里就先从定义说起。\u003c/p\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-定义\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 定义\u003c/h3\u003e\n\u003cp\u003e还是拆词法，“网络流”就可以大致理解为“网络”上的“流”，接下来就挨个说一下这两个的定义。\u003c/p\u003e\n\u003ch4 id=\"text-stylecolorrgb0150136-网络\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 网络\u003c/h4\u003e\n\u003cp\u003e先说网络的定义。\u003cdel\u003e（当然不是Internet）\u003c/del\u003e\u003c/p\u003e\n\u003cp\u003e我们在理解的时候可以认为是管道，但实际上它是一张特殊的\u003cstrong\u003e有向\u003c/strong\u003e图。\u003c/p\u003e\n\u003cp\u003e建设管道的必然知道，管道内流过的水，准确来说是单位时间内流过的水，必然是有上限限制的，否则管道就炸了。\u003c/p\u003e\n\u003cp\u003e这里也一样，对于每条边 $x \\to y$，都有一个函数 $c(x,y)$ 表示这条边的限制，又称\u003cstrong\u003e容量\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e如果在图上没有这条边，则统一规定 $c(x,y)=0$。\u003c/p\u003e\n\u003cp\u003e最后，还是跟最短路一样，它有一个起点和一个终点，又称\u003cstrong\u003e源点\u003c/strong\u003e $S$ 和\u003cstrong\u003e汇点\u003c/strong\u003e $T$（$S \\not= T$）。\u003c/p\u003e\n\u003ch4 id=\"text-stylecolorrgb0150136-流函数\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 流函数\u003c/h4\u003e\n\u003cp\u003e再说流函数。\u003c/p\u003e\n\u003cp\u003e流函数就是说，在真实操作中，一个单位时间内一条边 $x \\to y$ 流过的水量 $f(x,y)$。\u003c/p\u003e\n\u003cp\u003e这里默认保证每个单位时间内都得流过这么多。\u003c/p\u003e\n\u003cp\u003e其实很好理解。\u003c/p\u003e\n\u003ch4 id=\"text-stylecolorrgb0150136-流函数性质\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 流函数性质\u003c/h4\u003e\n\u003cp\u003e顺便说一下流函数要满足的性质。\u003c/p\u003e\n\u003cp\u003e首先，源点可以无限输出水，汇点可以无限输入水。\u003c/p\u003e\n\u003cp\u003e接下来就是一堆性质：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对于每个 $x,y$，显然 $f(x,y) \\leq c(x,y)$（\u003cstrong\u003e容量限制\u003c/strong\u003e）。\u003c/li\u003e\n\u003cli\u003e对于每个 $x,y$，$f(x,y)=-f(y,x)$（\u003cstrong\u003e斜对称\u003c/strong\u003e）。\u003c/li\u003e\n\u003cli\u003e对于每个 $x$，满足不是源点也不是汇点，$\\sum\\limits_{u \\to x} f(u,x)=\\sum\\limits_{x \\to v} f(x,v)$（\u003cstrong\u003e流量守恒\u003c/strong\u003e）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这里说一下最后一点性质。\u003c/p\u003e","title":"网络流"},{"content":"\r（说是斜率优化，其实和斜率几乎没有关系）\n（e\u0026hellip;更新后确实有关系）\n其实斜率优化和决策二分栈（队列）很像，下面分几种类型来讲。\n一维斜率优化 针对形如 $d_i=\\min\\limits_{j=0}^{i-1} \\big( d_j+w(j+1,i) \\big)$ 的方程，而且需要满足决策单调性。\n此处重新说一下，如果我们发现一个转移点 $x$ 在 $d_i$ 的时候已经比另外一个转移点 $y$ 要更优了（$x\u0026gt;y$），那么转移点 $y$ 在后面（$d_{i+1}$ 及以后）就不可能比转移点 $x$ 要更优了，那么这个DP一定满足决策单调性，而且反过来也一样（见\u0026quot;决策单调性.md\u0026quot;）。\n其实证明是否满足单调性只用看：如果一个决策点 $x$ 如果在 $d_i$ 的转移中已经比决策点 $y$ 要优了，那么 $d_{i+1}$ 中是否仍然满足这个条件。\n证明了满足决策单调性后，就可以开始斜率优化了。\n我们首先要考虑推斜率式：\n其实斜率式就是把式子 $d_x+w(x+1,i)\u0026lt;d_y+w(y+1,i)$（$x\u0026gt;y$）不断移项、变化，直到式子左边只和 $x$、$y$ 有关，右边只和 $i$ 有关为止。\n此时的斜率式一般左边是个分数，而且这个分数还需要把分子和分母的下标对应：\n如果斜率式最后是像这样的：\n$\\dfrac{d_x-d_y}{v_y-v_x}\u0026gt;-a_i$\n那么就不是个合法的斜率式，需要变成：\n$\\dfrac{d_x-d_y}{v_x-v_y}\u0026lt;a_i$\n才是合法的。\n注意，这里说的是“合法的”，而不是“正确的”，其实最上方的斜率式也可以使用，就是不能叫“斜率式”了（斜率的公式是 $\\dfrac{y_2-y_1}{x_2-x_1}$）。\n设此时的斜率式就是上面说的：\n$\\dfrac{d_x-d_y}{v_x-v_y}\u0026lt;a_i$\n那么，我们就定义 $\\text{slope}(y,x)=\\dfrac{d_x-d_y}{v_x-v_y}$。\n有了上面函数，显然如果存在两个转移点 $x$ 和 $y$（$x\u0026gt;y$）在转移到 $d_i$ 的时候满足 $\\text{slope}(x,y)\u0026lt;a_i$，那么就说明转移点 $x$ 比转移点 $y$ 更优，转移点 $y$ 在后面就不需要了。\n下面默认推出来的斜率式就是上式，并默认 $a$ 数组单调不降。\nupd：其实上面决策单调性的证明并不需要非常复杂地证明，其实只要证明斜率式的右项是否单调即可，即如果中间符号是小于，只用证明右项是否单调递增，反之亦然。（23.1.8）\n我们维护一个单调队列 $q$（设队头下标为 $h$，队尾下标为 $t$）代表目前还没有被淘汰的那些转移点，然后考虑转移 $d_i$：\n首先，如果队列大小大于等于 $2$ 且 $\\text{slope}(q_h,q_{h+1})\u0026lt;a_i$，那么就直接弹出队首。 有人问，根据单调队列性质，$q_h\u0026lt;q_{h+1}$，那不是和上面的假设 $j\u0026gt;k$ 冲突了吗？那直接弹出 $q_h$ 岂不是会错？答案是否定的。\n首先，显然，对于所有的 $(j,k)$，都满足 $\\text{slope}(j,k)=\\text{slope}(k,j)$。\n有了上述性质，即 $\\text{slope}(q_h,q_{h+1})=\\text{slope}(q_{h+1},q_h)$，那么就和假设不冲突了。\n所以，如果 $\\text{slope}(q_{h+1},q_h)\u0026lt;a_i$，那么由于 $q_{h+1}\u0026gt;q_h$，所以 $q_h$ 就会被 $q_{h+1}$ 所取代，就会被弹出队列。\n其次，以 $q_h$ 作为转移点转移 $d_i$。 然后，如果队列大小大于等于 $2$ 且 $\\text{slope}(q_{t-1},q_t) \\geq \\text{slope}(q_t,i)$，那么就直接弹出队尾。 首先，在此时的 $q_t$ 和 $i$ 在将来成为队列的前两个元素的时候，且 $\\text{slope}(q_h,q_{h+1})\u0026lt;a_i$ 的条件也满足的时候（此时的时刻设为时刻1），此时的 $q_t$ 也会被弹出。\n其次，在此时的 $q_{t-1}$ 和 $q_t$ 在将来成为队列的前两个元素的时候，且 $\\text{slope}(q_h,q_{h+1})\u0026lt;a_i$ 的条件也满足的时候（此时的时刻设为时刻2），此时的 $q_{t-1}$ 也会被弹出。\n显然，时刻1小于时刻2。\n所以综上所述，如果此时的 $q_{t-1}$ 被弹出了，那么 $q_t$ 也被弹出了，而 $q_{t-1}$ 更靠队头一些，所以 $q_t$ 是不需要的。\n最后，在队尾加入 $i$。 （参考代码：M2500、M2506）\n二维斜率优化 其实也差不多，它针对的是形如 $d_{i,j}=\\min\\limits_{k=0}^{i-1} \\big( d_{k,j-1}+w(k+1,i) \\big)$ 的转移方程，且满足决策单调性（记 $d_{i,j}$ 的最优转移点为 $f_{i,j}$，那么此处的“决策单调性”就是指的对于所有的 $i$、$j$ 都满足 $f_{i,j} \\leq f_{i+1,j}$）。\n实现也差不多，我们直接从小到大枚举 $j$，然后对于所有 $i$ 分别用上述做法转移即可，就是需要改一些细节，但也不多。\n（参考题目：M2515）\n没有决策单调性的斜率优化（upd on 23.1.6） 针对形如 $d_i=\\max\\limits_{j=0}^{i-1} \\big( d_j+w(j+1,i) \\big)$ 的方程，但不满足决策单调性。\n还是老规矩，我们推导一下斜率式，设推导结果为 $\\dfrac{y_j-y_k}{x_j-x_k}\u0026gt;s_i$，并且要求 $x$ 数组单调不降，但 $s$ 数组不一定，可能是非常不规则的数组。\n此处可以发现我们变换了一下变量名，其实没有决策单调性的斜率优化我就是用「把一个转移点 $j$ 想成一个二维平面上的坐标 $(x_j,y_j)$」的方法理解的。\n一样，我们维护一个单调队列 $q$（设队头下标为 $h$，队尾下标为 $t$）代表目前还没有被淘汰的那些转移点（当前队列内的点斜率单调递减），然后考虑转移 $d_i$：\n首先，由于不满足单调性，所以此处不能弹出队首，我们需要二分出斜率小于等于 $s_i$ 的最后面的下标来作为转移点。 其次，以找到的下标为转移点来转移 $d_i$。 然后，如果队列大小大于等于 $2$ 且 $\\text{slope}(q_{t-1},q_t) \\leq \\text{slope}(q_t,i)$，那么就直接弹出队尾。 有人对这个过程有疑问，此处解释一下。\n其实这个单调队列里维护的是一个斜率单调递减的凸包（不要和数学知识里的“凸包”搞混了，和那个“凸包”没有任何关系；下面的“凸壳”也是指的“凸包”），如下图所示：\n在这里，“凸包”其实就是指的如上图的一个“包”住所有点的“拼合线段”（多个线段“拼”起来后的东西在这里称为“拼合线段”）。\n我们考虑新加一个点：（最右上角）\n比较此时队列后两个元素：\n显然两个绿色虚线相比，前者斜率小于后者，所以弹出队尾，继续比较：\n还是前者（斜率）小于后者，弹出队尾，继续比较：\n终于满足条件了，所以队列最后只剩下这些元素了：\n自己推一下式子就知道了，其实上面那个斜率式原本的形式是 $y_j-s_i \\times x_j\u0026gt;y_k-s_i \\times x_k$（即 $w(j+1,i)=y_j-s_i \\times x_j$），回顾整个删除过程，显然所有删除的点都不可能比最后留下的三个转移点要更优。\n其他情况可以自己讨论一下，很容易证明。\n最后，在队尾加入 $i$。 （参考代码：M2484）\nX坐标不满足递增的斜率优化（upd on 23.2.26） 针对形如 $d_i=\\max\\limits_{j=0}^{i-1} \\big( d_j+w(j+1,i) \\big)$ 的方程，但推导后的斜率式中X坐标不满足决策单调性。\n还是老规矩，我们推导一下斜率式，设推导结果为 $\\dfrac{y_j-y_k}{x_j-x_k}\u0026gt;s_i$，并且假设 $x$ 数组（X坐标）并不单调，但 $s$ 数组不一定，可能是非常不规则的数组。\n（注意，X、Y坐标不一定是一开始就能知道的，可能需要在求出DP值后才可以求出的，但 $s$ 数组必须在一开头就能求出）\n初始化 在这种情况下，我们就要用到CDQ分治了。\n我们直接给 $d$ 数组赋初值，并记录初始每个点的X坐标和Y坐标（还有下标），赋值到一个数组 $q$ 里去，然后把 $q$ 数组按 $s_i$ 从大到小排序。\n设计CDQ函数 然后我们考虑设计 $\\text{cdq}(l,r)$ 函数。\n首先，如果 $l=r$，那么此时 $d_l$ 的值就知道了，所以我们就用新的 $d_l$ 值重新更新 $q_l$ 的X、Y坐标。\n否则，我们求出 $[l,r]$ 区间的中点 $\\text{mid}$。\n然后，我们把 $q_l \\sim q_r$ 内所有的 $q_i$ 按照其原本下标值（设为 $q_i . \\text{id}$）分组：把满足 $q_i . \\text{id} \\leq \\text{mid}$ 的分成一组，依次赋值到 $q_l \\sim q_{\\text{mid}}$；另一部分，即满足 $q_i . \\text{id}\u0026gt;\\text{mid}$ 的分成一组，依次赋值到 $q_{\\text{mid}+1} \\sim q_r$。\n由于我们在下面计算时，需要用到 $q_l \\sim q_{\\text{mid}}$ 的真实X、Y坐标，所以要先递归 $\\text{cdq}(l,\\text{mid})$。\n然后，我们考虑 $d_l \\sim d_{\\text{mid}}$ 对 $d_{\\text{mid}+1} \\sim d_r$ 的影响。\n我们先对 $d_l \\sim d_{\\text{mid}}$ 用上述方式（斜率优化模板）建一个凸壳，用一个队列 $\\text{que}_{h \\dots t}$（名称为 $\\text{que}$，队首下标为 $h$，队尾下标为 $t$）存起来。\n我们再循环 $i=\\text{mid}+1 \\sim r$，然后看如果 $q_h$ 比 $q_{h+1}$ 要劣，删除 $q_h$。\n弹出所有无用状态后，直接用 $q_h$ 更新 $d_i$ 即可。\n执行完转移后，递归 $\\text{cdq}(\\text{mid}+1,r)$。\n但要注意，可以维护凸壳有且仅当X坐标递增，所以此处要拿 $l \\sim \\text{mid}$ 和 $\\text{mid}+1 \\sim r$ 的排序结果，把 $q_l \\sim q_r$ 内所有元素按X坐标递增顺序排序。\n（参考代码：M2590）\n补充：\n名不副实的意思是：空有虚名，名声和实际不一致。也说名不符实。\n","permalink":"https://qjwh.github.io/posts/oi/aln/slopeopm/","summary":"\u003ctext style=\"font-family:Noto Sans SC\"\u003e\r\n\u003cp\u003e\u003cdel\u003e（说是斜率优化，其实和斜率几乎没有关系）\u003c/del\u003e\u003c/p\u003e\n\u003cp\u003e\u003cdel\u003e（e\u0026hellip;更新后确实有关系）\u003c/del\u003e\u003c/p\u003e\n\u003cp\u003e其实斜率优化和决策二分栈（队列）很像，下面分几种类型来讲。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-一维斜率优化\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 一维斜率优化\u003c/h2\u003e\n\u003cp\u003e针对形如 $d_i=\\min\\limits_{j=0}^{i-1} \\big( d_j+w(j+1,i) \\big)$ 的方程，而且需要满足决策单调性。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e此处重新说一下，如果我们发现一个转移点 $x$ 在 $d_i$ 的时候已经比另外一个转移点 $y$ 要更优了（$x\u0026gt;y$），那么转移点 $y$ 在后面（$d_{i+1}$ 及以后）就不可能比转移点 $x$ 要更优了，那么这个DP一定满足决策单调性，而且反过来也一样（见\u0026quot;决策单调性.md\u0026quot;）。\u003c/p\u003e\n\u003cp\u003e其实证明是否满足单调性只用看：如果一个决策点 $x$ 如果在 $d_i$ 的转移中已经比决策点 $y$ 要优了，那么 $d_{i+1}$ 中是否仍然满足这个条件。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e证明了满足决策单调性后，就可以开始斜率优化了。\u003c/p\u003e\n\u003cp\u003e我们首先要考虑推斜率式：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e其实斜率式就是把式子 $d_x+w(x+1,i)\u0026lt;d_y+w(y+1,i)$（$x\u0026gt;y$）不断移项、变化，直到式子左边只和 $x$、$y$ 有关，右边只和 $i$ 有关为止。\u003c/p\u003e\n\u003cp\u003e此时的斜率式一般左边是个分数，而且这个分数还需要把分子和分母的下标对应：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如果斜率式最后是像这样的：\u003c/p\u003e\n\u003cp\u003e$\\dfrac{d_x-d_y}{v_y-v_x}\u0026gt;-a_i$\u003c/p\u003e\n\u003cp\u003e那么就不是个合法的斜率式，需要变成：\u003c/p\u003e\n\u003cp\u003e$\\dfrac{d_x-d_y}{v_x-v_y}\u0026lt;a_i$\u003c/p\u003e\n\u003cp\u003e才是合法的。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e注意，这里说的是“合法的”，而不是“正确的”，其实最上方的斜率式也可以使用，就是不能叫“斜率式”了（斜率的公式是 $\\dfrac{y_2-y_1}{x_2-x_1}$）。\u003c/p\u003e\u003c/blockquote\u003e\u003c/blockquote\u003e\n\u003cp\u003e设此时的斜率式就是上面说的：\u003c/p\u003e\n\u003cp\u003e$\\dfrac{d_x-d_y}{v_x-v_y}\u0026lt;a_i$\u003c/p\u003e\n\u003cp\u003e那么，我们就定义 $\\text{slope}(y,x)=\\dfrac{d_x-d_y}{v_x-v_y}$。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e有了上面函数，显然如果存在两个转移点 $x$ 和 $y$（$x\u0026gt;y$）在转移到 $d_i$ 的时候满足 $\\text{slope}(x,y)\u0026lt;a_i$，那么就说明转移点 $x$ 比转移点 $y$ 更优，转移点 $y$ 在后面就不需要了。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e下面默认推出来的斜率式就是上式，并默认 $a$ 数组单调不降。\u003c/p\u003e","title":"斜率优化"},{"content":"要说行列式，就得先说一下矩阵（其实是方阵）的秩的定义。\n对于一个方阵，其秩的定义就是矩阵里线性无关的极大值。\n听这个定义有点难懂，这里解释一下。\n其实一个方阵就可以被当做是一个没有右项的方程集。\n而一个方阵的秩就可以当做是，这个没有右项的方程集在经过高斯消元后，非 $0$ 行的数量。\n有了这个定义，矩阵的秩还可以被当做是，这个没有右项的方程集中，不会被其他方程替代掉的方程数量：\n解释一下，如果方程长这样：\n$ \\begin{cases} -x_1+2x_2+5x_3=11 \\ 2x_1=8 \\ x_1+2x_2+5x_3=19 \\end{cases} $\n那么，其实第三个方程式可以通过前两个方程式推出来，也就称作第三个方程式可以被前两个方程式替代掉。\n知道了“替代”的定义后，就知道了一件事，就是上面说的“会被其他方程替代掉的方程”，这些方程可以直接从方程组里去掉，而不影响最终的解。\n所以，我们就可以对奥数里的一个点做一个更简洁的解释：\n在奥数里，讲了解 $n$ 元一次方程（组）的方法。\n同时还说了，在这个 $n$ 元一次方程组内，如果“有用”的方程数量，刚好等于未知数的数量，或者大于未知数的数量，那么这个方程组就有唯一解。\n这一点可以被更简洁地解释为：\n这个 $n$ 元一次方程组，转化为“高斯矩阵”，并删除最后一列后（变成 $n \\times n$ 的方阵），如果这个方阵的秩刚好为 $n$，那么这个方程组就有唯一解。\n然后，我们回归正题，说行列式。\n行列式是对于一个方阵来讲的，一个方阵有行列式有且仅当这个方程的秩刚好等于方阵的大小（行或者列）。\n行列式的定义此处不讲，因为：\n太复杂了 （几乎）没有用处 行列式的计算方法是用的高斯消元。\n在高斯消元的思路里，提到了三种“基本行变换”：（以下全部以高斯矩阵的角度去说）\n将一行全部乘上一个非 $0$ 实数 $x$，解不变。 将一行内的所有元素对应地加上/减去另一行对应的元素乘上一个非 $0$ 实数 $x$，解不变。 交换两行，解不变。 这三种基本行变换在执行前后，行列式并不是都不变的：\n将一行全部乘上一个非 $0$ 实数 $x$，行列式也会乘上 $x$。 将一行内的所有元素对应地加上/减去另一行对应的元素乘上一个非 $0$ 实数 $x$，行列式不变。 交换两行，行列式变号（负数变成正数，反之亦然）。 所以我们只用写一下高斯消元，然后处理一下对行列式的值的变化即可。\n但这儿还有一点问题，就是行列式怎么求。\n求法很好记，如果说当前方阵是个上三角矩阵（设方阵叫 $a$，那么 $a$ 是个上三角矩阵有且仅当对于所有的 $(i,j)$，如果满足 $i\u0026gt;j$，那么 $a_{i,j}$ 一定要等于 $0$，当然其他方格不做要求），那么这个方阵的行列式就是这个方阵中正对角线上的元素的乘积。\n进而就可以写出行列式的模板了。\n此外，行列式还满足一个性质。\n对于一个方阵 $A$，如果它的构造如下：\n$ A= \\begin{bmatrix} B \u0026amp; C \\ 0 \u0026amp; D \\end{bmatrix} $\n其中 $B$、$D$ 皆为方阵，$C$ 不做限制。\n即，如果把 $A$ 划分成这样：\n满足绿色部分内全部都是 $0$，红色部分 $B$ 和蓝色部分 $D$ 都是方阵。\n那么，设 $\\det A$ 为矩阵 $A$ 的行列式值，那么 $\\det A$ 一定等于 $(\\det B) \\times (\\det D)$。\n行列式的求法有了，但有人就有个问题了，如果模数不是质数，那么怎么求行列式呢？接下来说一下做法。\n首先，模数不是质数，就说明数可能没有逆元，所以以下两种操作无法进行：\n将同一行同时乘上一个非 $0$ 整数（在乘的同时，行列式的值也需要除上相同的数，涉及逆元，证毕） 将同一行同时除以一个非 $0$ 整数（除的时候就涉及逆元了，证毕） 其次，我们考虑做法。\n在高斯-约旦消元法里，要求把 $1 \\sim n-1$ 行（除了 $now$ 行）的第 $j$ 列全部变成 $0$。\n但由于模数不是质数，就无法用以前的思路去做到上述点了。\n但也不是不能做到，这里就说一下。\n记得“更相减损术”（又称“辗转相减法”）没？更相减损术是解决 $\\gcd(a,b)$ 的一个利器。\n更相减损术就是说 $\\gcd(a,b)=\\gcd(b,a-b)$。\n更相减损术还说了，用递归实现上述公式，递归到最后，$a$、$b$ 两个数之一一定会成为 $0$。\n但“辗转相除法”比“更相减损术”要快，代码也更短，所以容易被忘掉，但这里成了推导过程中必须的一步。\n具体地，用上面说的更相减损术的方法，我们就可以设计出一个算法来了：\n我们循环每个比 $now$ 大的 $i$（此处不需要循环每个不等于 $now$ 的 $i$，因为如果这么循环，是无法实现的，实现起来是错的；而且行列式只要求我们消成上三角矩阵即可，不用消成严格对角矩阵），然后我们只关注第 $now$ 行和第 $i$ 行。\n我们不断比较这两行的主元（第 $j$ 列上的值），将主元更小的放到第 $now$ 行，主元更大的放到第 $i$ 行。\n然后，将第 $i$ 行全部对应地减去第 $now$ 行。\n重复以上过程直到第 $i$ 行第 $j$ 列消成了 $0$。\n为了防止出现特殊情况，每次循环时也顺便判断一下第 $now$ 行第 $j$ 列是否是 $0$。\n但这个算法复杂度很大，所以我们需要优化。\n记得上面还提到了“辗转相除法”，这里就要用这个来优化，变成：\n我们还是循环每个比 $now$ 大的 $i$，然后我们只关注第 $now$ 行和第 $i$ 行。\n我们不断比较这两行的主元（第 $j$ 列上的值），将主元更小的放到第 $now$ 行，主元更大的放到第 $i$ 行。\n然后，将第 $i$ 行全部对应地减去第 $now$ 行乘上 $\\left\\lfloor \\dfrac{第i行的主元}{第now行的主元} \\right\\rfloor$。\n重复以上过程直到第 $i$ 行第 $j$ 列消成了 $0$。\n为了防止出现特殊情况，每次循环时也顺便判断一下第 $now$ 行第 $j$ 列是否是 $0$。\n用辗转相除法就可以把循环次数优化到 $O(~\\log$ 数字 $)$ 级别\n以上所有过程显然都不会影响行列式，所以做法正确。\n","permalink":"https://qjwh.github.io/posts/oi/aln/hanglieshi/","summary":"\u003cp\u003e要说行列式，就得先说一下矩阵（其实是方阵）的秩的定义。\u003c/p\u003e\n\u003cp\u003e对于一个方阵，其秩的定义就是矩阵里线性无关的极大值。\u003c/p\u003e\n\u003cp\u003e听这个定义有点难懂，这里解释一下。\u003c/p\u003e\n\u003cp\u003e其实一个方阵就可以被当做是一个没有右项的方程集。\u003c/p\u003e\n\u003cp\u003e而一个方阵的秩就可以当做是，这个没有右项的方程集在经过高斯消元后，非 $0$ 行的数量。\u003c/p\u003e\n\u003cp\u003e有了这个定义，矩阵的秩还可以被当做是，这个没有右项的方程集中，不会被其他方程替代掉的方程数量：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e解释一下，如果方程长这样：\u003c/p\u003e\n\u003cp\u003e$\n\\begin{cases}\n-x_1+2x_2+5x_3=11 \\\n2x_1=8 \\\nx_1+2x_2+5x_3=19\n\\end{cases}\n$\u003c/p\u003e\n\u003cp\u003e那么，其实第三个方程式可以通过前两个方程式推出来，也就称作第三个方程式可以被前两个方程式替代掉。\u003c/p\u003e\n\u003cp\u003e知道了“替代”的定义后，就知道了一件事，就是上面说的“会被其他方程替代掉的方程”，这些方程可以直接从方程组里去掉，而不影响最终的解。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e所以，我们就可以对奥数里的一个点做一个更简洁的解释：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在奥数里，讲了解 $n$ 元一次方程（组）的方法。\u003c/p\u003e\n\u003cp\u003e同时还说了，在这个 $n$ 元一次方程组内，如果“有用”的方程数量，刚好等于未知数的数量，或者大于未知数的数量，那么这个方程组就有唯一解。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e这一点可以被更简洁地解释为：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e这个 $n$ 元一次方程组，转化为“高斯矩阵”，并删除最后一列后（变成 $n \\times n$ 的方阵），如果这个方阵的秩刚好为 $n$，那么这个方程组就有唯一解。\u003c/p\u003e\u003c/blockquote\u003e\n\u003chr\u003e\n\u003cp\u003e然后，我们回归正题，说行列式。\u003c/p\u003e\n\u003cp\u003e行列式是对于一个方阵来讲的，一个方阵有行列式有且仅当这个方程的秩刚好等于方阵的大小（行或者列）。\u003c/p\u003e\n\u003cp\u003e行列式的定义此处不讲，因为：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e太复杂了\u003c/li\u003e\n\u003cli\u003e（几乎）没有用处\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e行列式的计算方法是用的高斯消元。\u003c/p\u003e\n\u003cp\u003e在高斯消元的思路里，提到了三种“基本行变换”：（以下全部以高斯矩阵的角度去说）\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将一行全部乘上一个非 $0$ 实数 $x$，解不变。\u003c/li\u003e\n\u003cli\u003e将一行内的所有元素对应地加上/减去另一行对应的元素乘上一个非 $0$ 实数 $x$，解不变。\u003c/li\u003e\n\u003cli\u003e交换两行，解不变。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这三种基本行变换在执行前后，行列式并不是都不变的：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将一行全部乘上一个非 $0$ 实数 $x$，行列式也会乘上 $x$。\u003c/li\u003e\n\u003cli\u003e将一行内的所有元素对应地加上/减去另一行对应的元素乘上一个非 $0$ 实数 $x$，行列式不变。\u003c/li\u003e\n\u003cli\u003e交换两行，行列式变号（负数变成正数，反之亦然）。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e所以我们只用写一下高斯消元，然后处理一下对行列式的值的变化即可。\u003c/p\u003e\n\u003cp\u003e但这儿还有一点问题，就是行列式怎么求。\u003c/p\u003e\n\u003cp\u003e求法很好记，如果说当前方阵是个上三角矩阵（设方阵叫 $a$，那么 $a$ 是个上三角矩阵有且仅当对于所有的 $(i,j)$，如果满足 $i\u0026gt;j$，那么 $a_{i,j}$ 一定要等于 $0$，当然其他方格不做要求），那么这个方阵的行列式就是这个方阵中正对角线上的元素的乘积。\u003c/p\u003e","title":"行列式"},{"content":"说一个非常重要的语法错误。\n如果你写这样一句话：\nv[x] = newnode(); 其中：\nv为一个vector。 x为不越界的非负整数，且不会变化。 newnode()函数内会向vector内push_back一个新元素，并返回加入元素（即最后一个元素）的下标。 那么，你会发现，v[x]的值并不是这样变化的：\n1,2,3,4,5,6,7,... 而是类似于这样的：（非真实输出结果，仅供参考）\n1,1,2,2,3,4,4,5,6,7,8,8,9,10,11,12,13,14,15,16,16,17,18,19,20,... 你会发现部分情况下，v[x]没有变化！\n这实际上是因为vector的内部机制。\nvector会有一个capacity，就是提供的内存大小。\n每次push_back的时候，如果说加入后，不超过当前的capacity，就会直接加入。\n否则，vector会新开辟一块等于当前capacity的两倍（这个在不同编辑器上是不一样的，有些可能是每次新增 $5$ 个）的新空间，并把原本的数据拷进这块新空间内。\n比如说现在的vector是：\n内存354~357位置：3 1 2 4 且capacity是 $4$，那么我们如果尝试push_back一个 $5$，则vector就会发现大于了capacity，便会新开一块等于当前capacity的两倍的空间：\n内存354~357位置：3 1 2 4\r内存382~389位置： 并把当前数据拷进去：\n内存354~357位置：3 1 2 4\r内存382~389位置：3 1 2 4 然后在新空间内加入 $5$：\n内存354~357位置：3 1 2 4\r内存382~389位置：3 1 2 4 5 并把所有v[x]指向的内存都改成382~389这块新内存内对应的地方。\n不过由于C++的赋值机制，系统会先找到要赋值给的变量的指针，然后求出要赋的值，赋给以前找到的指针。（这一步是推测，可能不准确）\n所以就会导致把newnode()的值赋给了原本的v[x]，导致输出的时候访问的新v[x]值出错。\n解决方法也很简单，把newnode()用个临时变量t存储，并将v[x]赋值为t即可。\n","permalink":"https://qjwh.github.io/posts/oi/aln/animportantgrammer/","summary":"\u003cp\u003e说一个非常重要的语法错误。\u003c/p\u003e\n\u003cp\u003e如果你写这样一句话：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enewnode\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e其中：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ev\u003c/code\u003e为一个\u003ccode\u003evector\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ex\u003c/code\u003e为不越界的非负整数，且不会变化。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enewnode()\u003c/code\u003e函数内会向\u003ccode\u003evector\u003c/code\u003e内\u003ccode\u003epush_back\u003c/code\u003e一个新元素，并返回加入元素（即最后一个元素）的下标。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e那么，你会发现，\u003ccode\u003ev[x]\u003c/code\u003e的值并不是这样变化的：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e1,2,3,4,5,6,7,...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e而是类似于这样的：（非真实输出结果，仅供参考）\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e1,1,2,2,3,4,4,5,6,7,8,8,9,10,11,12,13,14,15,16,16,17,18,19,20,...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e你会发现部分情况下，\u003ccode\u003ev[x]\u003c/code\u003e没有变化！\u003c/p\u003e\n\u003cp\u003e这实际上是因为\u003ccode\u003evector\u003c/code\u003e的内部机制。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003evector\u003c/code\u003e会有一个\u003ccode\u003ecapacity\u003c/code\u003e，就是提供的内存大小。\u003c/p\u003e\n\u003cp\u003e每次\u003ccode\u003epush_back\u003c/code\u003e的时候，如果说加入后，不超过当前的\u003ccode\u003ecapacity\u003c/code\u003e，就会直接加入。\u003c/p\u003e\n\u003cp\u003e否则，\u003ccode\u003evector\u003c/code\u003e会新开辟一块等于当前\u003ccode\u003ecapacity\u003c/code\u003e的两倍（这个在不同编辑器上是不一样的，有些可能是每次新增 $5$ 个）的新空间，并把原本的数据拷进这块新空间内。\u003c/p\u003e\n\u003cp\u003e比如说现在的\u003ccode\u003evector\u003c/code\u003e是：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e内存354~357位置：3 1 2 4\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e且\u003ccode\u003ecapacity\u003c/code\u003e是 $4$，那么我们如果尝试\u003ccode\u003epush_back\u003c/code\u003e一个 $5$，则\u003ccode\u003evector\u003c/code\u003e就会发现大于了\u003ccode\u003ecapacity\u003c/code\u003e，便会新开一块等于当前\u003ccode\u003ecapacity\u003c/code\u003e的两倍的空间：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e内存354~357位置：3 1 2 4\r\n内存382~389位置：\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e并把当前数据拷进去：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e内存354~357位置：3 1 2 4\r\n内存382~389位置：3 1 2 4\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e然后在新空间内加入 $5$：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e内存354~357位置：3 1 2 4\r\n内存382~389位置：3 1 2 4 5\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e并把所有\u003ccode\u003ev[x]\u003c/code\u003e指向的内存都改成\u003ccode\u003e382~389\u003c/code\u003e这块新内存内对应的地方。\u003c/p\u003e\n\u003cp\u003e不过由于C++的赋值机制，系统会先找到要赋值给的变量的指针，然后求出要赋的值，赋给以前找到的指针。\u003cem\u003e（这一步是推测，可能不准确）\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e所以就会导致把\u003ccode\u003enewnode()\u003c/code\u003e的值赋给了原本的\u003ccode\u003ev[x]\u003c/code\u003e，导致输出的时候访问的新\u003ccode\u003ev[x]\u003c/code\u003e值出错。\u003c/p\u003e\n\u003cp\u003e解决方法也很简单，把\u003ccode\u003enewnode()\u003c/code\u003e用个临时变量\u003ccode\u003et\u003c/code\u003e存储，并将\u003ccode\u003ev[x]\u003c/code\u003e赋值为\u003ccode\u003et\u003c/code\u003e即可。\u003c/p\u003e","title":"一个非常重要的语法点"},{"content":"\r在数学、编程界里，可能会经常遇到方程，而且有时候还会遇到一种特殊方程——一元二次方程。\n除此之外，还有含参一元二次方程，这里也会一起讲。（待补充）\n其实还有如二元一次方程、一元三次方程等的特殊方程，但在这里不讲。\n一元二次方程 有人看到“一元二次方程”就不知道是啥意思，这里先说一下定义\n定义 首先，方程相信大家都见过，所以这里不写对方程的定义解释。（废话\n而 $x$ 元 $y$ 次方程就是这么定义的：\n这个方程经过化简后，共有 $x$ 个未知数，且未知数上的最大指数为 $y$ 的方程。 如：\n$3(x+1)=6x$：一元一次方程，也是最常见的方程。 $3(x+1)^2=2(x+1)$：一元一次方程，因为两边可以同时除以 $x+1$ 以让指数减少 $1$。 $x^2-4x+1=0$：一元二次方程，也是下面要讲的方程类型。 $x^3+2x^2-1=16x$：一元三次方程，也是一种不常见的方程类型。 讲完定义，接下来说怎么解\n解法 推导 我们把方程一般化，变成：\n$ax^2+bx+c=0$\n其中 $a$、$b$、$c$ 均为常量。\n然后，我们不断对方程做一些推导。\n移项\n$ax^2+bx=-c$\n同时除以 $a$ 常量\n$x^2+\\dfrac{b}{a}x=-\\dfrac{c}{a}$\n这个式子很多人看了就不知道怎么继续推导了。\n但还是可以继续转化的。\n我们考虑配方，即把式子的左/右项同时加/减/乘/除一个相同的数，然后让这个等式的左/右项变成一个数的平方的形式。\n这一步比较考验数感，一个结论就是，我们同时加上 $\\left( \\dfrac{b}{2a} \\right)^2$ 常量 即可。\n$x^2+\\dfrac{b}{a}x+\\left( \\dfrac{b}{2a} \\right)^2=-\\dfrac{c}{a}+\\left( \\dfrac{b}{2a} \\right)^2$\n化简\n$\\left( x+\\dfrac{b}{2a} \\right)^2=\\dfrac{-c}{a}+\\dfrac{b^2}{4a^2}$\n二次化简\n$\\left( x+\\dfrac{b}{2a} \\right)^2=\\dfrac{b^2-4ac}{4a^2}$\n同时开根号\n$x+\\dfrac{b}{2a}=\\sqrt{\\dfrac{b^2-4ac}{4a^2}}$\n移项\n$x=\\sqrt{\\dfrac{b^2-4ac}{4a^2}}-\\dfrac{b}{2a}$\n提出分母\n$x=\\dfrac{\\sqrt{b^2-4ac}}{2a}-\\dfrac{b}{2a}$\n化简\n$x=\\dfrac{-b+\\sqrt{b^2-4ac}}{2a}$\n但 $\\sqrt{b^2-4ac}$ 是可以正也可以负的，所以变化符号一下。\n$x=\\dfrac{-b \\pm \\sqrt{b^2-4ac}}{2a}$\n于是一元二次方程得解。\n定义与总结 在一元二次方程里，还有一个名词——根，你可以当“方程的解”理解。\n而且，一元二次方程里，最多只有两个根。\n我们把两个根分别表示为 $x_1$ 和 $x_2$，那么：\n$x_1=\\dfrac{-b+\\sqrt{b^2-4ac}}{2a}$\n$x_2=\\dfrac{-b-\\sqrt{b^2-4ac}}{2a}$\n同时，我们定义 $\\Delta$（读作 $\\text{delta}$，音标/'deltə/），即“根的判别式”，为 $b^2-4ac$，就是这个地方的式子：\n$x_{1,2}=\\dfrac{-b \\pm \\sqrt{\\color{red} b^2-4ac}}{2a}$ 而根据 $\\sqrt{~~}$ 内不能为负数的限制，如果 $\\Delta\u0026lt;0$，则无实根（注意，不是无解）。\n关于为啥不是无解，这里解释一下，因为有一种数叫虚数，可以被表示为 $ai+b$（$a \\not= 0$），其中 $i=\\sqrt{-1}$ 的数都被称作虚数。\n而 $\\Delta\u0026lt;0$ 时根就是虚数。\n而如果 $\\Delta=0$，则两个根相同，均为 $\\dfrac{-b}{2a}$。\n否则，$\\Delta\u0026gt;0$，两个根分别为 $\\dfrac{-b+\\sqrt{\\Delta}}{2a}$ 和 $\\dfrac{-b-\\sqrt{\\Delta}}{2a}$。\n含参一元二次方程 （待补充）\n","permalink":"https://qjwh.github.io/posts/oi/aln/quadraticequation/","summary":"\u003ctext style=\"font-family:Noto Sans SC\"\u003e\r\n\u003cp\u003e在数学、编程界里，可能会经常遇到方程，而且有时候还会遇到一种特殊方程——一元二次方程。\u003c/p\u003e\n\u003cp\u003e除此之外，还有含参一元二次方程，这里也会一起讲。\u003cem\u003e（待补充）\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e其实还有如二元一次方程、一元三次方程等的特殊方程，但在这里不讲。\u003c/p\u003e\n\u003ch1 id=\"text-stylecolorrgb0150136-一元二次方程\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 一元二次方程\u003c/h1\u003e\n\u003cp\u003e有人看到“一元二次方程”就不知道是啥意思，这里先说一下定义\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-定义\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 定义\u003c/h2\u003e\n\u003cp\u003e首先，方程相信大家都见过，所以这里不写对方程的定义解释。（废话\u003c/p\u003e\n\u003cp\u003e而 $x$ 元 $y$ 次方程就是这么定义的：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e这个方程\u003cstrong\u003e经过化简\u003c/strong\u003e后，共有 $x$ 个未知数，且\u003cstrong\u003e未知数上\u003c/strong\u003e的最大指数为 $y$ 的方程。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$3(x+1)=6x$：一元一次方程，也是最常见的方程。\u003c/li\u003e\n\u003cli\u003e$3(x+1)^2=2(x+1)$：一元一次方程，因为两边可以同时除以 $x+1$ 以让指数减少 $1$。\u003c/li\u003e\n\u003cli\u003e$x^2-4x+1=0$：一元二次方程，也是下面要讲的方程类型。\u003c/li\u003e\n\u003cli\u003e$x^3+2x^2-1=16x$：一元三次方程，也是一种不常见的方程类型。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e讲完定义，接下来说怎么解\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-解法\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 解法\u003c/h2\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-推导\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 推导\u003c/h3\u003e\n\u003cp\u003e我们\u003cstrong\u003e把方程一般化\u003c/strong\u003e，变成：\u003c/p\u003e\n\u003cp\u003e$ax^2+bx+c=0$\u003c/p\u003e\n\u003cp\u003e其中 $a$、$b$、$c$ 均为常量。\u003c/p\u003e\n\u003cp\u003e然后，我们不断对方程做一些推导。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e移项\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e$ax^2+bx=-c$\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e同时除以 $a$ 常量\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e$x^2+\\dfrac{b}{a}x=-\\dfrac{c}{a}$\u003c/p\u003e\n\u003cp\u003e这个式子很多人看了就不知道怎么继续推导了。\u003c/p\u003e\n\u003cp\u003e但还是可以继续转化的。\u003c/p\u003e\n\u003cp\u003e我们考虑\u003cstrong\u003e配方\u003c/strong\u003e，即把式子的左/右项同时加/减/乘/除一个相同的数，然后让这个等式的左/右项变成一个数的平方的形式。\u003c/p\u003e\n\u003cp\u003e这一步比较考验数感，一个结论就是，我们\u003cstrong\u003e同时加上 $\\left( \\dfrac{b}{2a} \\right)^2$ 常量\u003c/strong\u003e 即可。\u003c/p\u003e\n\u003cp\u003e$x^2+\\dfrac{b}{a}x+\\left( \\dfrac{b}{2a} \\right)^2=-\\dfrac{c}{a}+\\left( \\dfrac{b}{2a} \\right)^2$\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e化简\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e$\\left( x+\\dfrac{b}{2a} \\right)^2=\\dfrac{-c}{a}+\\dfrac{b^2}{4a^2}$\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e二次化简\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e$\\left( x+\\dfrac{b}{2a} \\right)^2=\\dfrac{b^2-4ac}{4a^2}$\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e同时开根号\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e$x+\\dfrac{b}{2a}=\\sqrt{\\dfrac{b^2-4ac}{4a^2}}$\u003c/p\u003e","title":"一元二次方程解法（未完工）"},{"content":"\r感谢这篇文章的作者\n整除分块主要解决求解 $\\sum\\limits_{i=1}^n \\lfloor \\frac{n}{i} \\rfloor$ 的值。\n一看这个公式，可能毫无头绪，但画张图你就有点思路了：（$n=11$）\n（灰色线：$y=\\frac{11}{x}$，绿色点：$y=\\lfloor \\frac{11}{x} \\rfloor$，橙色线：仅为辅助）\n这张图其实就是在提示我们：\n$\\lfloor \\frac{n}{i} \\rfloor$ 的值随着 $i$ 的增长而非单调递减 $\\lfloor \\frac{n}{i} \\rfloor$ 的值往往会在一段区间内相等 所以，我们就有一个思路了，就是求出所有值（下面的“值”都代指的是 $\\lfloor \\frac{n}{i} \\rfloor$）相等的极大区间集，然后就可以快速统计了。\n有人问，这不就是个常数级别的优化吗，怎么能叫“快速”呢？其实区间个数总是 $O(\\sqrt{n})$ 级别，最多约 $2 \\times \\sqrt{n}$。\n证明：\n我们把 $i$ 分成两部分去考虑，一部分是 $i \\leq \\sqrt{n}$，另一部分是 $i\u0026gt;\\sqrt{n}$。\n在第一部分内，$i$ 也就只有 $\\sqrt{n}$ 种取值，$\\lfloor \\frac{n}{i} \\rfloor$ 最多只有约 $\\sqrt{n}$ 种取值。\n在第二部分内，$\\lfloor \\frac{n}{i} \\rfloor$ 在 $i$ 最小时（$i=\\sqrt{n}+1$）会达到最大值，约 $\\sqrt{n}$；而上面说“$\\lfloor \\frac{n}{i} \\rfloor$ 的值随着 $i$ 的增长而非单调递减”，所以易得 $\\lfloor \\frac{n}{i} \\rfloor$ 最多也只有约 $\\sqrt{n}$ 种取值。\n$\\lfloor \\frac{n}{i} \\rfloor$ 的总取值种数最多只有第一、二部分的取值个数和，即 $2 \\times \\sqrt{n}$，证毕。\n然后，我们就考虑求区间集了，以下设 $l$ 为这个区间的左端点，$r$ 为这个区间的右端点，且 $l$ 已知。\n设 $v=\\lfloor \\frac{n}{l} \\rfloor$，其实 $r$ 就是最大的 $i$ 满足 $v=\\lfloor \\frac{n}{i} \\rfloor$，显然（条件）等价于 $i=\\lfloor \\frac{n}{v} \\rfloor$，带入 $v$ 后即可求出 $r=\\left\\lfloor \\dfrac{n}{\\lfloor \\frac{n}{l} \\rfloor} \\right\\rfloor$。\n于是乎，最上面那个问题就可以求解了，答案就是 $\\sum (r-l+1) \\times v$。\n","permalink":"https://qjwh.github.io/posts/oi/aln/divisionblock/","summary":"\u003ctext style=\"font-family:Noto Sans SC\"\u003e\r\n\u003cp\u003e感谢\u003ca href=\"https://blog.csdn.net/qq_58207591/article/details/123883428\"\u003e这篇文章\u003c/a\u003e的作者\u003c/p\u003e\n\u003cp\u003e整除分块主要解决求解 $\\sum\\limits_{i=1}^n \\lfloor \\frac{n}{i} \\rfloor$ 的值。\u003c/p\u003e\n\u003cp\u003e一看这个公式，可能毫无头绪，但画张图你就有点思路了：（$n=11$）\u003c/p\u003e\n\u003cimg src=\"https://cdn.luogu.com.cn/upload/image_hosting/5by1ehmz.png\" width=\"65%\"\u003e\r\n\u003cp\u003e（灰色线：$y=\\frac{11}{x}$，绿色点：$y=\\lfloor \\frac{11}{x} \\rfloor$，橙色线：仅为辅助）\u003c/p\u003e\n\u003cp\u003e这张图其实就是在提示我们：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e$\\lfloor \\frac{n}{i} \\rfloor$ 的值随着 $i$ 的增长而非单调递减\u003c/li\u003e\n\u003cli\u003e$\\lfloor \\frac{n}{i} \\rfloor$ 的值往往会在一段区间内相等\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e所以，我们就有一个思路了，就是求出所有值（下面的“值”都代指的是 $\\lfloor \\frac{n}{i} \\rfloor$）相等的极大区间集，然后就可以快速统计了。\u003c/p\u003e\n\u003cp\u003e有人问，这不就是个常数级别的优化吗，怎么能叫“快速”呢？其实区间个数总是 $O(\\sqrt{n})$ 级别，最多约 $2 \\times \\sqrt{n}$。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e证明：\u003c/p\u003e\n\u003cp\u003e我们把 $i$ 分成两部分去考虑，一部分是 $i \\leq \\sqrt{n}$，另一部分是 $i\u0026gt;\\sqrt{n}$。\u003c/p\u003e\n\u003cp\u003e在第一部分内，$i$ 也就只有 $\\sqrt{n}$ 种取值，$\\lfloor \\frac{n}{i} \\rfloor$ 最多只有约 $\\sqrt{n}$ 种取值。\u003c/p\u003e\n\u003cp\u003e在第二部分内，$\\lfloor \\frac{n}{i} \\rfloor$ 在 $i$ 最小时（$i=\\sqrt{n}+1$）会达到最大值，约 $\\sqrt{n}$；而上面说“$\\lfloor \\frac{n}{i} \\rfloor$ 的值随着 $i$ 的增长而非单调递减”，所以易得 $\\lfloor \\frac{n}{i} \\rfloor$ 最多也只有约 $\\sqrt{n}$ 种取值。\u003c/p\u003e\n\u003cp\u003e$\\lfloor \\frac{n}{i} \\rfloor$ 的总取值种数最多只有第一、二部分的取值个数和，即 $2 \\times \\sqrt{n}$，证毕。\u003c/p\u003e","title":"整除分块"},{"content":"\r整体二分类似于线段树上二分，在讲这个算法前，先引入几个问题。\n解决题型 整体二分一般解决的是如下的问题：\n给你一个【集合/序列/矩阵/树】，要求【静态/动态】维护所有【元素/区间/子矩阵/链/子树】中的第 $k$【可能每次给定】大元素，【可能强制在线】。\n下面是一堆例题。\n例题1 动态查询集合第k大（可离线） 题意 让你维护一个初始为空的多重集合 $s$，并支持 $q$ 次操作，操作都是下面三种之一：\n添加一个数 $x$ 到集合 $s$ 中。 在集合 $s$ 中删除一个数 $x$（保证元素存在）。 查询集合第 $k$ 大（保证第 $k$ 大存在）。 数据范围 $1 \\leq q \\leq 2 \\times 10^5$ $0 \\leq x \\leq 10^9$ 题解 维护一个权值线段树（权值线段树其实就是一个维护值域的线段树），维护一段值域里有多少个数，每次询问在线段树上二分即可。\n具体地，对于线段树上某个节点对应的区间 $[l,r]$，这个节点上的值为集合中，值在 $[l,r]$ 的数的个数有多少。\n在询问时，我们要记录当前节点编号 $x$，$x$ 维护区间 $[l,r]$，以及要查询值在 $[l,r]$ 内的所有数的第 $k$ 大。\n当递归到某个状态后，我们看这个节点的左子树 $\\text{lc}$ 内有多少个值，如果大于等于 $k$，则递归到左子树；否则递归到右子树，且 $k$ 减去(左子树内数的个数)。\n由于值域较大，权值线段树可能会爆，所以要先把所有询问离线下来，做个离散化，然后就可以把 $x$ 控制到 $q$ 级别，就不会爆了。\n修改操作就是典中典了，此处不再赘述。\n时间复杂度：$O(q \\log q)$\n例题2 动态查询集合第k大（强制在线） 题意 同上，不过加了个强制在线的限制。\n数据范围 同上。\n题解 此时就不能离线，然后离散化了。\n此时有四种做法：\n动态开点线段树，时间复杂度：$O(q \\log^2 q)$ PBDS（笔记），时间复杂度：$O(q \\log q)$ 平衡树，时间复杂度：$O(q \\log q)$ 对顶堆，时间复杂度：$O(q \\log q)$ 有人一看“对顶堆”就感觉很难，但其实很好理解。\n（注：使用该做法的前提是 $k$ 是一个定值）\n我们维护一个小根堆 $h_1$ 和一个大根堆 $h_2$。\n$h_1$ 里维护的是前 $k$ 大，$h_2$ 里则是维护的其他值。\n由于涉及删除（查找），所以要用set，而不是priority_queue。\n每次添加操作，先加入到 $h_1$ 里，如果说 $h_1$ 的大小大于 $k$（显然只可能是 $k+1$），那么弹出 $h_1$ 内的最小元素，并加入到 $h_2$。\n每次删除操作，如果 $h_2$ 里有删除的元素，直接在 $h_2$ 里删；否则在 $h_1$ 里删，如果说 $h_1$ 的大小小于 $k$（显然只可能是 $k-1$），那么弹出 $h_2$ 内的最大元素，并加入到 $h_1$。\n每次查询操作，直接弹出 $h_1$ 内的最小值即可。\n上面做法里只涉及几种操作：\n添加元素（multiset.insert(LL)，复杂度为 $O(\\log n)$） 找到元素出现位置/判断元素是否存在（multiset.find(LL)，复杂度为 $O(\\log n)$） 注意，这里不能使用multiset.count(LL)，因为这个函数的复杂度其实是 $O(\\log n+\\text{cnt})$，其中 $\\text{cnt}$ 为返回值。\n而这样的复杂度显然会被特殊数据卡到 $\\text{cnt}=n$，也就炸了。\n删除元素（multiset.erase(multiset::iterator)，复杂度均摊常数） 有人问为啥不能直接用multiset.erase(LL)？有两个原因：\nmultiset.erase(LL)会直接删除这个multiset中所有与传参相同的位置，但题目说的是只删除一个，所以会WA。 直接用multiset.erase(multiset::iterator)复杂度是均摊常数的（如果要加上multiset.find(LL)的复杂度，也只是 $O(\\log n)$ 而已），但multiset.erase(LL)的复杂度是 $O(\\log n+\\text{cnt})$，会TLE。 所以总复杂度为 $O(q \\log q)$。\n例题3 静态查询区间第k小（可离线） 题意 给你一个长度为 $n$ 的数组 $a$，你要回答 $q$ 次询问，每次询问会给定 $l$、$r$、$k$，问你 $a_l \\sim a_r$ 内第 $k$ 小的数是多少。\n数据范围 $1 \\leq n \\leq 2 \\times 10^5$ $1 \\leq q \\leq 2 \\times 10^5$ $0 \\leq a_i \\leq n$ 题解 一看这道题，再看例题1的解法，有些人就想到了主席树（可持久化线段树），然后直接开干，$O((n+q) \\log n)$ 的复杂度，稳过。\n上面这种做法比下面要讲的整体二分还要少一个 $\\log$，不过缺点是，这个代码忒长了。\n下面讲一下整体二分。\n概览 整体二分，顾名思义就是「对整体做线段树上二分」，而具体怎么个思路呢？见下。\n整体二分本质还是一个分治。\n设计分治函数 看到「（权值）线段树上二分」，那么分治里必须有值域。\n再看例题1的做法，在例题1里，整体来看，每当递归到一个节点，我们就是把问题分为了两类：一类去了左儿子，一类则是去了右儿子。\n这里也一样，于是我们就得到了一个分治函数：$\\text{solve}(l,r,q_l,q_r)$，代表已经确定了第 $q_l$ 个询问到第 $q_r$ 个询问（我们已经把所有询问都存到了一个数组，且这个数组可能会随时变化）的答案在 $[l,r]$ 内。\n就像本题，初始的状态就是 $\\text{solve}(1,n,1,q)$。\n询问分类 接下来考虑把这些询问分成两类：一类答案在 $[l,\\text{mid}]$ 内，另一类答案在 $[\\text{mid}+1,r]$ 内，其中 $\\text{mid}$ 为区间 $[l,r]$ 的中点下标。\n对于一个询问 $(c_l,c_r,c_k)$，分类看的其实就是 $a_{c_l} \\sim a_{c_r}$ 内有多少值在 $[l,\\text{mid}]$ 内的下标，是否大于等于 $c_k$。\n上面说的值域 $[l,\\text{mid}]$ 是固定的，所以我们考虑维护一个树状数组。\n在初始时，对于所有值在 $[l,\\text{mid}]$ 内的下标 $x$ 都加 $1$。\n有人感觉描述有点模糊，此处用数学方式表达一下。\n我们把所有满足 $a_x \\in [l,\\text{mid}]$ 的 $x$（$1 \\leq x \\leq n$）全部加入一个集合 $s$，然后对于 $s$ 中的所有值 $v$，在树状数组的 $v$ 下标上加 $1$（add(v,1)）。\n但直接实现会TLE，我们考虑在初始时，就记录一个vector数组 $\\text{pos}$，$\\text{pos}_i$ 为一个vector，存储满足 $a_x=i$ 的 $x$ 集合。\n然后，直接遍历 $i \\in [l,\\text{mid}]$，并对于每个 $i$，循环所有 $x \\in \\text{pos}_i$，并在树状数组的 $x$ 位置上加 $1$ 即可。\n所以就可以很快分类了，我们直接看树状数组的下标 $c_l \\sim c_r$ 上的值的和 $\\text{sum}$，如果 $\\text{sum} \\geq c_k$，则该询问 $(c_l,c_r,c_k)$ 分到“左子树类”，否则分到“右子树类”。\n由于要分类，所以需要记录一个临时数组防止WA。\n到最后，我们就讲这个问题变成了两个子问题：一个 $\\text{solve}(l,\\text{mid},左子树类下标区间)$，另一个 $\\text{solve}(\\text{mid}+1,r,右子树类下标区间)$。\n边界情况 最后是一些边界。\n如果我们发现 $q_l\u0026gt;q_r$，那么就说明考虑范围为空，return。\n如果 $l=r$，就说明询问 $q_l \\sim q_r$ 的答案唯一，都是 $l$，直接赋值即可，return。\n时间复杂度：$O((n+q) \\log^2 n)$\n代码 const LL N = 2e5 + 10, Q = 2e5 + 10; LL n, qc; LL a[N]; LL l, r, k; bs\u0026lt;LL\u0026gt; pos[N]; struct Query{ LL l, r, k, id; }; Query q[Q]; Query b[Q]; #define lowbit(x) ((x) \u0026amp; (-(x))) LL c[N]; void add(LL x, LL v){ for(LL i = x;i \u0026lt;= n;i += lowbit(i)) c[i] += v; } LL query(LL x){ LL ret = 0; for(LL i = x;i;i -= lowbit(i)) ret += c[i]; return ret; } LL ans[Q]; void work(LL l, LL r, LL ql, LL qr){ if(l \u0026gt; r || ql \u0026gt; qr) return; if(l == r){ rep(i, ql, qr) ans[q[i].id] = l; return; } LL mid = l + (r - l) / 2; rep(i, l, mid) for(auto x : pos[i]) add(x, 1); LL pa = ql, pb = qr; rep(i, ql, qr){ LL l = q[i].l, r = q[i].r, k = q[i].k; LL s = query(r) - query(l - 1); if(s \u0026gt;= k) b[pa++] = q[i]; else q[i].k -= s, b[pb--] = q[i]; } rep(i, ql, qr) q[i] = b[i]; rep(i, l, mid) for(auto x : pos[i]) add(x, -1); work(l, mid, ql, pa - 1), work(mid + 1, r, pb + 1, qr); } void solve(){ rd(n), rd(qc); rep(i, 1, n) rd(a[i]), pos[a[i]] += i; rep(i, 1, qc) rd(l), rd(r), rd(k), q[i] = {l, r, k, i}; work(1, n, 1, qc); rep(i, 1, qc) printf(\u0026#34;%lld\\n\u0026#34;, ans[i]); } 例题4 静态查询区间第k小（强制在线） 题意 同上，不过加了个强制在线的限制。\n数据范围 同上。\n题解 本题可用树状数组套主席树以 $O((n+q) \\log^2 n)$ 的复杂度解决。\n例题5 动态查询区间第k小（可离线） 题意 给你一个长度为 $n$ 的数组 $a$，你要处理 $q$ 次操作，每次操作分两种：\n操作：给定 $x$、$v$，将 $a_x$ 的值更改为 $v$。 询问：给定 $l$、$r$、$k$，问你 $a_l \\sim a_r$ 内第 $k$ 小的数是多少。 数据范围 $1 \\leq n \\leq 2 \\times 10^5$ $1 \\leq q \\leq 2 \\times 10^5$ $0 \\leq a_i \\leq 10^9$ 题解 一看这道题，再看例题1的解法，有些人就想到了树状数组套主席树，然后直接开干，$O((n+q) \\log^2 n)$ 的复杂度，稳过。\n上面这种做法比下面要讲的带修整体二分复杂度一样，不过缺点是，这个代码忒长了。\n下面讲一下带修整体二分。\n概览 带修整体二分其实就是「带修改的整体二分」。\n带修整体二分和普通整体二分代码差别很大，但思想一致。\n注意：和CDQ分治一样，$\\text{solve}(l,r,q_l,q_r)$ 代表的是，只考虑 $q_l \\sim q_r$ 内的修改，去更新 $q_l \\sim q_r$ 内的查询。\n变化修改操作 看见这个修改操作，也是最难搞的一个操作。\n但修改操作本身难搞，并不代表转化后难搞。\n我们把一次修改操作 $(x,v)$ 变化成两部分：\n第一步：$a_x$ 减去 $a_x$ 第二步：$a_x$ 加上 $v$ 这样变化后，我们就可以继续设计新的分治思路了。\n变化分治函数 还是一样的思路，我们要把第 $q_l$ 到第 $q_r$ 个询问分类。\n但这里带上了修改操作，不太好处理。\n但也不是不能处理，我们直接去遍历 $i=q_l \\sim q_r$：\n如果说第 $i$ 个操作是修改，我们假设是 $a_x$ 加上 $v \\times \\text{mul}$（$\\text{mul} \\in { -1,1 }$）的操作： 那么，由于 $v$ 不是修改前 $a_x$ 的值，就是修改后 $a_x$ 的值，所以通过 $v$ 即可得到修改前/后的值。 所以： 如果我们发现 $v \\leq \\text{mid}$，那么，就需要在树状数组上做修改：在位置 $x$ 上加上值 $\\text{mul}$，很容易理解，此处略。 同时，即使当前操作是修改，也要加入到第一类操作中。 否则，加入到第二类操作中，而不改变树状数组。 如果第 $i$ 个操作是询问 $(l,r,k)$： 那么我们找到树状数组第 $l$ 到 $r$ 个位置上数的和 $\\text{cnt}$。 然后就是一样的处理了： 如果 $\\text{cnt} \\geq k$，则加入到第一类操作中。 否则，将 $k$ 减去 $\\text{cnt}$ 并加入到第二类操作中。 （很好理解，此处略）\n时间复杂度：$O((n+q) \\log^2 n)$\n代码 const LL N = 1e5 + 10, Q = 3e5 + 10; LL n, qc; LL a[N]; char opt[2]; LL x, v; LL l, r, k; LL ma; struct Query{ //opt=1：修改操作，a[x]+=v*mul //opt=2：查询操作，查询a[l]~a[r]内的第k大，并将答案存入ans[qid] LL opt; LL x, v, mul; LL l, r, k; LL qid; }; Query q[Q]; LL qi; Query b[Q]; #define lowbit(x) ((x) \u0026amp; (-(x))) LL c[N]; void add(LL x, LL v){ for(LL i = x;i \u0026lt;= n;i += lowbit(i)) c[i] += v; } LL query(LL x){ LL ret = 0; for(LL i = x;i;i -= lowbit(i)) ret += c[i]; return ret; } LL ans[Q]; void work(LL l, LL r, LL ql, LL qr){ if(l \u0026gt; r || ql \u0026gt; qr) return; if(l == r){ rep(i, ql, qr) if(q[i].opt == 2) ans[q[i].qid] = l; return; } LL mid = l + (r - l) / 2; LL pa = ql, pb = qr; rep(i, ql, qr) if(q[i].opt == 1){ if(q[i].v \u0026lt;= mid) add(q[i].x, q[i].mul), b[pa++] = q[i]; else b[pb--] = q[i]; }else{ LL cnt = query(q[i].r) - query(q[i].l - 1); if(cnt \u0026gt;= q[i].k) b[pa++] = q[i]; else q[i].k -= cnt, b[pb--] = q[i]; } rep(i, ql, qr) if(q[i].opt == 1 \u0026amp;\u0026amp; q[i].v \u0026lt;= mid) add(q[i].x, -q[i].mul); rep(i, ql, qr) q[i] = b[i]; //q[pb+1]~q[qr]在上面是倒序赋值的，所以此处要把q[pb+1]~q[qr]翻转一下 reverse(q + pb + 1, q + qr + 1); work(l, mid, ql, pa - 1), work(mid + 1, r, pb + 1, qr); } void solve(){ rd(n), rd(qc); rep(i, 1, n){ rd(a[i]); //初始值处理 q[++qi] = {1, i, a[i], 1}; ma = max(ma, a[i]); } LL qryc = 0; rep(i, 1, qc){ scanf(\u0026#34;%s\u0026#34;, opt); if((*opt) == \u0026#39;C\u0026#39;){ rd(x), rd(v); q[++qi] = {1, x, a[x], -1}; q[++qi] = {1, x, v, 1}; a[x] = v; //最大值更新要带上修改操作 ma = max(ma, v); }else if((*opt) == \u0026#39;Q\u0026#39;){ rd(l), rd(r), rd(k); q[++qi] = {2, 0, 0, 0, l, r, k, ++qryc}; } } work(0, ma, 1, qi); rep(i, 1, qryc) printf(\u0026#34;%lld\\n\u0026#34;, ans[i]); } 例题6 动态查询区间第k小（强制在线） 题意 同上，不过加了个强制在线的限制。\n数据范围 同上。\n题解 本题可用树状数组套主席树以 $O((n+q) \\log^2 n)$ 的复杂度解决。\n例题7 静态查询子矩阵第k小（可离线） 题意 给你一个大小为 $n \\times m$ 的矩阵 $a$，你要处理 $q$ 次询问，每次询问给定 $x_1$、$y_1$、$x_2$、$y_2$、$k$，问你以 $(x_1,y_1)$ 为左上角、以 $(x_2,y_2)$ 为右下角的子矩阵的第 $k$ 小的数是多少。\n数据范围 $1 \\leq n,m \\leq 2 \\times 10^3$ $1 \\leq q \\leq 2 \\times 10^5$ $0 \\leq a_i \\leq 10^9$ 题解 这题和例题3几乎没有什么区别，只不过平面维度变成了二维。\n所以，我们就需要用到二维树状数组。\n这里简单说一下原理。\n一维树状数组里，$c_x$ 维护的是区间 $(x-\\text{lowbit}(x),x]$ 的某个值。\n同理，在二维树状数组里，$c_{x,y}$ 就代表X坐标在 $(x-\\text{lowbit}(x),x]$ 内、Y坐标在 $(y-\\text{lowbit}(y),y]$ 内的这个子矩阵的某个值。\n所以，其实add和query函数也差不了多少，详情见代码，很好理解。\n时间复杂度：$O((n+q) \\log^3 n)$\n代码 const LL N = 2010, A = 4e6 + 10, Q = 6e4 + 10; LL n, qc; LL a[N][N]; LL xa, ya, xb, yb, k; bs\u0026lt;LL\u0026gt; alls; #define find(x) (lower_bound(all(alls), x) - alls.begin() + 1) LL nn; vector\u0026lt;PII\u0026gt; pos[A]; struct Query{ LL xa, ya, xb, yb, k, id; }; Query q[Q]; Query b[Q]; #define lowbit(x) ((x) \u0026amp; (-(x))) LL c[N][N]; void add(LL x, LL y, LL v){ for(LL i = x;i \u0026lt;= n;i += lowbit(i)) for(LL j = y;j \u0026lt;= n;j += lowbit(j)) c[i][j] += v; } LL query(LL x, LL y){ LL ret = 0; for(LL i = x;i;i -= lowbit(i)) for(LL j = y;j;j -= lowbit(j)) ret += c[i][j]; return ret; } LL query_zi(LL xa, LL ya, LL xb, LL yb){ return query(xb, yb) - query(xa - 1, yb) - query(xb, ya - 1) + query(xa - 1, ya - 1); } LL ans[Q]; void work(LL l, LL r, LL ql, LL qr){ if(l \u0026gt; r || ql \u0026gt; qr) return; if(l == r){ rep(i, ql, qr) ans[q[i].id] = l; return; } LL mid = l + (r - l) / 2; rep(i, l, mid) for(auto it : pos[i]) add(it.fir, it.sec, 1); LL pa = ql, pb = qr; rep(i, ql, qr){ LL xa = q[i].xa, ya = q[i].ya, xb = q[i].xb, yb = q[i].yb, k = q[i].k; LL s = query_zi(xa, ya, xb, yb); if(s \u0026gt;= k) b[pa++] = q[i]; else q[i].k -= s, b[pb--] = q[i]; } rep(i, ql, qr) q[i] = b[i]; rep(i, l, mid) for(auto it : pos[i]) add(it.fir, it.sec, -1); work(l, mid, ql, pa - 1), work(mid + 1, r, pb + 1, qr); } void solve(){ rd(n), rd(qc); rep(i, 1, n) rep(j, 1, n) rd(a[i][j]), alls += a[i][j]; sort(all(alls)); alls.erase(unique(all(alls)), alls.end()); nn = alls.size(); rep(i, 1, n) rep(j, 1, n) a[i][j] = find(a[i][j]), pos[a[i][j]].pb({i, j}); rep(i, 1, qc) rd(xa), rd(ya), rd(xb), rd(yb), rd(k), q[i] = {xa, ya, xb, yb, k, i}; work(1, nn, 1, qc); rep(i, 1, qc) printf(\u0026#34;%lld\\n\u0026#34;, alls[ans[i] - 1]); } 例题8 动态查询子矩阵第k小（可离线） 题意 给你一个大小为 $n \\times m$ 的矩阵 $a$，你要处理 $q$ 次操作，每次操作分两种：\n操作：给定 $x$、$y$、$v$，将 $a_{x,y}$ 的值更改为 $v$。 询问：给定 $x_1$、$y_1$、$x_2$、$y_2$、$k$，问你以 $(x_1,y_1)$ 为左上角、以 $(x_2,y_2)$ 为右下角的子矩阵的第 $k$ 小的数是多少。 数据范围 $1 \\leq n,m \\leq 2 \\times 10^3$ $1 \\leq q \\leq 2 \\times 10^5$ $0 \\leq a_i \\leq 10^9$ 题解 这题和例题4很像，改成二维和例题7是一样的方式，此处略。\n时间复杂度：$O((n+q) \\log^3 n)$\n例题9 动态查询区间第k小（强制在线） 题意 同上，不过加了个强制在线的限制。\n数据范围 同上。\n题解 本题可用权值线段树套KD Tree解决。\n例题10 动态查询树上第k小（可离线） 题意 给你一颗 $n$ 个节点的树，你要处理 $q$ 次操作，每次操作分两种：\n操作：给定 $x$、$v$，将 $x$ 点的权值更改为 $v$。 询问：给你 $x$，问你 $x$ 及其子树内权值第 $k$ 小的节点的权值是多少。 数据范围 $1 \\leq n \\leq 2 \\times 10^5$ $1 \\leq q \\leq 2 \\times 10^5$ $0 \\leq a_i \\leq 10^9$ 题解 根据给这个笔记写的经验，我们可以直接求出每个节点的欧拉序，然后把节点编号直接重新赋值为其欧拉序。\n于是乎，对单点的权值修改就变成了序列单点修改，对子树的权值第 $k$ 小查询就变成了序列区间求第 $k$ 小。\n于是就转化为了例题5。\n时间复杂度：$O((n+q) \\log^2 n)$\n例题11 动态查询树上第k小（强制在线） 题意 同上，不过加了个强制在线的限制。\n数据范围 同上。\n题解 本题可用树状数组套主席树解决。\n总结 题型1 普通整体二分 上面说的，其实都是整体二分优化线段树上二分过程的例题。\n实际上，整体二分可以解决所有形如一下的问题：\n给你一些信息，让你维护 $q$ 次询问。\n但这 $q$ 次询问要满足一些要求，查询可以通过一次二分/线段树上二分来解决，但直接每次二分会TLE。\n这种情况下，我们就可以把所有询问离线下来，然后定义如上的分治函数。\n前面对边界的处理一样，然后先跑一遍调用二分 $\\text{check}(\\text{mid})$ 函数时做的修改操作。\n然后，对所有 $[q_l,q_r]$ 内的询问，都跑一遍调用二分 $\\text{check}(\\text{mid})$ 函数时做的判断过程。\n利用上面的结果，把这以内的所有询问分成两部分，一部分是答案在 $[l,\\text{mid}]$ 内的询问，另一部分则是答案在 $[\\text{mid}+1,r]$ 内的询问。\n说完上面部分，你应该也想到了，其实整体二分是有模板的，所有题的代码都差不多，只不过要在那些差别部分多加思考。\n题型2 带修整体二分 那如果说题目里存在修改操作呢？其实也一样，只不过加一个对修改的处理即可。\n带修整体二分比普通整体二分肯定要复杂一些，我们要在这些复杂的地方多加思考才能搞定题目。\n","permalink":"https://qjwh.github.io/posts/oi/aln/exbinarysearch/","summary":"\u003ctext style=\"font-family:Noto Sans SC\"\u003e\r\n\u003cp\u003e整体二分类似于线段树上二分，在讲这个算法前，先引入几个问题。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-解决题型\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 解决题型\u003c/h2\u003e\n\u003cp\u003e整体二分一般解决的是如下的问题：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e给你一个【集合/序列/矩阵/树】，要求【静态/动态】维护所有【元素/区间/子矩阵/链/子树】中的第 $k$【可能每次给定】大元素，【可能强制在线】。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e下面是一堆例题。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-例题1-动态查询集合第k大可离线\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 例题1 动态查询集合第k大（可离线）\u003c/h2\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-题意\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 题意\u003c/h3\u003e\n\u003cp\u003e让你维护一个初始为空的多重集合 $s$，并支持 $q$ 次操作，操作都是下面三种之一：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e添加一个数 $x$ 到集合 $s$ 中。\u003c/li\u003e\n\u003cli\u003e在集合 $s$ 中删除一个数 $x$（保证元素存在）。\u003c/li\u003e\n\u003cli\u003e查询集合第 $k$ 大（保证第 $k$ 大存在）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-数据范围\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 数据范围\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e$1 \\leq q \\leq 2 \\times 10^5$\u003c/li\u003e\n\u003cli\u003e$0 \\leq x \\leq 10^9$\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-题解\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 题解\u003c/h3\u003e\n\u003cp\u003e维护一个权值线段树（权值线段树其实就是一个维护值域的线段树），维护一段值域里有多少个数，每次询问在线段树上二分即可。\u003c/p\u003e\n\u003cp\u003e具体地，对于线段树上某个节点对应的区间 $[l,r]$，这个节点上的值为集合中，值在 $[l,r]$ 的数的个数有多少。\u003c/p\u003e\n\u003cp\u003e在询问时，我们要记录当前节点编号 $x$，$x$ 维护区间 $[l,r]$，以及要查询值在 $[l,r]$ 内的所有数的第 $k$ 大。\u003c/p\u003e\n\u003cp\u003e当递归到某个状态后，我们看这个节点的左子树 $\\text{lc}$ 内有多少个值，如果大于等于 $k$，则递归到左子树；否则递归到右子树，且 $k$ 减去(左子树内数的个数)。\u003c/p\u003e\n\u003cp\u003e由于值域较大，权值线段树可能会爆，所以要先把所有询问离线下来，做个离散化，然后就可以把 $x$ 控制到 $q$ 级别，就不会爆了。\u003c/p\u003e","title":"整体二分"},{"content":"中国剩余定理，Chinese Remainder Theorem，又称CRT，我们接下来就讲一下这个算法的原理。\n要说原理，就得从古代说起。\n（你到底是在讲编程课还是在讲历史课）\n（真的是在将编程课）\n在古代，有一个问题，叫做“物不知数问题”，原文是这样的：\n有物不知其数 三三数之剩二 五五数之剩三 七七数之剩二 问物几何？ 这个问题翻译过来就是问以下方程的所有正整数解：\n$ \\begin{cases} x \\equiv 2 \\pmod{3} \\ x \\equiv 3 \\pmod{5} \\ x \\equiv 2 \\pmod{7} \\end{cases} $\n这个问题在后来有一个解了，解出来这个问题的人，编了一首诗，叫做“孙子歌诀”，原文：\n三人同行七十稀 五树梅花廿一支 七子团圆正半月 除百零五便得知 这个解翻译过来就是说，若设 $r_3$ 为方程中 $x$ 模 $3$ 的余数，$r_5$、$r_7$ 同理，那么所有解 $x$ 一定满足：\n$x \\equiv r_3 \\times 70+r_5 \\times 21+r_7 \\times 15 \\pmod{105}$\n其中 $105$ 的实际来源是上面三个方程的模数的 $\\text{lcm}$，即 $\\text{lcm}(3,5,7)=3 \\times 5 \\times 7=105$。\n关于 $70$、$21$、$15$ 的来源下面再说，我们先证明一下这个解是正确的。\n由于 $105$ 是三个模数的 $\\text{lcm}$，所以说如果 $x$ 是满足条件的，$x-105$、$x+105$ 都是满足条件的（此处暂时忽略“正整数解”的限制），显然。\n所以我们就只用证明解 $x=\\color{orangered} r_3 \\times 70 \\color{default}+\\color{orange} r_5 \\times 21 \\color{default}+\\color{royalblue} r_7 \\times 15$ 合法即可。\n我们把这个解带入到第一个方程式 $x \\equiv r_3 \\pmod{3}$ 里：\n我们把方程式换种写法，变成 $x \\bmod 3=r_3$。\n那么，我们再把 $x$ 的解带入进去，变成 $(\\color{orangered} r_3 \\times 70 \\color{default}+\\color{orange} r_5 \\times 21 \\color{default}+\\color{royalblue} r_7 \\times 15 \\color{default}) \\bmod 3=r_3$。\n可以发现，其实黄色项（中间）和蓝色项（最后）是可以被 $3$ 整除的，所以可以直接删掉，只保留橙色项（最前），变成 $\\color{orangered} r_3 \\times 70 \\color{default} \\bmod 3=r_3$\n由于 $70 \\bmod 3=1$，所以上述方程一定成立，显然。\n带入到其他方程式也是差不多的证法，此处略。\n有了上面那个具体的例子，我们就可以来解决抽象的例子了：\n$ \\begin{cases} x \\equiv a_1 \\pmod{m_1} \\ x \\equiv a_2 \\pmod{m_2} \\ x \\equiv a_3 \\pmod{m_3} \\ \\dots \\ x \\equiv a_k \\pmod{m_k} \\end{cases} $\n（说一下，CRT只能解决那些 $m_i$ 和 $m_j$ 两两互质的上述类型同余方程）\n有了上面的启发，我们可以设 $x$ 的解为 $(a_1 \\times c_1+a_2 \\times c_2+a_3 \\times c_3+\\dots+a_k \\times c_k) \\bmod (\\prod m_i)$。\n接下来我们考虑构造 $c$ 数组。\n有了上述证明的启发，我们可以列出一个 $c$ 数组要满足的条件列表：\n$ \\begin{cases} c_1 \\bmod m_1=1 \u0026amp; c_1 \\bmod m_2=0 \u0026amp; c_1 \\bmod m_3=0 \u0026amp; \\dots \u0026amp; c_1 \\bmod m_k=0 \\ c_2 \\bmod m_1=0 \u0026amp; c_2 \\bmod m_2=1 \u0026amp; c_2 \\bmod m_3=0 \u0026amp; \\dots \u0026amp; c_2 \\bmod m_k=0 \\ c_3 \\bmod m_1=0 \u0026amp; c_3 \\bmod m_2=0 \u0026amp; c_3 \\bmod m_3=1 \u0026amp; \\dots \u0026amp; c_3 \\bmod m_k=0 \\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\ c_k \\bmod m_1=0 \u0026amp; c_k \\bmod m_2=0 \u0026amp; c_k \\bmod m_3=0 \u0026amp; \\dots \u0026amp; c_k \\bmod m_k=1 \\end{cases} $\n我们先考虑构造 $c_1$（以 $c_1$ 为例）。\n我们先满足第一行的第二到最后一列的所有条件，即 $c_1=\\prod\\limits_{i=2}^n m_i$，且 $c_1$ 在满足第一行第一列中的条件时，只能变成初始值的倍数。\n我们设 $c_1$ 最后要变成初始值的 $d_1$ 倍，那么（$d_1$）就需要满足 $c_1 \\times d_1 \\bmod m_1=1$，由于 $m_i$、$m_j$ 两两互质，所以 $c_1$、$m_1$ 也是互质的，进而就可以构造 $d_1$ 为 $c_1$ 在模 $m_1$ 意义下的逆元即可。\n注意到 $m_i$ 不一定都是质数，所以求逆元需要用exgcd（推荐）或者欧拉定理（不推荐）。\n总结一下，如果我们设 $M=\\prod m_i$，$M_i=M \\div m_i$，$t_i$ 为 $M_i$ 在模 $m_i$ 意义下的逆元，那么最小正整数解就是 $(\\sum a_iM_it_i) \\bmod M$，通解 $x$ 满足 $x \\equiv \\sum a_iM_it_i \\pmod{M}$。\n注意到上面说“要保证 $m_i$ 和 $m_j$ 两两互质”，但如果不满足呢？就需要用到exCRT。\nexCRT的原理与CRT完全相反，CRT是通过预处理数组一下子求出解，exCRT则是一个一个合并同余方程。\n我们设当前要合并：\n$ \\begin{cases} x \\equiv a_1 \\pmod{m_1} \\ x \\equiv a_2 \\pmod{m_2} \\end{cases} $\n那么考虑一下合并之后这个方程组会变成啥样。\n遇到取模就要想到拆开，我们设 $k_1$ 和 $k_2$，然后把上面两个方程变成：\n$ \\begin{cases} x=k_1m_1+a_1 \\ x=k_2m_2+a_2 \\end{cases} $\n所以还可以得到等式：\n$k_1m_1+a_1=k_2m_2+a_2$\n移项：\n$k_1m_1-k_2m_2=a_2-a_1$\n设 $k_2\u0026rsquo;=-k_2$，那么就变成了：\n$k_1m_1+k_2\u0026rsquo;m_2=a_2-a_1$\n这个方程可以用exgcd判断是否有解并求出一组解 $(k_1,k_2)$，所以就合并为了：\n$x \\equiv k_1m_1+a_1 \\pmod{M}$\n（其中 $M=\\text{lcm}(m_1,m_2)$）\n用上述合并方法，可以直接把多个方程合并为一个，就可以求出解了。\n","permalink":"https://qjwh.github.io/posts/oi/aln/crt/","summary":"\u003cp\u003e中国剩余定理，Chinese Remainder Theorem，又称CRT，我们接下来就讲一下这个算法的原理。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e要说原理，就得从古代说起。\u003c/p\u003e\n\u003cp\u003e\u003cdel\u003e（你到底是在讲编程课还是在讲历史课）\u003c/del\u003e\u003c/p\u003e\n\u003cp\u003e\u003cdel\u003e（真的是在将编程课）\u003c/del\u003e\u003c/p\u003e\n\u003cp\u003e在古代，有一个问题，叫做“物不知数问题”，原文是这样的：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e有物不知其数\u003c/li\u003e\n\u003cli\u003e三三数之剩二\u003c/li\u003e\n\u003cli\u003e五五数之剩三\u003c/li\u003e\n\u003cli\u003e七七数之剩二\u003c/li\u003e\n\u003cli\u003e问物几何？\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这个问题翻译过来就是问以下方程的所有正整数解：\u003c/p\u003e\n\u003cp\u003e$\n\\begin{cases}\nx \\equiv 2 \\pmod{3} \\\nx \\equiv 3 \\pmod{5} \\\nx \\equiv 2 \\pmod{7}\n\\end{cases}\n$\u003c/p\u003e\n\u003cp\u003e这个问题在后来有一个解了，解出来这个问题的人，编了一首诗，叫做“孙子歌诀”，原文：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e三人同行七十稀\u003c/li\u003e\n\u003cli\u003e五树梅花廿一支\u003c/li\u003e\n\u003cli\u003e七子团圆正半月\u003c/li\u003e\n\u003cli\u003e除百零五便得知\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这个解翻译过来就是说，若设 $r_3$ 为方程中 $x$ 模 $3$ 的余数，$r_5$、$r_7$ 同理，那么所有解 $x$ 一定满足：\u003c/p\u003e\n\u003cp\u003e$x \\equiv r_3 \\times 70+r_5 \\times 21+r_7 \\times 15 \\pmod{105}$\u003c/p\u003e\n\u003cp\u003e其中 $105$ 的实际来源是上面三个方程的模数的 $\\text{lcm}$，即 $\\text{lcm}(3,5,7)=3 \\times 5 \\times 7=105$。\u003c/p\u003e\n\u003cp\u003e关于 $70$、$21$、$15$ 的来源下面再说，我们先证明一下这个解是正确的。\u003c/p\u003e\n\u003cp\u003e由于 $105$ 是三个模数的 $\\text{lcm}$，所以说如果 $x$ 是满足条件的，$x-105$、$x+105$ 都是满足条件的（此处暂时忽略“正整数解”的限制），显然。\u003c/p\u003e","title":"中国剩余定理"},{"content":"\r有人问，组合数学不是就一些简单的公式吗？不是的，其实组合数学是数学中的一个非常庞大的分支，接下来就举一些例子。（更新中）\n本文主要讲各种数据范围下，求组合数的方式；以及球盒模型各种情况下的公式；最后是一些球盒模型的扩展情况。\n转到：球盒模型公式\n转到：球盒模型扩展公式\n（下面部分标题里的LaTeX公式更新后炸了，就凑合着看吧）\n求组合数 以下所有范围都可以当成是以下题目的某个Subtask：\n给你 $p$，代表模数。\n之后会给你一个 $q$，代表询问次数。\n每次询问给定 $n$ 和 $m$，问 $C_n^m \\bmod p$ 的值。\n下面不给定 $q$ 的范围，因为不重要。\n以下全部默认 $n \\geq m$。\n范围1：$n,m \\leq 2000,p \\leq 10^9+7$ 先递推预处理，然后直接回答询问即可。\n递推式：$C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$。\n预处理复杂度：$O(n^2)$ 查询复杂度：$O(1)$ 范围2：$n,m \\leq 10^6,p \\leq 10^9+7,p\\text{ is prime}$ 1 先预处理阶乘，然后直接回答询问即可。\n回答询问式：$C_n^m=\\dfrac{n!}{m!(n-m)!}$。\n为了节省时间复杂度，此处还可以预处理一下阶乘的逆元。\n2 预处理复杂度：$O(n)$ 查询复杂度：$O(1)$ 范围3：$n,m \\leq 10^6,p \\leq 10^9+7$ 1 可以发现，范围2与范围3唯一的不同就是，范围3把质数的条件去掉了。\n而把质数的条件后，就没法求逆元了，因为逆元可能不存在。\n所以我们考虑换做法。\n2 我们考虑把模数做个质因数分解，变成 ${p_1}^{a_1} \\times {p_2}^{a_2} \\times {p_3}^{a_3} \\times \\dots \\times {p_k}^{a_k}$。\n然后，我们求出 $c$ 数组，$c_i=C_n^m \\bmod {p_i}^{a_i}$，然后就可以列出以下方程：\n$ \\begin{cases} x \\equiv c_1 \\pmod{{p_1}^{a_1}} \\ x \\equiv c_2 \\pmod{{p_2}^{a_2}} \\ x \\equiv c_3 \\pmod{{p_3}^{a_3}} \\ \\dots \\ x \\equiv c_k \\pmod{{p_k}^{a_k}} \\end{cases} $\n用中国剩余定理即可求出上述方程的最小正整数解 $x$，输出这个 $x$ 即可。\n3 接下来考虑一下如何求 $c$ 数组。\n我们设当前要求 $C_n^m \\bmod q^a$。\n那么，我们把 $C_n^m$ 展开为阶乘形式，变成 $\\dfrac{n!}{m!(n-m)!}$。\n然后，我们想，$C_n^m \\bmod p$ 不能直接求的原因其实就是因为上述式子可能不会与 $p$ 互质。\n进而，$C_n^m \\bmod q^a$ 不能直接求的原因也是因为上述式子可能不会与 $q^a$（其实也是 $q$）互质。\n所以，我们就把上述式子里（那个分数的分子和分母内）所有的 $q$ 都去掉，变成 $\\Large \\dfrac{\\frac{n!}{q^x}}{\\frac{m!}{q^y}\\frac{(n-m)!}{q^z}} \\times q^{x-y-z}$，其中 $x$、$y$、$z$ 就是 $n!$、$m!$、$(n-m)!$ 中含有的 $q$ 质因子数量。\n这个式子中的 $\\dfrac{n!}{q^x}$ 是可以直接预处理的，此处略。\n由于分母中的两项都没有 $q$ 质因子，所以就有在模 $q^a$ 意义下的逆元，前项的分数可求；后项就是一个快速幂，可求。\n4 这里再说最后一点细节，就是我们设 $f_n=\\dfrac{n!}{q^x}$，那么 $f_i=f_{i-1} \\times i \\div q^c$（虽说这个式子中有除号，但显然不需要逆元），其中 $c$ 是 $i$ 含有的 $q$ 质因子个数。\n这个公式中存在一个 $i \\div q^c$，这可以暴力计算，但需要多带一个 $\\log$。\n但这其实不用带这个 $\\log$，我们可以先处理出来一个 $g$ 数组，$g_i=i \\div q^c$，这个 $g$ 数组很好递推：\n$i \\bmod q=0$：$g_i=g_{i \\div q}$ $i \\bmod q \\not= 0$：$g_i=i$ 有了这个 $g$ 数组，$f$ 数组的递推方程就变成了 $f_i=f_{i-1} \\times g_i$，递推复杂度也变成了 $O(n)$。\n5 预处理复杂度：$O(\\sqrt{n}+n \\log p)$，其中，$\\sqrt{p}$ 为求出 $p$ 的唯一分解复杂度，$\\log p$ 为枚举 $p$ 的所有唯一分解项复杂度，以下所有复杂度内的 $\\sqrt{p}$、$\\log p$ 都默认是这个意思。 查询复杂度：$O(\\log^2 p)$，其中一个 $\\log p$ 是枚举 $p$ 的所有唯一分解项复杂度，另外一个则是求逆元的复杂度。 范围4：$n,m \\leq 10^6,p \\leq 10^9+7$ 1 这里提供范围3的另外一种做法。\n其实很简单，我们只用把 $C_n^m$ 表示为 $2^? \\times 3^? \\times 5^? \\times \\dots$ 的形式即可。\n有人问，这个质数要枚举到多少呢？其实显然最多只用枚举到 $n$。\n实现这个做法可以借助一个函数ci(n,p)代表 $n!$ 的唯一分解中，$p$ 的指数是多少，这个函数可以用奥数知识，在 $\\log_p n$ 的复杂度内求出。\n细节不用多说。\n2 预处理复杂度：$O(n)$ 查询复杂度：$O(\\text{prime}(n) \\times \\log n)$，其中 $\\text{prime}(n)$ 代表 $n$ 及以内的质数个数，约为 $n \\div \\ln(n)$，以下所有 $\\text{prime}$ 函数都是这个意思；$\\log n$ 为ci函数的上界复杂度。 范围5：$n \\leq 10^{18},m \\leq 10^6,p \\leq 10^9+7,p\\text{ is prime}$ 1 注意到 $m \\leq 10^6$，所以我们就直接用公式 $C_n^m=\\dfrac{n \\times (n-1) \\times (n-2) \\times \\dots \\times (n-m+1)}{1 \\times 2 \\times 3 \\times \\dots \\times m}$，配合逆元求解即可。\n2 预处理复杂度：无 查询复杂度：$O(m \\log p)$，其中 $\\log p$ 为算逆元的时间复杂度。 范围6：$n \\leq 10^{18},m \\leq 10^6,p \\leq 10^9+7$ 1 注意到 $p$ 没有保证是质数，所以分母内的那些项没有逆元。\n但我们还可以用与范围3的做法1相似的做法去做。\n具体地，我们先分解 $p$，然后对于唯一分解内的每一项 $q^a$，先求出 $n \\times (n-1) \\times (n-2) \\times \\dots \\times (n-m+1) \\bmod q^a$。\n然后循环每个 $i \\in [1,m]$，把 $i$ 中的 $q$ 都除尽，此时就可以求 $i$ 在模 $q^a$ 意义下的逆元了，直接更新答案即可。\n2 预处理复杂度：$O(m \\log p)$ 查询复杂度：$O(\\log^2 p)$，该复杂度解释见范围3的做法1的同地（同一个地方）。 范围7：$n,m \\leq 10^{18},p \\leq 10^6+3,p\\text{ is prime}$ 1 直接Lucas定理即可。\n2 预处理复杂度：$O(p)$ 查询复杂度：$O(\\log m)$ 范围8：$n,m \\leq 10^{18},p \\leq 10^6+3$ 1 直接exLucas定理即可。\n2 预处理复杂度：$O(\\sqrt{p})$ 查询复杂度：$O(\\log p \\log n+\\log^2 p)$，其中第一个 $\\log p$ 为枚举 $p$ 的所有唯一分解项复杂度，$\\log n$ 为ci函数/f函数复杂度，第二个 $\\log p$ 为CRT内枚举方程复杂度，第三个 $\\log p$ 为CRT内求逆元的复杂度。 范围9：$n,m \\leq 10^{18},p \\leq 10^9+7$ 1 这个数据范围需要利用高阶多项式的知识，参考这里\n2 预处理复杂度：未知 查询复杂度：未知 组合数模型：球盒模型 参考：\nhttps://zhuanlan.zhihu.com/p/602410836 统一设 $n$ 为球的个数，$m$ 为盒子的个数。\n在情况 $i$ 内，$f_i(n,m)$ 为这种情况下，如果球数为 $n$、盒子数为 $m$，方案数是多少。\n转到：球盒模型公式\n情况1：球相同，盒相同，允许为空 这种情况下无法直接求，需要递推。\n接下来考虑转移 $f_1(n,m)$：\n$n=0$：$f_1(n,m)=1$ $m=0$：$f_1(n,m)=0$ $n\u0026lt;m$：首先必然会有 $m-n$ 个盒子是空的，其次由于盒子两两相同，所以可以任意指定哪些格子为空，即 $f_1(n,m)=f_1(n,n)$ $n \\geq m$： 如果所有盒子都不为空：我们可以先在每个格子里拿出一个球，即 $f_1(n,m) \\text{+=} f_1(n-m,m)$ 否则：我们就随便指定一个格子，设这个格子为空，即 $f_1(n,m) \\text{+=} f_1(n,m-1)$ 情况2：球相同，盒相同，不允许为空 这种情况下可以直接求。\n具体地，设要求 $f_2(n,m)$。\n那么我们考虑，其实情况1和情况2就一个区别，情况1允许为空，情况2不允许。\n所以我们就可以先在所有盒子内都拿出一个球，保证都非空后，就转化为了情况1，即 $f_2(n,m)=f_1(n-m,m)$。\n但注意，当 $n\u0026lt;m$ 时，方案数为 $0$。\n情况3：球相同，盒不同，允许为空 其实就是在问 $x_1+x_2+x_3+\\dots+x_m=n$ 的非负整数解的个数。\n由于是非负整数，所以我们要先把所有的 $x_i$ 加 $1$，就变成了问 $x_1+x_2+x_3+\\dots+x_m=n+m$ 的正整数解的个数。\n上述问题可以用插板法解决，答案为 $f_3(n,m)=C_{n+m-1}^{m-1}$。\n情况4：球相同，盒不同，不允许为空 其实就是在问 $x_1+x_2+x_3+\\dots+x_m=n$ 的正整数解的个数。\n上述问题可以用插板法解决，答案为 $f_4(n,m)=C_{n-1}^{m-1}$。\n情况5：球不同，盒相同，允许为空 （请先阅读情况6）\n1 有了情况6的铺垫，这里就变得简单了。\n我们可以考虑枚举空出来的盒子数 $i$（$0 \\leq i \\leq m$），然后 $f_5(n,m) \\text{+=} f_6(n,m-i)$。\n即，$f_5(n,m)=\\sum\\limits_{i=0}^m f_6(n,m-i)$。\n很好懂。\n2 但这里也顺便说一下 $n \\leq m$ 时的另一种做法——求贝尔数。\n首先，由于盒子都相同，所以其实答案与 $m$ 无关。\n所以，如论是什么 $n$、$m$，只要 $n \\leq m$，那么就转化为了，有 $n$ 个不同的球，放入 $n$ 个相同的盒子，每个盒子都允许为空，问方案数。\n一个结论就是，若设 $b_i$ 为 $n=i,m \\geq n$ 时的答案，即 $b_n=f_5(n,n)$。\n那么，$b_n=\\sum\\limits_{i=0}^{n-1} C_{n-1}^i b_i$。\n（$n=0$ 的情况直接特判，$b_0=1$）\n接下来解释一下这个公式。\n我们枚举的这个 $i$ 其实就是代表着，我们假设球 $n$ 所在盒子里有放了 $n-i$ 个球（包括球 $n$）。\n注意到，在这个公式内，$n-i$ 的范围是 $[1,n]$，而不是 $[0,n]$，因为 $n$ 所在盒子显然要至少包含一个球。（废话）\n有人问，为啥要枚举球 $n$ 所在盒子里的球数，而不是任意盒子里的球数？因为后者很容易计重，而前者肯定不会计重，也不会计漏，显然。\n然后，我们就忽略那个有球 $n$ 的、放了 $n-i$ 个球的盒子，剩下的盒子里的球的总数就是 $i$ 了。\n显然，$i$ 个球最多涉及 $i$ 个盒子，所以那 $i$ 个球的放置方案数就是 $b_i$。\n但注意到，球是不同的，所以我们还要额外加一个选择（那 $i$ 个球）的方案数作为系数。\n由于 $n$ 号球已经被确定不会被放在那 $i$ 个盒子里了，所以其实只有 $n-1$ 个球可以被选择并放入那 $i$ 个盒子中。\n于是就得到了上述公式。\n情况6：球不同，盒相同，不允许为空 其实就是第二类斯特林数，又写作 $n \\brace m$。\n其实转移很好想，一种就是当前元素单立一个集合，另一种就是加入到以前的某个集合。\n即 $f_6(n,m)=f_6(n-1,m-1)+f_6(n-1,m) \\times m$。\n还是，如果 $n\u0026lt;m$，方案数为 $0$。\n情况7：球不同，盒不同，允许为空 由于球、盒都不同，所以我们就可以分别去考虑每个球去哪个盒里了。\n由于球的选择互相独立，所以可以直接用乘法原理乘起来。\n由于允许为空，所以没有其他限制。\n综上所述，$f_7(n,m)=m^n$。\n情况8：球不同，盒不同，不允许为空 该情况与情况6的唯一区别就在于，盒子是两两不同的。\n所以，我们可以直接拿情况6里的答案，乘上 $m!$ 返回即可。\n综上所述，$f_8(n,m)=f_6(n,m) \\times m!$。\n球盒模型主要情况总结 情况1：球相同，盒相同，允许为空 ： $n=0$：$f_1(n,m)=1$ $m=0$：$f_1(n,m)=0$ $n\u0026lt;m$：$f_1(n,m)=f_1(n,n)$ $n \\geq m$：$f_1(n,m)=f_1(n-m,m)+f_1(n,m-1)$ 情况2：球相同，盒相同，不允许为空 ： $n\u0026lt;m$：$f_2(n,m)=0$ $n \\geq m$：$f_2(n,m)=f_1(n-m,m)$ 情况3：球相同，盒不同，允许为空 ： 任何情况：$f_3(n,m)=C_{n+m-1}^{m-1}$ 情况4：球相同，盒不同，不允许为空 ： $n\u0026lt;m$：$f_4(n,m)=0$ $n \\geq m$：$f_4(n,m)=C_{n-1}^{m-1}$ 情况5：球不同，盒相同，允许为空 ： 任何情况：$f_5(n,m)=\\sum\\limits_{i=0}^m f_6(n,m-i)$ 情况6：球不同，盒相同，不允许为空 ： $n\u0026lt;m$：$f_6(n,m)=0$ $n \\geq m$：$f_6(n,m)=f_6(n-1,m-1)+f_6(n-1,m) \\times m$ 情况7：球不同，盒不同，允许为空 ： 任何情况：$f_7(n,m)=m^n$。 情况8：球不同，盒不同，不允许为空 ： $n\u0026lt;m$：$f_8(n,m)=0$ $n \\geq m$：$f_8(n,m)=f_6(n,m) \\times m!$ 组合数模型：球盒模型拓展 参考：\nhttps://zhuanlan.zhihu.com/p/602410836 统一设 $n$ 为球的个数，$m$ 为盒子的个数。\n在情况 $i$ 内，$g_i(n,m)$ 为这种情况下，如果球数为 $n$、盒子数为 $m$，方案数是多少。\n（若有更多限制，可以在最后加另外参数）\n转到：球盒模型扩展公式\n拓展情况1：球相同，盒相同，不允许为空，至少 $t$ 个球 1 考虑DP。\n由于球、盒都相同，所以可以将问题转化成数划分问题。\n具体地，这个问题可以被转化成，数 $n$ 拆成刚好 $m$ 个数相加，且每个数至少为 $t$ 的方案数\n定义状态 $d_{i,j,k}$ 代表数 $i$ 拆成刚好 $j$ 个数相加，且每个数至少为 $k$ 的方案数。\n转移就枚举拆分里的某一项的值 $x$，从 $k$ 到 $n$，然后就转移到了状态 $d_{i-x,j-1,x}$。\n其中，为了防止计重，最后一维要是 $x$ 而不是 $k$。\n综上所述，$d_{i,j,k}=\\sum\\limits_{x=k}^n d_{i-x,j-1,x}$，$g_1(n,m,t)=d_{n,m,t}$。\n最后，说一些边界：\n$n=0,m=0$：$g_1(n,m,t)=1$ $n=0$：$g_1(n,m,t)=1$ $m=0$：$g_1(n,m,t)=0$ $n\u0026lt;m \\times t$：$g_1(n,m,t)=0$ 2 （下述做法还不能被证明完全正确，仅为参考）\n首先，还是判断上面那些边界。\n判断完边界后，就可以完全忽略“不允许为空”的限制了。\n我们考虑事先在每个盒子里都拿走 $t$ 个球，然后就转化为了 $n-m \\times t$ 个球，$m$ 个盒，球、盒都相同，盒允许为空，问方案数。\n就是情况1的问题，直接调用即可。\n综上所述，$g_1(n,m,t)=f_1(n-m \\times t,m)$。\n拓展情况2：球相同，盒不同，不允许为空，盒 $i$ 至少 $a_i$ 个球 （如果说存在某个 $a_i$ 是小于 $1$ 的，直接将其设为 $1$）\n与模型3的唯一差别就在于这里有每个盒子内球个数的下界限制。\n但球还是两两相同的，所以我们考虑事先在第 $i$ 个格子里放 $a_i$ 个球。\n剩下的工作就交给模型3了。\n注意，在初始放完之后，某个格子可能会出现说不再放任何球的情况，所以应该转化成模型3而不是模型4。\n综上所述，$g_2(n,m,a)=f_3(n-\\sum a_i,m)$。\n但如果 $n\u0026lt;\\sum a_i$，是无解的，显然。\n拓展情况3：球相同，盒不同，允许为空，至多 $t$ 个球 该情况需要用到生成函数，生成函数学习笔记网页及本模型做法见这里的模型2B。\n拓展情况4：球相同，盒不同，允许为空，至多 $1$ 个球，非空盒不可相邻 （说一个细节，题目中说的“非空盒不可相邻”指的是如果给所有盒子依次赋予 $1 \\sim m$ 内的编号，那么按编号顺序排成一列后，非空盒不可相邻）\n易得只有在 $2n-1 \\leq m$ 的时候才有解，其中 $2n-1$ 代表 $n$ 个球如果一隔一（第一个格子里放一个球，第二个格子不放，第三个放，第四个不放，以此类推）地放，需要用多少个盒子才能满足条件；同时 $2n-1$ 也是这个 $n$ 对应的 $m$ 的下限。\n接下来考虑有解情况。\n（以下暂时忽略编号，在构造完一个方案后按排列顺序依次编号）\n首先，我们在 $m$ 个盒子里选 $n$ 个盒子，并从盒子的集合中删去这 $n$ 个盒子（下称“第一步”），每个被选的盒子里都恰好放置 $1$ 个球，所有球都放完了。（注意，此处的选择方案不能被计算到答案中）\n但这里不能直接考虑剩下 $m-n$ 个盒子要放到什么位置，因为不好处理。\n具体地，我们遇到这种情况都是把最初两两盒子内的间隙（包括两旁）看成盒子，把盒子看成球。\n但你会发现，这 $n+1$ 个盒子中有 $n-1$ 个盒子要求不为空，另外两个盒子不要求，所以不好求。\n那咋解决呢？很简单，我们只用在那 $n-1$ 个盒子内全部事先拿一个球出来即可，即再选 $n-1$ 个盒子插入原本的 $n$ 个盒子的间隙中，并将这 $n-1$ 个格子从盒子集合中移除（下称“第二步”）。\n所以，最后一共就有 $m-n-(n-1)=m-2n+1$（前项 $m-n-(n-1)$ 中，第一个 $-n$ 是第一步的影响；第二个 $-(n-1)$ 则是第二步的影响）个球，$n+1$ 个盒子，所以最终答案就是 $f_4(m-2n+1,n+1)$。\n球盒模型扩展主要情况总结 转到：球盒模型公式\n拓展情况1：球相同，盒相同，不允许为空，至少 $t$ 个球 ： $n=0,m=0$：$g_1(n,m,t)=1$ $n=0$：$g_1(n,m,t)=1$ $m=0$：$g_1(n,m,t)=0$ $n\u0026lt;m \\times t$：$g_1(n,m,t)=0$ 其他情况：$g_1(i,j,k)=\\sum\\limits_{x=k}^n g_1(i-x,j-1,x)$ 拓展情况2：球相同，盒不同，不允许为空，盒 $i$ 至少 $a_i$ 个球 ： 如果说存在某个 $a_i$ 是小于 $1$ 的，直接将其设为 $1$。 $n\u0026lt;\\sum a_i$：$g_2(n,m,a)=0$ 其他情况：$g_2(n,m,a)=f_3(n-\\sum a_i,m)$ 拓展情况3：球相同，盒不同，允许为空，至多 $t$ 个球 ： 该情况需要用到生成函数，生成函数学习笔记网页及本模型做法见这里的模型2B。 拓展情况4：球相同，盒不同，允许为空，至多 $1$ 个球，非空盒不可相邻 ： *注：题目中说的“非空盒不可相邻”指的是如果给所有盒子依次赋予 $1 \\sim m$ 内的编号，那么按编号顺序排成一列后，非空盒不可相邻。 $2n-1\u0026gt;m$：$g_4(n,m)=0$ 其他情况：$g_4(n,m)=f_4(m-2n+1,n+1)$ ","permalink":"https://qjwh.github.io/posts/oi/aln/c/","summary":"\u003ctext style=\"font-family:Lato,楷体\"\u003e\r\n\u003cp\u003e有人问，组合数学不是就一些简单的公式吗？不是的，其实组合数学是数学中的一个非常庞大的分支，接下来就举\u003cstrong\u003e一些\u003c/strong\u003e例子。\u003cem\u003e（更新中）\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e本文主要讲各种数据范围下，求组合数的方式；以及球盒模型各种情况下的公式；最后是一些球盒模型的扩展情况。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/posts/oi/aln/c/#%e7%90%83%e7%9b%92%e6%a8%a1%e5%9e%8b%e4%b8%bb%e8%a6%81%e6%83%85%e5%86%b5%e6%80%bb%e7%bb%93\"\u003e转到：球盒模型公式\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/posts/oi/aln/c/#%e7%90%83%e7%9b%92%e6%a8%a1%e5%9e%8b%e6%89%a9%e5%b1%95%e4%b8%bb%e8%a6%81%e6%83%85%e5%86%b5%e6%80%bb%e7%bb%93\"\u003e转到：球盒模型扩展公式\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（下面部分标题里的LaTeX公式更新后炸了，就凑合着看吧）\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-求组合数\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 求组合数\u003c/h2\u003e\n\u003cp\u003e以下所有范围都可以当成是以下题目的某个Subtask：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e给你 $p$，代表模数。\u003c/p\u003e\n\u003cp\u003e之后会给你一个 $q$，代表询问次数。\u003c/p\u003e\n\u003cp\u003e每次询问给定 $n$ 和 $m$，问 $C_n^m \\bmod p$ 的值。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e下面不给定 $q$ 的范围，因为不重要。\u003c/p\u003e\n\u003cp\u003e以下全部默认 $n \\geq m$。\u003c/p\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-范围1nm-leq-2000p-leq-1097\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 范围1：$n,m \\leq 2000,p \\leq 10^9+7$\u003c/h3\u003e\n\u003cp\u003e先递推预处理，然后直接回答询问即可。\u003c/p\u003e\n\u003cp\u003e递推式：$C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e预处理复杂度：$O(n^2)$\u003c/li\u003e\n\u003cli\u003e查询复杂度：$O(1)$\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-范围2nm-leq-106p-leq-1097ptext-is-prime\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 范围2：$n,m \\leq 10^6,p \\leq 10^9+7,p\\text{ is prime}$\u003c/h3\u003e\n\u003ch4 id=\"text-stylecolorrgb0150136-1\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 1\u003c/h4\u003e\n\u003cp\u003e先预处理阶乘，然后直接回答询问即可。\u003c/p\u003e\n\u003cp\u003e回答询问式：$C_n^m=\\dfrac{n!}{m!(n-m)!}$。\u003c/p\u003e\n\u003cp\u003e为了节省时间复杂度，此处还可以预处理一下阶乘的逆元。\u003c/p\u003e\n\u003ch4 id=\"text-stylecolorrgb0150136-2\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 2\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e预处理复杂度：$O(n)$\u003c/li\u003e\n\u003cli\u003e查询复杂度：$O(1)$\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-范围3nm-leq-106p-leq-1097\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 范围3：$n,m \\leq 10^6,p \\leq 10^9+7$\u003c/h3\u003e\n\u003ch4 id=\"text-stylecolorrgb0150136-1-1\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 1\u003c/h4\u003e\n\u003cp\u003e可以发现，范围2与范围3唯一的不同就是，范围3把质数的条件去掉了。\u003c/p\u003e\n\u003cp\u003e而把质数的条件后，就没法求逆元了，因为逆元可能不存在。\u003c/p\u003e\n\u003cp\u003e所以我们考虑换做法。\u003c/p\u003e\n\u003ch4 id=\"text-stylecolorrgb0150136-2-1\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 2\u003c/h4\u003e\n\u003cp\u003e我们考虑把模数做个质因数分解，变成 ${p_1}^{a_1} \\times {p_2}^{a_2} \\times {p_3}^{a_3} \\times \\dots \\times {p_k}^{a_k}$。\u003c/p\u003e","title":"组合数学（待补充）"},{"content":"This page is just for test\n123\n$123$\n$$ 123 $$\n$x^2$\n$\\color{green}(\\sum a_i) \\color{default} 123$\n456 456 123 123 123 123 123 123 123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n123\n","permalink":"https://qjwh.github.io/posts/test/","summary":"\u003cp\u003eThis page is just for test\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e$123$\u003c/p\u003e\n\u003cp\u003e$$\n123\n$$\u003c/p\u003e\n\u003cp\u003e$x^2$\u003c/p\u003e\n\u003cp\u003e$\\color{green}(\\sum a_i) \\color{default} 123$\u003c/p\u003e\n\u003ch1 id=\"456\"\u003e456\u003c/h1\u003e\n\u003ch2 id=\"456-1\"\u003e456\u003c/h2\u003e\n\u003ch1 id=\"123\"\u003e123\u003c/h1\u003e\n\u003ch2 id=\"123-1\"\u003e123\u003c/h2\u003e\n\u003ch3 id=\"123-2\"\u003e123\u003c/h3\u003e\n\u003ch4 id=\"123-3\"\u003e123\u003c/h4\u003e\n\u003ch5 id=\"123-4\"\u003e123\u003c/h5\u003e\n\u003ch6 id=\"123-5\"\u003e123\u003c/h6\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e123\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://cdn.luogu.com.cn/upload/image_hosting/czpw2jco.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cvideo src=\"/1.mp4\" controls=\"controls\" width=\"800\"\u003e\u003c/video\u003e\u003c/p\u003e","title":"Hello, world!"},{"content":"\r普通莫队算法 概览 莫队其实是分块的变化版，没有完全分块。\n但莫队的题目一般比分块的题目比较好看一些，其中的“好看”指的是很好看出这是个莫队/分块的题。\n接下来说一下莫队能解决的题型。\n解决题型 莫队一般解决以下问题：\n给你一些信息，和 $q$ 次询问，每次询问可以抽象为一个区间。\n而且这个问题还要满足一些条件：\n可以离线 不能有修改（当然带修莫队支持修改，不过普通莫队就不行了） 从 $[l,r]$ 的答案可以很快转移到 $[l-1,r]$、$[l+1,r]$、$[l,r-1]$、$[l,r+1]$ 的答案 解决方法 这种题型有个解决方法。\n还是先从暴力说起。\n暴力做法 看见这个问题的最后一个条件没？这个条件就启发我们从第一个问题的答案，暴力调整左、右端点，去得到第二个问题的答案，以此类推。\n这种暴力做法的复杂度一般为 $O($ 任意相邻两个问题的左、右端点差之和 $)$。\n而这个算法可以用一种数据卡掉：\n左、右端点的值的最大值 $n$ 调到最大，把询问次数 $q$ 也调到最大。 然后的 $q$ 次询问里，交替询问 $1 \\sim n$ 和 $n \\sim n$。 于是，复杂度被卡到 $O(qn)$。\n一次优化 这个做法的复杂度是无法接受的，所以我们考虑优化。\n我们不如把所有询问离线，然后考虑交换询问处理的顺序以减少复杂度。\n一种方式就是把左、右端点分别作为第一、二关键字，然后做排序。\n但这样就会被排序后所有询问的右端点一大一小的数据卡到 $O(qn)$ 的复杂度。\n二次优化 这样排序还是不好，还是会被卡掉，于是我们考虑变换比较函数。\n直接双关键字比较不好，那我们就分块后进行双关键字比较。\n具体地，遇到两个询问，先按左端点所属块编号从小到大排序，如果相同，则按右端点（不是所属块编号，是原本的下标）从小到大排序。\n这样的话，复杂度就是 $O(n \\sqrt n+q \\sqrt n)$ 的复杂度了。\n做法复杂度证明 这个复杂度很多人看了都不理解，这里就证明一下。\n（如果没有以下证明，很多人都会认为，这个复杂度还是 $O(qn)$ 的，从而失去很多AC题的机会，所以一定要认真理解）\n（我也吃过这个亏，所以有了上面那句话）\n我们仿照双指针证明方式，分别去看左、右端点的总变化次数。\n右端点 先看右端点移动次数，因为比较好证明。\n首先我们看左端点在同一个块内，右端点最多变化几次，显然最多 $O(n)$ 次，一共 $O(\\sqrt n)$ 个块，所以这部分总复杂度 $O(n \\sqrt n)$。\n接下来看左端点换到另一个块的时候，最多变化几次。\n显然还是 $O(n)$ 次最多，而左端点最多会进行 $O(\\sqrt n)$ 次“换块”的过程，所以这部分复杂度也是 $O(n \\sqrt n)$。\n所以右端点最多 $O(n \\sqrt n)$ 次移动。\n左端点 再看比较难证明的右端点移动次数。\n我们首先看左端点在“换块”的过程中总共会变化几次，显然最多总共变化 $O(n)$ 次。\n接下来看左端点在同一个块内，从前到后总共会变化多少次，显然一次变化最多 $O(\\sqrt n)$ 次，最坏情况下所有询问左端点都在同一个块中，所以变化次数最多就 $O(q)$ 次。\n所以右端点最多 $O(q \\sqrt n)$ 次移动。\n证毕。\n莫队常数优化 莫队可以配合很多东西，但如果配合的算法常数大，我们就要对莫队算法本身做优化了。\n据教练实测，这种常数优化能优化一倍常数。\n复杂度瓶颈 首先，我们看上面做法的复杂度慢在哪儿了。\n回顾上述证明过程，我们分几个部分来看总复杂度：\n左端点变化总数： 同块最多共变化 $O(q \\sqrt n)$ 次。 换块最多共变化 $O(n)$ 次。 右端点变化总数： 同块最多共变化 $O(n \\sqrt n)$ 次。 换块最多共变化 $O(n \\sqrt n)$ 次。 可以发现，复杂度常数大就大在右端点的变化次数上，这里有两倍的常数。\n同块的变化总次数已经最优了，无法优化；但换块过程的总次数是可以更优的。\n右端点变化 我们把右端点变化的过程画出来：\n我们标注一下：\n可以发现，每次换块，右端点都要“从头再来”，而降低这个过程所需时间，就可以减少常数。\n我们可以考虑按左端点所在块的编号 $x$ 分别考虑，如果左端点所在块的编号不同，还是按编号从小到大排序，否则：\n如果 $x$ 为奇数，则按右端点从小到大排序。 如果 $x$ 为偶数，则按右端点从大到小排序。 这下，这个右端点的变化图就变了：\n而这下常数就少了。\n高维莫队 此处以三维莫队为例。\n三维莫队是说每次修改给你 $(l,r,t)$ 三个参数，让你查询所有满足 $x\u0026rsquo; \\in [l,r]$ 且 $t\u0026rsquo; \\leq t$ 的 $(x\u0026rsquo;,t\u0026rsquo;)$ 数对的某个权值（此处举个例子）。\n这种情况下咋做呢？其实和二维莫队是差不多的。\n我们设计一个块大小 $B$，然后先按 $l$ 所在块从小到大排序，然后按 $r$ 所在块从小到大排序，如果都相同，就按 $t$ 从小到大排序。\n设块数为 $C$，我们尝试计算一下复杂度。\n我们先看一下 $t$ 指针移动的总复杂度： 显然对于每个不同的 $(\\text{bel}_l,\\text{bel}_r)$（$\\text{bel}_i$ 表示 $i$ 所在块），$t$ 最坏会从最小值移动到最大值（$O(n \\times C^2)$ 复杂度）；然后在换块的时候，再从最大值移动到最小值（$O(n \\times C^2)$ 复杂度）。\n此处设 $l$、$r$、$t$ 的最大值都是 $n$，那么 $t$ 指针的复杂度就是 $O(nC^2)$。\n我们再看一下 $r$ 指针移动的总复杂度： 在 $\\text{bel}_l$ 变化时，$r$ 最坏会从最大值移动到最小值（$O(nC)$ 复杂度）；而在 $\\text{bel}_l$ 不变时，如果 $\\text{bel}_r$ 也不变，则 $r$ 每次变化最多 $B$（$O(nB)$ 复杂度，注意不是 $O(BC^2)$）；但如果 $\\text{bel}_r$ 变化，则 $r$ 变化最多 $2B$（$O(BC^2)$ 复杂度）。\n由于 $O(BC)=O(n)$，所以最后一部分的复杂度就是 $O(BC^2)=O(nC)$；且根据上面复杂度 $O(nC^2)$，我们猜测 $B\u0026gt;C$（因为后面要复杂度均衡）；所以 $r$ 指针的复杂度就是 $O(nB)$。\n最后看一下 $l$ 指针移动的总复杂度： 在 $\\text{bel}_l$ 变化时，$l$ 会变化 $2B$ 次（$O(BC)$ 复杂度）；而在 $\\text{bel}_l$ 不变时，$l$ 每次变化最多 $B$ 次（$O(nB)$ 复杂度）。\n综上所述，$l$ 指针的复杂度就是 $O(nB)$。\n然后，我们的目标就是设计 $B$ 和 $C$ 的值，使得这三个部分的复杂度相同。\n即 $O(nC^2)=O(nB)=O(nB)$，同时要保证 $BC=n$。\n最后一项重复，直接删去，然后把 $n$ 一消，即可得到 $O(C^2)=O(B)$。\n由于要保证 $BC=n$，所以 $B=n^{\\frac{2}{3}}$，$C=n^{\\frac{1}{3}}$。\n而复杂度就是 $O(nB)$，即 $O(nC^2)$，带入后得到复杂度为 $O(n \\times n^{\\frac{2}{3}})=O(n^{\\frac{5}{3}})$。\n（这个复杂度在 $n=10^5$ 的时候大约为 $2.1 \\times 10^8$，在 $n=5 \\times 10^4$ 的时候大约为 $6.7 \\times 10^7$）\n同理，还可以得到四维莫队复杂度为 $O(n^{\\frac{7}{4}})$，$k$ 维莫队复杂度为 $O(n^{\\frac{2k-1}{k}})$。\n（四维莫队复杂度在 $n=10^5$ 的时候大约为 $5.6 \\times 10^8$，在 $n=5 \\times 10^4$ 的时候大约为 $1.6 \\times 10^8$，在 $n=10^4$ 的时候为 $10^7$）\n（所以，莫队到四维已经和 $O(n^2)$ 算法差不多了，到五维的时候就根本没必要了，这种情况下就另辟蹊径，或者考虑降维了）\n带修莫队 其实所谓的带修莫队，就是三维莫队。\n我们给每个输入的修改和查询都附上时刻参数，意思就是在这个时刻进行修改/查询。\n然后，在时刻自增时，把这个时刻上的修改操作加入考虑范围；在自减时，就踢出考虑范围。\n所以就可以写出代码了，参考M2613。\n树上莫队 众所周知，树上莫队只能解决序列问题，但如果搬到树上呢？就需要加一层特殊处理。\n在将这种处理方式前，先引入一个知识点。\n括号序 括号序也是遍历树得到的序列种类之一。\n三大遍历序 实现方式 我目前了解到的有三大遍历序：（下面每个代码里的v都是一个vector，为对应遍历序列）\n欧拉序（又称“DFS序”）\nvoid dfs(LL x, LL fa){ v += x; erg(i, pre, x){ LL to = a[i].to; if(to == fa) continue; dfs(to, x); } } 扩展欧拉序（又称“exDFS序”）\nvoid dfs(LL x, LL fa){ v += x; erg(i, pre, x){ LL to = a[i].to; if(to == fa) continue; dfs(to, x); v += x; } } 括号序\nvoid dfs(LL x, LL fa){ v += x; erg(i, pre, x){ LL to = a[i].to; if(to == fa) continue; dfs(to, x); } v += x; } 性质与应用场景 同时，每个遍历序都有自己的性质和应用场景：\n欧拉序： 对于一个子树，子树内所有节点的欧拉序连续。 所以如果把每个节点编号替换成其欧拉序，那么可以直接用树状数组/线段树解决： 单点修改节点权值。 查询子树内所有节点权值的和/最值/异或和等。 （待补充） 扩展欧拉序： 对于一棵树上的任意两个点，这两点在扩展欧拉序上第一次出现的位置组成的区间内深度最小的点就是LCA。 所以可以用RMQ更快地解决LCA问题。 （待补充） 括号序： 对于树上的链，有一个特殊性质，见下。 所以可以解决树上与链相关的问题，不过比较局限，因为上面说的“性质”很复杂。 （待补充） 括号序的特殊性质 下面说一下括号序的几个特殊性质。\n可以发现，每个点在括号序上一定都只出现过刚好 $2$ 次，设点 $x$ 第一次出现在位置 $\\text{lef}_x$ 上，第二次出现在位置 $\\text{rig}_x$ 上。\n然后，我们考虑对于一棵树上的两点 $x$、$y$，考虑在括号序上表示点 $x$ 到 $y$ 的路径上的所有点。\n我们分几种情况：\n如果点 $x$ 和 $y$ 是祖先后代关系（设 $x$ 为 $y$ 的祖先）： 在括号序的第 $\\text{lef}_x \\sim \\text{lef}_y$ 个位置里，出现过奇数次的所有点，就是点 $x$ 到 $y$ 的路径上的所有点。 如果点 $x$ 和 $y$ 没有任何关系： 在括号序的第 $\\text{rig}_x \\sim \\text{lef}_y$ 个位置里，出现过奇数次的所有点，加上点 $\\text{lca}(x,y)$，就是点 $x$ 到 $y$ 的路径上的所有点。 比如，这棵树：\n的括号序就是 $[1,2,3,4,4,3,5,6,6,7,7,5,2,1]$。\n那么，如果 $x=2,y=6$，则我们看的就是第 $2 \\sim 8$ 个位置，出现过奇数次的节点有 $2$、$5$、$6$，正确。\n还比如如果 $x=4,y=7$，则我们看的就是第 $5 \\sim 10$ 个位置，出现过奇数次的节点有 $3$、$4$、$5$、$7$，加上 $\\text{lca}(x,y)=2$，正确。\n可以发现，这个性质一定成立。\n处理方式 讲完括号序后，我们回到上面说的“处理方式”。\n方式简述 根据上面说的性质，你应该就猜到了所谓的方式是啥了。\n我们就把括号序求出，然后把询问变成三个参数：\n$l$、$r$：我们看的是括号序的第 $l \\sim r$ 个位置。 $k$：而且不仅要考虑这些位置内出现奇数次的点，还要考虑第 $k$ 个点。 其中，如果 $k=-1$，则不用多考虑。\n此时，我们就可以用莫队直接处理了。\n代码细节 我们可以用莫队维护 $l$ 和 $r$ 端点，每次添加/删除一个括号序上的下标时，看这个下标上的值（点编号，设为 $x$）出现过的次数的奇偶性来看要加入 $x$ 点的影响还是要剔除 $x$ 点的影响。\n此外，在调整完 $l$、$r$ 端点，处理完修改（如果有）之后，我们还要临时加入点 $k$（注意，不是下标 $k$）的影响，然后将答案存入数组，并在存入后，重新删除点 $k$ 的影响。\n其他细节见M2621的代码（为树上带修莫队）。\n回滚莫队 解决完特殊题型后，我们再回头看普通莫队的变种——回滚莫队。\n老规矩，先说题型。\n解决题型 在很多题里，你会发现，莫队的add函数很好实现，但del函数却很难实现。\n此时，我们就要用到回滚莫队了。\n概览 其实回滚莫队的思想很简单，就是通过某种方式让整个莫队里只有add操作。\n但这样还是不能实现，我们就再加一个undo操作（撤销操作）。\n接下来可以看回滚莫队的算法实现了。\n实现 存储修改 在将回滚莫队前，我们要先修改一下原本传统的存储询问结构。\n我们要先分块，然后把左端点所在块相同的询问，存到一起。\n并且，对于左端点在同一个块的询问，按右端点从小到大排序。\n那有人就问了，这样做的用处是啥？接下来你就知道了。\n同块处理 接下来，我们来枚举左端点所在块 $i$，并循环所有询问左端点为 $i$ 的询问 $[l,r]$。\n那么如果说 $l$ 和 $r$ 在同一个块中，那么直接循环每个 $i \\in [l,r]$，并将下标 $i$ 加入影响即可。\n全部加入后，直接把答案存储，并重新撤销全部。\n异块处理 但如果 $l$ 和 $r$ 不在同一个块中呢？其实也能处理的。\n我们设当前考虑的下标区间为 $[nl,nr]$，初始的时候 $nr$ 为块 $i$ 的右端点，并且 $nl=nr+1$，此时考虑范围为空区间。\n（如果说不允许空区间，可以干脆把 $nl$ 设为 $nr$，而不是 $nr+1$，同样可以执行下面做法）\n然后，由于已经将询问右端点 $r$ 从小到大排序了，所以 $nr$ 必然只会递增，也只会添加元素。\n循环到这个询问时，直接暴力调整 $nr$ 即可。\n接下来考虑调整 $nl$。\n为了方便处理，我们在调整并存入答案后，要把对 $nl$ 的所有修改撤销，让 $nl$ 重新等于初始值。\n所以，这里我们就假设 $nl$ 为初始值。\n那调整就可以直接调整即可。\n总结 可以发现，上面并没有涉及删除下标操作，只有加入下标和撤销操作。\n撤销操作可以 $O(1)$ 执行，所以复杂度和普通莫队复杂度相同。\n细节 上面说要对于每个左端点所在块都分别存储，那我们就要定义 $\\sqrt n$ 个vector，或者 $\\sqrt n$ 个长度为 $n$ 的数组。\n这样的话，不是常数大，就是空间大。\n我们不如直接把每个询问一股脑加入一个数组内，并按左端点所在块排序，如果相同按右端点排序。\n然后，在处理时，就可以直接循环，只用判断左端点所在块有没有变化即可。\n具体细节见M2622的代码。\n莫队二次离线 时隔多年，终于把二次离线搞了。\n解决题型 其实顾名思义，二次离线，就是要离线两次。\n莫队本身离线了一次。\n而如果说，离线一次后，我们无法及时更新add、del（或者undo）操作的影响，也就是无法及时回答query操作。\n那么我们就要做一些操作了。\n概览 我们考虑再次离线，把这些操作存下来，然后统一处理。\n处理之后，把更改或者此时实时的答案存下来。\n然后再跑一遍同样的莫队，此时add、del、query全都可以 $O(1)$ 搞出来了。\n实现 首先跑一遍莫队，把所有add、del操作记下来。\n往往此类操作都会转为前缀和去处理。\n然后把这些操作排个序，一遍扫过去就可以搞定了。\n记录答案的时候可以维护一个qid，直接存到对应的qid里面。\n接下来再次莫队，直接找对应qid的答案，更新即可。\n细节 一般情况下，在处理的时候都不是一个一个add或者del的去加操作的。\n而是我们对一个区间的操作一股脑加进去。\n但这样会有很多细节。\n具体可以看P4887代码。\n","permalink":"https://qjwh.github.io/posts/oi/aln/modui/","summary":"\u003ctext style=\"font-family:Noto Sans SC\"\u003e\r\n\u003ch1 id=\"text-stylecolorrgb0150136-普通莫队算法\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 普通莫队算法\u003c/h1\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-概览\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 概览\u003c/h2\u003e\n\u003cp\u003e莫队其实是分块的变化版，没有完全分块。\u003c/p\u003e\n\u003cp\u003e但莫队的题目一般比分块的题目比较好看一些，其中的“好看”指的是很好看出这是个莫队/分块的题。\u003c/p\u003e\n\u003cp\u003e接下来说一下莫队能解决的题型。\u003c/p\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-解决题型\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 解决题型\u003c/h2\u003e\n\u003cp\u003e莫队一般解决以下问题：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e给你一些信息，和 $q$ 次询问，每次询问可以抽象为一个区间。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e而且这个问题还要满足一些条件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e可以离线\u003c/li\u003e\n\u003cli\u003e不能有修改（当然带修莫队支持修改，不过普通莫队就不行了）\u003c/li\u003e\n\u003cli\u003e从 $[l,r]$ 的答案可以很快转移到 $[l-1,r]$、$[l+1,r]$、$[l,r-1]$、$[l,r+1]$ 的答案\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"text-stylecolorrgb0150136-解决方法\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 解决方法\u003c/h2\u003e\n\u003cp\u003e这种题型有个解决方法。\u003c/p\u003e\n\u003cp\u003e还是先从暴力说起。\u003c/p\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-暴力做法\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 暴力做法\u003c/h3\u003e\n\u003cp\u003e看见这个问题的最后一个条件没？这个条件就启发我们从第一个问题的答案，暴力调整左、右端点，去得到第二个问题的答案，以此类推。\u003c/p\u003e\n\u003cp\u003e这种暴力做法的复杂度一般为 $O($ 任意相邻两个问题的左、右端点差之和 $)$。\u003c/p\u003e\n\u003cp\u003e而这个算法可以用一种数据卡掉：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e左、右端点的值的最大值 $n$ 调到最大，把询问次数 $q$ 也调到最大。\u003c/li\u003e\n\u003cli\u003e然后的 $q$ 次询问里，交替询问 $1 \\sim n$ 和 $n \\sim n$。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e于是，复杂度被卡到 $O(qn)$。\u003c/p\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-一次优化\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 一次优化\u003c/h3\u003e\n\u003cp\u003e这个做法的复杂度是无法接受的，所以我们考虑优化。\u003c/p\u003e\n\u003cp\u003e我们不如把所有询问离线，然后考虑交换询问处理的顺序以减少复杂度。\u003c/p\u003e\n\u003cp\u003e一种方式就是把左、右端点分别作为第一、二关键字，然后做排序。\u003c/p\u003e\n\u003cp\u003e但这样就会被排序后所有询问的右端点一大一小的数据卡到 $O(qn)$ 的复杂度。\u003c/p\u003e\n\u003ch3 id=\"text-stylecolorrgb0150136-二次优化\"\u003e\u003ctext style=\"color:rgb(0,150,136)\"\u003e 二次优化\u003c/h3\u003e\n\u003cp\u003e这样排序还是不好，还是会被卡掉，于是我们考虑变换比较函数。\u003c/p\u003e\n\u003cp\u003e直接双关键字比较不好，那我们就分块后进行双关键字比较。\u003c/p\u003e\n\u003cp\u003e具体地，遇到两个询问，先按左端点所属块编号从小到大排序，如果相同，则按右端点（不是所属块编号，是原本的下标）从小到大排序。\u003c/p\u003e\n\u003cp\u003e这样的话，复杂度就是 $O(n \\sqrt n+q \\sqrt n)$ 的复杂度了。\u003c/p\u003e","title":""}]