<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on CXBlog</title>
    <link>https://qjwh.github.io/posts/</link>
    <description>Recent content in Posts on CXBlog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Mon, 10 Feb 2025 22:30:00 +0800</lastBuildDate>
    <atom:link href="https://qjwh.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【村新晚报】2025W03</title>
      <link>https://qjwh.github.io/posts/cxep/2025w03/</link>
      <pubDate>Mon, 10 Feb 2025 22:30:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/cxep/2025w03/</guid>
      <description>&lt;h2 id=&#34;重庆集训有感&#34;&gt;重庆集训有感&lt;/h2&gt;&#xA;&lt;h3 id=&#34;主线重庆集训&#34;&gt;主线：重庆集训&lt;/h3&gt;&#xA;&lt;p&gt;截止今天重庆的8天集训已经过去了6天了，是时候说说自己的感受了。&lt;/p&gt;&#xA;&lt;p&gt;只能说这次的集训内容很多。&lt;/p&gt;&#xA;&lt;p&gt;集训安排是每天上午（8:00&lt;del&gt;12:00）、下午（14:00&lt;/del&gt;17:30）有安排，我还会跟同一学校的大佬们在晚上去上晚自习（19:30~22:30）。&lt;/p&gt;&#xA;&lt;p&gt;事实上这次集训压力挺大的，集训必须要有效果，而且还要做作业（显然做不完），等等的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;副线休息&#34;&gt;副线：休息&lt;/h3&gt;&#xA;&lt;p&gt;所以我有时候会抽出时间来休息，这就是在集训期间还在微信上发消息的原因，不然这压力真的吃不消，这是自保护。&lt;/p&gt;&#xA;&lt;p&gt;比如说&lt;a href=&#34;https://xiaoce.fun/daily&#34;&gt;炒饭小测验&lt;/a&gt;就是这段时间知道的，每天都会登上去看看。&lt;/p&gt;&#xA;&lt;p&gt;另外在中午（12:00&lt;del&gt;14:00）、傍晚（17:30&lt;/del&gt;19:30）、晚上（19:30~22:30）是无管理时间，所以这段时间发消息是正常的，其他时间发消息往往是在休息。&lt;/p&gt;&#xA;&lt;h3 id=&#34;副线行程&#34;&gt;副线：行程&lt;/h3&gt;&#xA;&lt;p&gt;只说去程，G2241。&lt;/p&gt;&#xA;&lt;p&gt;我们订的是第一排的位置，感觉第一排的桌子比其他的桌子更小（？）。&lt;/p&gt;&#xA;&lt;p&gt;这回终于是把去年去重庆的大行李箱带上了。&lt;/p&gt;&#xA;&lt;p&gt;本来计划在路上做作业的，结果没时间，全在调代码。&lt;/p&gt;&#xA;&lt;p&gt;到了八维空间（重庆）之后百度导航就崩了，为了找火车站附近的一个酒店百度导航甚至让我穿墙……&lt;/p&gt;&#xA;&lt;h3 id=&#34;副线酒店&#34;&gt;副线：酒店&lt;/h3&gt;&#xA;&lt;p&gt;这次我们住的是全季酒店。&lt;/p&gt;&#xA;&lt;p&gt;这算是一个比较有名的酒店了。&lt;/p&gt;&#xA;&lt;p&gt;感觉总体设施还行，有用来送东西的机器人（还能远程操控电梯），在每个房间还有个AI（虽然没用过）。&lt;/p&gt;&#xA;&lt;p&gt;在桌上有个折叠式电源（就是默认是和桌子水平的，按一下才出来的那种），10A我能理解，标个250V就不能理解了。&lt;/p&gt;&#xA;&lt;p&gt;洗手、洗澡的时候热水来得很快，基本上2s到达。刷牙的时候用来刺开牙膏口覆盖物的东西的刺比很多酒店要锋利所以很容易刺开。&lt;/p&gt;&#xA;&lt;p&gt;如果让我说缺点，大概就是有些房间会有味（这是我妈说的），所以我们一连换了一堆房间：（按时间顺序）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;3202&lt;/li&gt;&#xA;&lt;li&gt;3207&lt;/li&gt;&#xA;&lt;li&gt;3239&lt;/li&gt;&#xA;&lt;li&gt;3502（现在）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;不要问为啥楼层这么高，酒店大堂在36F，客房32F~35F。&lt;/p&gt;&#xA;&lt;p&gt;其他的内容之后会补充。&lt;/p&gt;&#xA;&lt;h2 id=&#34;我们组为什么叫珠江三角洲&#34;&gt;我们组为什么叫“珠江三角洲”？&lt;/h2&gt;&#xA;&lt;p&gt;这个词是我在遍历全国江河的时候偶然发现的，这五个字分别对应我们组的一个人：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;珠：朱熠辰，不解释&lt;/li&gt;&#xA;&lt;li&gt;江：我，不解释&lt;/li&gt;&#xA;&lt;li&gt;三：高煜涵，因为铝是+3价的（by 陈王喆）&lt;/li&gt;&#xA;&lt;li&gt;角：陈王喆，吉吉玉足&lt;/li&gt;&#xA;&lt;li&gt;洲：王若凡，不解释&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这个称呼会用在我的很多文章中，若无特殊说明，“珠江三角洲”都是指的我们组。&lt;/p&gt;&#xA;&lt;h2 id=&#34;关于各种标准评分公式&#34;&gt;关于各种“标准评分公式”&lt;/h2&gt;&#xA;&lt;h3 id=&#34;标准距离公式sdfstandard-distance-formula&#34;&gt;标准距离公式（SDF，Standard Distance Formula）&lt;/h3&gt;&#xA;&lt;p&gt;该公式原创于2024年10月。&lt;/p&gt;&#xA;&lt;p&gt;本公式专门为了2024年11月18日（不含）以前的网格形座位而作。&lt;/p&gt;&#xA;&lt;p&gt;对于两个人，在按这个公式计算的时候，需要将两人的横向距离不变，纵向距离乘 $2$，之后按照欧几里得距离（即直线距离）公式计算。&lt;/p&gt;&#xA;&lt;p&gt;比如一个人A在 $2$ 排 $4$ 列，一个人B在 $4$ 排 $5$ 列，就是这样：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  1 2 3 4 5&#xD;&#xA;1          &#xD;&#xA;2       A  &#xD;&#xA;3          &#xD;&#xA;4         B&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那么他们的横向距离就是 $1$，纵向距离就是 $2$，但需要乘 $2$，所以就是 $4$。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【村新晚报】2025W02</title>
      <link>https://qjwh.github.io/posts/cxep/2025w02/</link>
      <pubDate>Sun, 09 Feb 2025 22:30:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/cxep/2025w02/</guid>
      <description>&lt;h2 id=&#34;cbs-122版本即将于下学期发布看看有哪些更新&#34;&gt;CBS 12.2版本即将于下学期发布！看看有哪些更新&lt;/h2&gt;&#xA;&lt;p&gt;在下个学期将会正式上线对于女生的玩梗保护（男生在之前的版本中就已经有了），目前已经验证了刘思源能够启用玩梗保护，对周馨姌的玩梗保护则正在启用中。&lt;/p&gt;&#xA;&lt;p&gt;同时将会对活跃好友的数据库进行重点维护，以防遗忘或混淆等问题。&lt;/p&gt;&#xA;&lt;p&gt;从12.2版本起，将会正式执行 $10 \sim 30$ 分钟检查言论的程序，每过一段时间我将会对所有与活跃好友的交流记录进行审查以防出现不合理言论。&lt;/p&gt;&#xA;&lt;h2 id=&#34;下学期将会表演音乐课节目bpo目前未定具体歌曲&#34;&gt;下学期将会表演音乐课节目？BPO：目前未定具体歌曲&lt;/h2&gt;&#xA;&lt;p&gt;在下学期的第二节音乐课我将会表演节目，但截至目前，我对于演唱歌曲仍然在决定中。&lt;/p&gt;&#xA;&lt;p&gt;该问题的结果可能需要等到开学后才能决定，请耐心等待之后的村新晚报给您回答。&lt;/p&gt;&#xA;&lt;h2 id=&#34;翻译服务关停bpo属实没有受益者了&#34;&gt;翻译服务关停？BPO：属实，没有受益者了&lt;/h2&gt;&#xA;&lt;p&gt;在wfb也装了插件后，我已经确认的没有任何人会看我的翻译了。&lt;/p&gt;&#xA;&lt;p&gt;所以在2025年2月9日，我正式决定关停翻译服务。&lt;/p&gt;&#xA;&lt;p&gt;从此之后，无论是什么比赛，翻译图片都不会发到QQ群内，若有需要请@我后我才会发。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【娱乐】炒饭每日小测验食用指南</title>
      <link>https://qjwh.github.io/posts/play/xiaoce_fun_daily/</link>
      <pubDate>Sun, 09 Feb 2025 19:38:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/play/xiaoce_fun_daily/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://xiaoce.fun/daily&#34;&gt;网址&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;每天北京时间0点整会更新所有测验。&lt;/p&gt;&#xA;&lt;p&gt;这里只说部分，其他的自行摸索。&lt;/p&gt;&#xA;&lt;h2 id=&#34;猜城猜城3d猜国猜旗天眼乡音城景&#34;&gt;猜城/猜城3D/猜国/猜旗/天眼/乡音/城景&lt;/h2&gt;&#xA;&lt;h3 id=&#34;线索&#34;&gt;线索&lt;/h3&gt;&#xA;&lt;p&gt;会给你关于这个行政区/国家的信息（如果是猜旗则随着你的猜测会逐步揭开）。&lt;/p&gt;&#xA;&lt;p&gt;你有 $6$ 次机会去猜，输入方式是类似于查找然后点击的方式（可以自己试试就知道是啥意思了）。&lt;/p&gt;&#xA;&lt;h3 id=&#34;判题&#34;&gt;判题&lt;/h3&gt;&#xA;&lt;p&gt;每次猜完后会告诉你答案在你猜的答案的（大致）哪个方位（八方向），以及距离是多少。&lt;/p&gt;&#xA;&lt;p&gt;天眼不会告诉你方位，只会告诉你距离，所以非常难猜，没有足够实力不要去挑战。&lt;/p&gt;&#xA;&lt;p&gt;不用管后面的百分比，这个是接近程度，按照距离除以一个很大的数去计算。&lt;/p&gt;&#xA;&lt;p&gt;一旦猜对则游戏结束。&lt;/p&gt;&#xA;&lt;h2 id=&#34;填省填国填歌&#34;&gt;填省/填国/填歌&lt;/h2&gt;&#xA;&lt;h3 id=&#34;线索-1&#34;&gt;线索&lt;/h3&gt;&#xA;&lt;p&gt;给你一个表格，表头有限制条件。&lt;/p&gt;&#xA;&lt;h3 id=&#34;判题-1&#34;&gt;判题&lt;/h3&gt;&#xA;&lt;p&gt;需要在表格内每一个方格填入数据库内同时满足行、列表头上的条件的元素。&lt;/p&gt;&#xA;&lt;p&gt;尝试机会有限，看最上面的生命值。&lt;/p&gt;&#xA;&lt;p&gt;填完则游戏结束。&lt;/p&gt;&#xA;&lt;h2 id=&#34;猜word&#34;&gt;猜Word&lt;/h2&gt;&#xA;&lt;h3 id=&#34;线索-2&#34;&gt;线索&lt;/h3&gt;&#xA;&lt;p&gt;跟Wordle一模一样。&lt;/p&gt;&#xA;&lt;h3 id=&#34;判题-2&#34;&gt;判题&lt;/h3&gt;&#xA;&lt;p&gt;跟阴阳小游戏很像，但不同的是可以告诉你每个位置是匹配还是错位。&lt;/p&gt;&#xA;&lt;p&gt;匹配显示为绿色，错位则是黄色，没有则是灰色。&lt;/p&gt;&#xA;&lt;h2 id=&#34;歌词诗文&#34;&gt;歌词/诗文&lt;/h2&gt;&#xA;&lt;h3 id=&#34;线索-3&#34;&gt;线索&lt;/h3&gt;&#xA;&lt;p&gt;一开始所有格子都是黑色的状态。&lt;/p&gt;&#xA;&lt;p&gt;你有无限次机会，每次可以输入一个字，然后这个字在这首歌（包括歌名、歌手、歌词）或诗（包括诗名、作者、内容）内出现的所有位置都会揭开。&lt;/p&gt;&#xA;&lt;h3 id=&#34;判题-3&#34;&gt;判题&lt;/h3&gt;&#xA;&lt;p&gt;如果猜的字没有出现，则会提示“未出现”并将该字以红色背景显示在最底下。&lt;/p&gt;&#xA;&lt;p&gt;如果猜过，则会提示“猜过”并不执行任何操作。&lt;/p&gt;&#xA;&lt;p&gt;将歌名或诗名完全揭开即可。&lt;/p&gt;&#xA;&lt;h2 id=&#34;连句&#34;&gt;连句&lt;/h2&gt;&#xA;&lt;h3 id=&#34;规则&#34;&gt;规则&lt;/h3&gt;&#xA;&lt;p&gt;给你一个表格，你要在里面找到固定数量（可以看最底下）的诗句或者歌词。&lt;/p&gt;&#xA;&lt;p&gt;可以通过八方向的一条链表示该诗句，连接的时候可以交叉，可以自己玩一下。&lt;/p&gt;&#xA;&lt;p&gt;每个字只能使用一次。&lt;/p&gt;&#xA;&lt;h3 id=&#34;判题-4&#34;&gt;判题&lt;/h3&gt;&#xA;&lt;p&gt;尝试机会有限，看最上面的生命值。&lt;/p&gt;&#xA;&lt;p&gt;如果连句成功则会标记为绿色，并不能再选。&lt;/p&gt;&#xA;&lt;p&gt;全部为绿色则游戏结束。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【娱乐】交流必备 florr中那些特殊的简写或别称</title>
      <link>https://qjwh.github.io/posts/play/florr_simple_name/</link>
      <pubDate>Sun, 09 Feb 2025 17:05:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/play/florr_simple_name/</guid>
      <description>&lt;p&gt;更新中……&lt;/p&gt;&#xA;&lt;h2 id=&#34;稀有度&#34;&gt;稀有度&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Common：绿&lt;/li&gt;&#xA;&lt;li&gt;Unusual：un/黄&lt;/li&gt;&#xA;&lt;li&gt;Rare：蓝&lt;/li&gt;&#xA;&lt;li&gt;Epic：紫&lt;/li&gt;&#xA;&lt;li&gt;Legendary：l/红&lt;/li&gt;&#xA;&lt;li&gt;Mythic：m/青&lt;/li&gt;&#xA;&lt;li&gt;Ultra：u/ul/粉&lt;/li&gt;&#xA;&lt;li&gt;Super：s/书青&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;合成&#34;&gt;合成&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;合成Mythic：合青&lt;/li&gt;&#xA;&lt;li&gt;合成Ultra：合粉/河粉&lt;/li&gt;&#xA;&lt;li&gt;合成Super：合苏（su）&lt;/li&gt;&#xA;&lt;li&gt;合成Ultra并失败：冒青烟&lt;/li&gt;&#xA;&lt;li&gt;合成Super并失败：冒粉烟&lt;/li&gt;&#xA;&lt;li&gt;用x个花瓣合成并成功：x=1（如5=1）&lt;/li&gt;&#xA;&lt;li&gt;用x个花瓣合成并失败：-数字（如-2，但通常此处x=5）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;花瓣&#34;&gt;花瓣&lt;/h2&gt;&#xA;&lt;p&gt;默认可以叫花瓣的英文名和大家普遍公认的中文名。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Ant Egg：agg/egg&lt;/li&gt;&#xA;&lt;li&gt;Antennae：ante/触&lt;/li&gt;&#xA;&lt;li&gt;Basil：比勒（一般不叫它罗勒）&lt;/li&gt;&#xA;&lt;li&gt;Beetle Egg：bgg&lt;/li&gt;&#xA;&lt;li&gt;Bone：骨/装&lt;/li&gt;&#xA;&lt;li&gt;Bubble：泡&lt;/li&gt;&#xA;&lt;li&gt;Claw：头发（一般不叫他爪子/蟹爪）&lt;/li&gt;&#xA;&lt;li&gt;Dandelion：dande&lt;/li&gt;&#xA;&lt;li&gt;Dice：色（shǎi）&lt;/li&gt;&#xA;&lt;li&gt;Faster：罚&lt;/li&gt;&#xA;&lt;li&gt;Iris：毒药&lt;/li&gt;&#xA;&lt;li&gt;Lightning：lāi&lt;/li&gt;&#xA;&lt;li&gt;Magic Eye：me/魔眼&lt;/li&gt;&#xA;&lt;li&gt;Magnet：mag&lt;/li&gt;&#xA;&lt;li&gt;Mana Orb：orb（拼写式读法）&lt;/li&gt;&#xA;&lt;li&gt;Pincer：品色/拼刺儿&lt;/li&gt;&#xA;&lt;li&gt;Powder：pow&lt;/li&gt;&#xA;&lt;li&gt;Rice：米&lt;/li&gt;&#xA;&lt;li&gt;Shovel：铲&lt;/li&gt;&#xA;&lt;li&gt;Sponge：海&lt;/li&gt;&#xA;&lt;li&gt;Third Eye：te/三眼&lt;/li&gt;&#xA;&lt;li&gt;Uranium：uran&lt;/li&gt;&#xA;&lt;li&gt;Wing：羽毛&lt;/li&gt;&#xA;&lt;li&gt;Yggdrasil：ygg（一般不叫它世界树）&lt;/li&gt;&#xA;&lt;li&gt;Yucca：于夹（一般不叫它丝兰）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;生物&#34;&gt;生物&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Queen Ant：queen&lt;/li&gt;&#xA;&lt;li&gt;Starfish：兴（xìng）禹（yú）&lt;/li&gt;&#xA;&lt;li&gt;黄色瓢虫：shiny&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>2-SAT算法</title>
      <link>https://qjwh.github.io/posts/aln/2sat/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/2sat/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;&#xD;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-前言&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 前言&lt;/h2&gt;&#xA;&lt;p&gt;2-SAT中的SAT是适定性（Satisfiability）问题的简称，一般形式为 $k$ - 适定性问题，简称 $k$ - SAT，但由于 $k&amp;gt;2$ 时问题为NP完全问题（只有指数级别复杂度的解法，或者多项式级别复杂度的&lt;strong&gt;相似&lt;/strong&gt;解法），而 $k=1$ 时都不用解了 &lt;del&gt;（废话）&lt;/del&gt; ，所以下面全部考虑 $k=2$ 的情况。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-定义&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义&lt;/h2&gt;&#xA;&lt;p&gt;2-SAT问题简单来说就是，有 $n$ 个集合，每个集合包含两个元素（集合 $i$ 包含元素 $2i-1$ 和 $2i$，但其实编号是无关紧要的，任意都行），你必须要在&lt;strong&gt;每个&lt;/strong&gt;集合里分别选择&lt;strong&gt;刚好&lt;/strong&gt;一个元素，但某些元素之间可能有矛盾，即这两个元素不能在一种方案里被同时选择，问你是否有解，报告出来，如果有解，输出一种方案（可能不用输出）。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-题目&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题目&lt;/h2&gt;&#xA;&lt;p&gt;看上面的定义可能有点难懂，这里举个题目。&lt;/p&gt;&#xA;&lt;p&gt;有一场宴会，这场宴会只有 $n$ 对幸运夫妻可以参加，每对夫妻里只能选择&lt;strong&gt;刚好&lt;/strong&gt;一个人去参加这场宴会。&lt;/p&gt;&#xA;&lt;p&gt;但部分人之间可能有矛盾，会给出所有有矛盾的两人编号。&lt;/p&gt;&#xA;&lt;p&gt;问你，是否可以构造一种合法方案，如果不行，报告无解，否则输出一种方案。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-解法&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解法&lt;/h2&gt;&#xA;&lt;p&gt;（下面统一默认要解决的是实际问题，不是定义里的问题）&lt;/p&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-定义点边&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义点、边&lt;/h3&gt;&#xA;&lt;p&gt;我们考虑把夫妻编个名字：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一对夫妻：A男、A女&lt;/li&gt;&#xA;&lt;li&gt;第二对夫妻：B男、B女&lt;/li&gt;&#xA;&lt;li&gt;第三对夫妻：C男、C女&lt;/li&gt;&#xA;&lt;li&gt;以此类推&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;然后，我们考虑建图。&lt;/p&gt;&#xA;&lt;p&gt;但这个建图就要用到一点思维了。&lt;/p&gt;&#xA;&lt;p&gt;我们不以其他的定义定义点，我们就把一个点当做一个&lt;strong&gt;现实&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;比如：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$1$ 号点代表第一对夫妻是A男参与宴会，$2$ 号点代表A女参与宴会&lt;/li&gt;&#xA;&lt;li&gt;$3$ 号点代表第二对夫妻是B男参与宴会，$4$ 号点代表B女参与宴会&lt;/li&gt;&#xA;&lt;li&gt;$5$ 号点代表第三对夫妻是C男参与宴会，$6$ 号点代表C女参与宴会&lt;/li&gt;&#xA;&lt;li&gt;以此类推&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;边的定义也很难思考出：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;一条&lt;strong&gt;有向边&lt;/strong&gt; $u \to v$，代表现实 $u$ &lt;strong&gt;满足&lt;/strong&gt;了，现实 $v$ 也要&lt;strong&gt;满足&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;text-stylecolorrgb0150136-举个例子&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 举个例子&lt;/h4&gt;&#xA;&lt;p&gt;所以，如果说A男和B女、C男和A女之间都有矛盾，那么就需要在：&lt;/p&gt;</description>
    </item>
    <item>
      <title>BSGS算法</title>
      <link>https://qjwh.github.io/posts/aln/bsgs/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/bsgs/</guid>
      <description>&lt;p&gt;&lt;strong&gt;basic&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;BSGS算法英文名叫“baby-step giant-step”，又称“大步小步算法”。&lt;/p&gt;&#xA;&lt;p&gt;这个算法听名字似乎是个随机化算法，但实际上是数论算法。&lt;/p&gt;&#xA;&lt;p&gt;具体地，这个算法解决的是 $a^x \equiv b \pmod{p}$ 的解，其中 $a$、$b$、$p$ 是已知的（$0 \leq a,b&amp;lt;p$，保证 $\gcd(a,p)=1$），$x$ 是要求的。&lt;/p&gt;&#xA;&lt;p&gt;这个算法甚至可以求出所有的 $x$，但为了好讲，我们先考虑如何求出是否有解，以下代码中&lt;code&gt;YES&lt;/code&gt;就代表确定有解了。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;force algorithm&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;首先，有一个暴力算法：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rep(x, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, INF)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(ksm(a, x, p) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; b)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        YES&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但这个算法是 $O(\infty)$ 的，我们考虑优化。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;optimization algorithm 1&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们考虑 $x$ 的上界，根据欧拉定理，$a^{\varphi(p)} \equiv 1 \pmod{p}$，我们就可以确定，$x$ 的上界就是 $\varphi(p)$（准确来说减 $1$ 也彳亍），因为如果 $x&amp;gt;\varphi(p)$，那么 $a^x$ 就等于 $a^{x-\varphi(p)}$，也就成为了一个循环，所以上界就是 $\varphi(p)$。&lt;/p&gt;&#xA;&lt;p&gt;由于 $\varphi(p)&amp;lt;p$，所以可以把 $p$ &lt;strong&gt;当做&lt;/strong&gt;是质数，$x$ 的上界也就是 $p-1$ 了。&lt;/p&gt;&#xA;&lt;p&gt;所以：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;rep(x, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, p &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(ksm(a, x, p) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; b)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        YES&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;optimization algorithm 2 (BSGS)&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>CDQ分治</title>
      <link>https://qjwh.github.io/posts/aln/cdq/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/cdq/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;&#xD;&#xA;&lt;p&gt;CDQ分治是一种解决三维、四维偏序的算法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-三维偏序&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 三维偏序&lt;/h2&gt;&#xA;&lt;p&gt;三维偏序问题形如：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;有 $q$ 次询问，每次询问有两种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;修改：会给定 $t$、$x$、$y$、$v$，表示在时刻 $t$，在二维坐标 $(x,y)$ 上加上权值 $v$，修改会永久改变权值 &lt;del&gt;（废话）&lt;/del&gt;。&lt;/li&gt;&#xA;&lt;li&gt;查询：会给定 $t$、$x$、$y$，表示求在时刻 $t$ 时，所有满足 $x&amp;rsquo; \leq x$，$y&amp;rsquo; \leq y$ 的二维坐标 $(x&amp;rsquo;,y&amp;rsquo;)$ 上的权值和。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$q \leq 2 \times 10^5$&lt;/li&gt;&#xA;&lt;li&gt;$t,x,y \leq 2 \times 10^5$&lt;/li&gt;&#xA;&lt;li&gt;$v \leq 10^9$&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;这种问题都有一个通用的解决方法，就是CDQ分治，接下来我们讲一下算法的原理。&lt;/p&gt;&#xA;&lt;p&gt;我们先把所有的询问离线下来，然后按时刻（第一维）升序排序，显然排序前和排序后，相同询问答案不变。&lt;/p&gt;&#xA;&lt;p&gt;接下来我们定义函数 $\text{solve}(l,r)$，代表只考虑 $l \sim r$ 内的修改，然后准确回答 $l \sim r$ 内的询问。&lt;/p&gt;&#xA;&lt;p&gt;既然是分治，我们就要构建好整个分治思路，像这道题，就这样做：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;找到 $mid$ 为区间 $[l,r]$ 的中点 $\left\lfloor \dfrac{l+r}{2} \right\rfloor$。&lt;/li&gt;&#xA;&lt;li&gt;考虑 $l \sim mid$ 内的修改对 $l \sim mid$ 内的询问的影响：递归调用 $\text{solve}(l,mid)$。&lt;/li&gt;&#xA;&lt;li&gt;考虑 $mid+1 \sim r$ 内的修改对 $mid+1 \sim r$ 内的询问的影响：递归调用 $\text{solve}(mid+1,r)$。&lt;/li&gt;&#xA;&lt;li&gt;考虑 $l \sim mid$ 内的修改对 $mid+1 \sim r$ 内的询问的影响：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;把 $l \sim mid$ 内的修改，和 $mid+1 \sim r$ 内的询问，统统存入一个数组 $b$。&lt;/li&gt;&#xA;&lt;li&gt;把 $b$ 中所有元素按 $x$ 坐标（第二维）升序排序。&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;有人对这一步的正确性有疑问，此处解释一下。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kruskal重构树</title>
      <link>https://qjwh.github.io/posts/aln/kruskalcgs/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/kruskalcgs/</guid>
      <description>&lt;p&gt;参考：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;老师讲解&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/Fighting_Peter/article/details/109149369&#34;&gt;Fighting_Peter 的文章&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;其实Kruskal重构树并不难。&lt;/p&gt;&#xA;&lt;h2 id=&#34;概览&#34;&gt;概览&lt;/h2&gt;&#xA;&lt;p&gt;首先，Kruskal重构树，顾名思义就是把整棵树重构。&lt;/p&gt;&#xA;&lt;p&gt;并且其是基于Kruskal算法的。&lt;/p&gt;&#xA;&lt;p&gt;它能解决很多问题，并且变种很多。&lt;/p&gt;&#xA;&lt;p&gt;但我们先从基础的实现说起。&lt;/p&gt;&#xA;&lt;h2 id=&#34;实现过程&#34;&gt;实现过程&lt;/h2&gt;&#xA;&lt;p&gt;我们考虑，在Kruskal算法里，我们每次会合并两个并查集集合。&lt;/p&gt;&#xA;&lt;p&gt;准确来说是在两个点 $u$、$v$ 之间加一个边权为 $w$ 的无向边。&lt;/p&gt;&#xA;&lt;p&gt;那么，我们就考虑，在重构树里，我们找到 $u$ 和 $v$ 分别所在的子树，把这两个子树的根拎出来，设为 $u&amp;rsquo;$ 和 $v&amp;rsquo;$。&lt;/p&gt;&#xA;&lt;p&gt;然后，我们就新建一个点 $w$，然后把 $u&amp;rsquo;$ 和 $v&amp;rsquo;$ 的父亲设为 $w$。&lt;/p&gt;&#xA;&lt;p&gt;此时我们就得到了另外一棵树。&lt;/p&gt;&#xA;&lt;p&gt;比如说这个例子：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/4t6kbaq1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;而在代码中，我们需要给这些方点一个别的编号，而不是以 $w$ 作为编号，否则会重，并且会炸。&lt;/p&gt;&#xA;&lt;h2 id=&#34;特性&#34;&gt;特性&lt;/h2&gt;&#xA;&lt;p&gt;我们讲一些Kruskal重构树的特性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;这棵树一定是二叉树。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;原树中的点放到重构树上一定是叶子，重构树上其他点都是原树中的边权。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;节点个数一定是 $2n-1$，且 $2n-1$ 一定是根。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果是最小生成树，那么这棵重构树一定是大根堆&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，否则是小根堆。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;原图中两个点 $u$、$v$ 之间所有路径上的边权最大值的最小值，就是该图的最小生成树重构树上，$u$ 和 $v$​ 的LCA的权值。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;em&gt;尚未想到证明方式&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于一个最小生成树上的点 $x$，其只通过（边权）不超过 $v$ 的边，能到的点集；和 $x$ 在重构树上深度最浅的、权值 $\leq v$ 的点 $y$ 的子树内（叶子）节点集合，是一样的。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这里稍微证明一下。&lt;/p&gt;&#xA;&lt;p&gt;就是我们根据上面的性质，可以发现，设后者对应集合为 $S$，那么显然 $S$ 内的点，和 $x$ 点，的LCA的权值一定不超过 $v$，显然。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lucas定理</title>
      <link>https://qjwh.github.io/posts/aln/lucas/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/lucas/</guid>
      <description>&lt;p&gt;（以下全部假设 $C_n^m$ 中的 $n$ 和 $m$ 都很大，最大能达到 $10^{18}$）&lt;/p&gt;&#xA;&lt;h2 id=&#34;lucas定理&#34;&gt;Lucas定理&lt;/h2&gt;&#xA;&lt;p&gt;Lucas定理往往用于求组合数的结果且&lt;strong&gt;模数较小&lt;/strong&gt;的题目。&lt;/p&gt;&#xA;&lt;p&gt;其实定理很简单，也很好记，$\Large C_n^m=C_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{m}{p} \rfloor} \times \color{orange} C_{n \bmod p}^{m \bmod p}$，在 $p$ 为质数的条件成立。&lt;/p&gt;&#xA;&lt;p&gt;上面之所以强调模数较小，是因为我们需要通过预处理阶乘的方式去求橙色项的值。&lt;/p&gt;&#xA;&lt;p&gt;代码实现很简单，此处略。&lt;/p&gt;&#xA;&lt;p&gt;但有个注意点，在我的代码模板里，由于求&lt;code&gt;facny&lt;/code&gt;数组是递推求出的，而不是每个分别去用&lt;code&gt;getny&lt;/code&gt;求出的，所以调用&lt;code&gt;init&lt;/code&gt;函数时，传参应该是&lt;code&gt;MOD-1&lt;/code&gt;而不是&lt;code&gt;MOD&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;exlucas定理&#34;&gt;exLucas定理&lt;/h2&gt;&#xA;&lt;p&gt;&lt;del&gt;（前方高能）&lt;/del&gt;&lt;/p&gt;&#xA;&lt;p&gt;这个定理还是解决求 $C_n^m \bmod p$ 的值的问题，$p$ 仍然很小，但&lt;strong&gt;不保证是质数&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;根据M2579的做法，我们可以考虑对 $p$ 做一个唯一分解，分解成 ${p_1}^{a_1} \times {p_2}^{a_2} \times {p_3}^{a_3} \times \dots \times {p_k}^{a_k}$。&lt;/p&gt;&#xA;&lt;p&gt;然后，分别求出 $C_n^m \bmod {p_1}^{a_1}$ 的值、$C_n^m \bmod {p_2}^{a_2}$ 的值、$C_n^m \bmod {p_3}^{a_3}$ 的值、&amp;hellip;、$C_n^m \bmod {p_k}^{a_k}$ 的值，然后就可以用CRT求出 $C_n^m \bmod p$ 的值了。&lt;/p&gt;&#xA;&lt;p&gt;在M2579内，$p$ 唯一分解后，每个 $a_i$ 都等于 $1$，所以直接用Lucas定理就可以求，但在一般的题目中，指数不一定都等于 $1$，所以才要用到exLucas定理。&lt;/p&gt;</description>
    </item>
    <item>
      <title>nth_element（未完工）</title>
      <link>https://qjwh.github.io/posts/aln/nthelement/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/nthelement/</guid>
      <description></description>
    </item>
    <item>
      <title>wqs二分</title>
      <link>https://qjwh.github.io/posts/aln/wqs/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/wqs/</guid>
      <description>&lt;p&gt;感谢&lt;a href=&#34;https://www.acwing.com/file_system/file/content/whole/index/content/5873556/&#34;&gt;这篇文章&lt;/a&gt;的作者。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;wqs二分一般解决这类问题：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;有 $n$ 个物品，你要选出恰好 $m$ 个（下称“选择物品个数限制”），可能有限制（下称“其他限制”），你要最大/小化某个权值。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;但除此之外，还有一些限制：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果我们设 $g_i$ 为选出恰好 $i$ 个时的最大/小权值，那么 $g$ 函数就应该是上凸（求最大权值）/下凹（求最小权值）的，即斜率单调递减（上凸）/递增（下凹）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;一般来说&lt;/strong&gt;，如果没有任何限制（包括选择物品个数限制和其他限制），那么答案是很好求的。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;一般来说&lt;/strong&gt;，如果没有其他限制，那么选择物品数量越多，最小权值就越大/小。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;以下是&lt;a href=&#34;https://www.luogu.com.cn/problem/P5633&#34;&gt;P5633&lt;/a&gt;的题解，顺带着讲了wqs二分的原理和应用。&lt;/p&gt;&#xA;&lt;p&gt;在原题中，我们可以以标号为 $s$ 点在最小生成树上的出度为横坐标，以这个出度对应的答案为纵坐标，画出图像：（网上粘的图，只画了部分横坐标的情况）&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.acwing.com/media/article/image/2022/06/21/58579_3af7039bf1-%E4%B8%8B%E5%87%B8%E5%A3%B3.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;显然D和E点就是最小值点。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;strong&gt;接下来就是wqs二分的重点了&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;wqs二分也是二分，那它二分什么值呢，它二分的是斜率 $mid$。&lt;/p&gt;&#xA;&lt;p&gt;具体而言，一个斜率就对应若干条平行的边，而总有一条边是完全切这个凸包的，如 $mid=-1$ 的时候，上图中被且的那个点就刚好是C点：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.acwing.com/media/article/image/2022/06/21/58579_3213b178f1-%E5%88%87%E7%BA%BF.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果我们设题目要求 $s$ 的度数要恰好为 $6$，那么 $mid=-1$ 的时候被切的那个点C的纵坐标就是答案了。&lt;/p&gt;&#xA;&lt;p&gt;但此时我们就有两个问题了：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如何求出被切的那个点的下标？&lt;/li&gt;&#xA;&lt;li&gt;就算求出了下标，那这个点的纵坐标又如何计算？&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;接下来我们来解决这两个问题。&lt;/p&gt;&#xA;&lt;p&gt;首先，这个切线肯定是所有经过某个点且斜率等于 $mid$ 的直线中截距最小的点：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;具体地，根据切线的性质，在上述例子中，经过C点的斜率等于 $mid$ 的直线（即切线），与经过D点的斜率等于 $mid$ 的直线、经过E点的斜率等于 $mid$ 的直线相比，切线的截距肯定最小，后两者的截距肯定更大。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;其次，显然，经过点 $(x,y)$ 且斜率等于 $k$ 的直线（肯定唯一），其截距一定等于 $y-kx$（$y=kx+b$，$b=y-kx$）。&lt;/p&gt;&#xA;&lt;p&gt;而在二分的&lt;code&gt;calc&lt;/code&gt;函数（此处不是&lt;code&gt;check&lt;/code&gt;函数了，&lt;code&gt;calc&lt;/code&gt;函数的返回值、返回值含义以及应用见下）中，我们已经知道了上述公式中的 $k$ 了（$k=mid$），所以我们只要让 $y-kx$ 最小、斜率为 $k$ 且经过了某个图上的点即可。&lt;/p&gt;&#xA;&lt;p&gt;考虑到上述公式中的 $x$ 未知，所以我们可以干脆把所有 $s$ 的出边的边权都减 $mid$。&lt;em&gt;（关于是加、减还是都彳亍的问题存疑）&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>一个非常重要的语法点</title>
      <link>https://qjwh.github.io/posts/aln/animportantgrammer/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/animportantgrammer/</guid>
      <description>&lt;p&gt;说一个非常重要的语法错误。&lt;/p&gt;&#xA;&lt;p&gt;如果你写这样一句话：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;v[x] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newnode();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;v&lt;/code&gt;为一个&lt;code&gt;vector&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;x&lt;/code&gt;为不越界的非负整数，且不会变化。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;newnode()&lt;/code&gt;函数内会向&lt;code&gt;vector&lt;/code&gt;内&lt;code&gt;push_back&lt;/code&gt;一个新元素，并返回加入元素（即最后一个元素）的下标。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;那么，你会发现，&lt;code&gt;v[x]&lt;/code&gt;的值并不是这样变化的：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1,2,3,4,5,6,7,...&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而是类似于这样的：（非真实输出结果，仅供参考）&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1,1,2,2,3,4,4,5,6,7,8,8,9,10,11,12,13,14,15,16,16,17,18,19,20,...&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你会发现部分情况下，&lt;code&gt;v[x]&lt;/code&gt;没有变化！&lt;/p&gt;&#xA;&lt;p&gt;这实际上是因为&lt;code&gt;vector&lt;/code&gt;的内部机制。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;会有一个&lt;code&gt;capacity&lt;/code&gt;，就是提供的内存大小。&lt;/p&gt;&#xA;&lt;p&gt;每次&lt;code&gt;push_back&lt;/code&gt;的时候，如果说加入后，不超过当前的&lt;code&gt;capacity&lt;/code&gt;，就会直接加入。&lt;/p&gt;&#xA;&lt;p&gt;否则，&lt;code&gt;vector&lt;/code&gt;会新开辟一块等于当前&lt;code&gt;capacity&lt;/code&gt;的两倍（这个在不同编辑器上是不一样的，有些可能是每次新增 $5$ 个）的新空间，并把原本的数据拷进这块新空间内。&lt;/p&gt;&#xA;&lt;p&gt;比如说现在的&lt;code&gt;vector&lt;/code&gt;是：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;内存354~357位置：3 1 2 4&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;且&lt;code&gt;capacity&lt;/code&gt;是 $4$，那么我们如果尝试&lt;code&gt;push_back&lt;/code&gt;一个 $5$，则&lt;code&gt;vector&lt;/code&gt;就会发现大于了&lt;code&gt;capacity&lt;/code&gt;，便会新开一块等于当前&lt;code&gt;capacity&lt;/code&gt;的两倍的空间：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;内存354~357位置：3 1 2 4&#xD;&#xA;内存382~389位置：&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并把当前数据拷进去：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;内存354~357位置：3 1 2 4&#xD;&#xA;内存382~389位置：3 1 2 4&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在新空间内加入 $5$：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;内存354~357位置：3 1 2 4&#xD;&#xA;内存382~389位置：3 1 2 4 5&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并把所有&lt;code&gt;v[x]&lt;/code&gt;指向的内存都改成&lt;code&gt;382~389&lt;/code&gt;这块新内存内对应的地方。&lt;/p&gt;&#xA;&lt;p&gt;不过由于C++的赋值机制，系统会先找到要赋值给的变量的指针，然后求出要赋的值，赋给以前找到的指针。&lt;em&gt;（这一步是推测，可能不准确）&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;所以就会导致把&lt;code&gt;newnode()&lt;/code&gt;的值赋给了原本的&lt;code&gt;v[x]&lt;/code&gt;，导致输出的时候访问的新&lt;code&gt;v[x]&lt;/code&gt;值出错。&lt;/p&gt;&#xA;&lt;p&gt;解决方法也很简单，把&lt;code&gt;newnode()&lt;/code&gt;用个临时变量&lt;code&gt;t&lt;/code&gt;存储，并将&lt;code&gt;v[x]&lt;/code&gt;赋值为&lt;code&gt;t&lt;/code&gt;即可。&lt;/p&gt;</description>
    </item>
    <item>
      <title>一元二次方程解法（未完工）</title>
      <link>https://qjwh.github.io/posts/aln/quadraticequation/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/quadraticequation/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;&#xD;&#xA;&lt;p&gt;在数学、编程界里，可能会经常遇到方程，而且有时候还会遇到一种特殊方程——一元二次方程。&lt;/p&gt;&#xA;&lt;p&gt;除此之外，还有含参一元二次方程，这里也会一起讲。&lt;em&gt;（待补充）&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;其实还有如二元一次方程、一元三次方程等的特殊方程，但在这里不讲。&lt;/p&gt;&#xA;&lt;h1 id=&#34;text-stylecolorrgb0150136-一元二次方程&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 一元二次方程&lt;/h1&gt;&#xA;&lt;p&gt;有人看到“一元二次方程”就不知道是啥意思，这里先说一下定义&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-定义&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义&lt;/h2&gt;&#xA;&lt;p&gt;首先，方程相信大家都见过，所以这里不写对方程的定义解释。（废话&lt;/p&gt;&#xA;&lt;p&gt;而 $x$ 元 $y$ 次方程就是这么定义的：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;这个方程&lt;strong&gt;经过化简&lt;/strong&gt;后，共有 $x$ 个未知数，且&lt;strong&gt;未知数上&lt;/strong&gt;的最大指数为 $y$ 的方程。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;如：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$3(x+1)=6x$：一元一次方程，也是最常见的方程。&lt;/li&gt;&#xA;&lt;li&gt;$3(x+1)^2=2(x+1)$：一元一次方程，因为两边可以同时除以 $x+1$ 以让指数减少 $1$。&lt;/li&gt;&#xA;&lt;li&gt;$x^2-4x+1=0$：一元二次方程，也是下面要讲的方程类型。&lt;/li&gt;&#xA;&lt;li&gt;$x^3+2x^2-1=16x$：一元三次方程，也是一种不常见的方程类型。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;讲完定义，接下来说怎么解&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-解法&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解法&lt;/h2&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-推导&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 推导&lt;/h3&gt;&#xA;&lt;p&gt;我们&lt;strong&gt;把方程一般化&lt;/strong&gt;，变成：&lt;/p&gt;&#xA;&lt;p&gt;$ax^2+bx+c=0$&lt;/p&gt;&#xA;&lt;p&gt;其中 $a$、$b$、$c$ 均为常量。&lt;/p&gt;&#xA;&lt;p&gt;然后，我们不断对方程做一些推导。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;移项&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;$ax^2+bx=-c$&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;同时除以 $a$ 常量&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;$x^2+\dfrac{b}{a}x=-\dfrac{c}{a}$&lt;/p&gt;&#xA;&lt;p&gt;这个式子很多人看了就不知道怎么继续推导了。&lt;/p&gt;&#xA;&lt;p&gt;但还是可以继续转化的。&lt;/p&gt;&#xA;&lt;p&gt;我们考虑&lt;strong&gt;配方&lt;/strong&gt;，即把式子的左/右项同时加/减/乘/除一个相同的数，然后让这个等式的左/右项变成一个数的平方的形式。&lt;/p&gt;&#xA;&lt;p&gt;这一步比较考验数感，一个结论就是，我们&lt;strong&gt;同时加上 $\left( \dfrac{b}{2a} \right)^2$ 常量&lt;/strong&gt; 即可。&lt;/p&gt;&#xA;&lt;p&gt;$x^2+\dfrac{b}{a}x+\left( \dfrac{b}{2a} \right)^2=-\dfrac{c}{a}+\left( \dfrac{b}{2a} \right)^2$&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;化简&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;$\left( x+\dfrac{b}{2a} \right)^2=\dfrac{-c}{a}+\dfrac{b^2}{4a^2}$&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;二次化简&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;$\left( x+\dfrac{b}{2a} \right)^2=\dfrac{b^2-4ac}{4a^2}$&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;同时开根号&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;$x+\dfrac{b}{2a}=\sqrt{\dfrac{b^2-4ac}{4a^2}}$&lt;/p&gt;</description>
    </item>
    <item>
      <title>中国剩余定理</title>
      <link>https://qjwh.github.io/posts/aln/crt/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/crt/</guid>
      <description>&lt;p&gt;中国剩余定理，Chinese Remainder Theorem，又称CRT，我们接下来就讲一下这个算法的原理。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;要说原理，就得从古代说起。&lt;/p&gt;&#xA;&lt;p&gt;&lt;del&gt;（你到底是在讲编程课还是在讲历史课）&lt;/del&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;del&gt;（真的是在将编程课）&lt;/del&gt;&lt;/p&gt;&#xA;&lt;p&gt;在古代，有一个问题，叫做“物不知数问题”，原文是这样的：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;有物不知其数&lt;/li&gt;&#xA;&lt;li&gt;三三数之剩二&lt;/li&gt;&#xA;&lt;li&gt;五五数之剩三&lt;/li&gt;&#xA;&lt;li&gt;七七数之剩二&lt;/li&gt;&#xA;&lt;li&gt;问物几何？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这个问题翻译过来就是问以下方程的所有正整数解：&lt;/p&gt;&#xA;&lt;p&gt;$&#xA;\begin{cases}&#xA;x \equiv 2 \pmod{3} \&#xA;x \equiv 3 \pmod{5} \&#xA;x \equiv 2 \pmod{7}&#xA;\end{cases}&#xA;$&lt;/p&gt;&#xA;&lt;p&gt;这个问题在后来有一个解了，解出来这个问题的人，编了一首诗，叫做“孙子歌诀”，原文：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;三人同行七十稀&lt;/li&gt;&#xA;&lt;li&gt;五树梅花廿一支&lt;/li&gt;&#xA;&lt;li&gt;七子团圆正半月&lt;/li&gt;&#xA;&lt;li&gt;除百零五便得知&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这个解翻译过来就是说，若设 $r_3$ 为方程中 $x$ 模 $3$ 的余数，$r_5$、$r_7$ 同理，那么所有解 $x$ 一定满足：&lt;/p&gt;&#xA;&lt;p&gt;$x \equiv r_3 \times 70+r_5 \times 21+r_7 \times 15 \pmod{105}$&lt;/p&gt;&#xA;&lt;p&gt;其中 $105$ 的实际来源是上面三个方程的模数的 $\text{lcm}$，即 $\text{lcm}(3,5,7)=3 \times 5 \times 7=105$。&lt;/p&gt;&#xA;&lt;p&gt;关于 $70$、$21$、$15$ 的来源下面再说，我们先证明一下这个解是正确的。&lt;/p&gt;&#xA;&lt;p&gt;由于 $105$ 是三个模数的 $\text{lcm}$，所以说如果 $x$ 是满足条件的，$x-105$、$x+105$ 都是满足条件的（此处暂时忽略“正整数解”的限制），显然。&lt;/p&gt;</description>
    </item>
    <item>
      <title>决策单调性</title>
      <link>https://qjwh.github.io/posts/aln/juecedandiaoxing/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/juecedandiaoxing/</guid>
      <description>&lt;h2 id=&#34;二维决策单调性&#34;&gt;二维决策单调性&lt;/h2&gt;&#xA;&lt;p&gt;对于形如 $d_{i,j}=\min\limits_{k=0}^{i-1} \Big( d_{k,j-1}+w(k+1,i) \Big)$ 的方程，我们尝试记录 $f_{i,j}$ 代表 $d_{i,j}$ 的最优转移点（$k$ 变量），如果有 $f_{i,j-1} \leq f_{i,j} \leq f_{i+1,j}$，那么就是经典的四边形不等式优化，复杂度为 $O(n^2)$，证明此处略（在&amp;quot;四边形不等式相关.md&amp;quot;里有）。&lt;/p&gt;&#xA;&lt;p&gt;但是，如果只有 $f_{i,j} \leq f_{i+1,j}$，那么就不能用四边形不等式优化了，需要用分治的方式优化。&lt;/p&gt;&#xA;&lt;p&gt;具体地，我们从小到大枚举 $j$，然后转移所有的 $d_{i,j}$。&lt;/p&gt;&#xA;&lt;p&gt;定义分治函数&lt;code&gt;dp(l,r,jl,jr)&lt;/code&gt;代表我们要转移所有的 $d_{i,j}$（$l \leq i \leq r$），并且保证所有在本次分治转移范围内的 $d_{i,j}$ 的转移点 $f_{i,j}$ 都在 $[jl,jr]$ 内。&lt;/p&gt;&#xA;&lt;p&gt;我们可以先求出 $[l,r]$ 的中点 $mid$，然后转移 $d_{mid,j}$：暴力枚举转移点 $k$（当然，要在 $[jl,jr]$ 内）进行转移，并递归&lt;code&gt;dp(l,mid-1,jl,最终转移点)&lt;/code&gt;和&lt;code&gt;dp(mid+1,r,最终转移点,jr)&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;该算法复杂度为 $O(n^2 \log n)$，证明：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;首先，枚举 $j$ 的复杂度 $O(n)$。&lt;/p&gt;&#xA;&lt;p&gt;其次，只看 $[jl,jr]$，$[jl,jr]$ 在递归的过程中就形成了个线段树的类似结构，只不过单层内可能有部分重叠位置，而且划分点（上面说的“最终转移点”）可能不是中点，不过无关紧要。&lt;/p&gt;&#xA;&lt;p&gt;然后，再看 $[l,r]$，$[l,r]$ 在递归过程中也形成了类似于线段树的结构，并且易证这个递归树深度是不会超过 $\log n$ 的。&lt;/p&gt;&#xA;&lt;p&gt;有了深度的保证，而且一层内的 $[jl,jr]$ 区间长度和最多只有 $O(n)$ 级别，所以一次分治的复杂度就是 $O(n \log n)$。&lt;/p&gt;</description>
    </item>
    <item>
      <title>判断拓扑序是否唯一</title>
      <link>https://qjwh.github.io/posts/aln/judgetopounique/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/judgetopounique/</guid>
      <description>&lt;text style=&#34;font-family:Lato,楷体&#34;&gt;&#xD;&#xA;&lt;p&gt;我们现在要解决一个问题，就如标题所说，我们要判断一个DAG的拓扑序是否唯一。&lt;/p&gt;&#xA;&lt;p&gt;以下说两种做法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-做法1推荐&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 做法1（推荐）&lt;/h2&gt;&#xA;&lt;p&gt;在拓扑排序时，我们只要每时每刻都判断一下，此时的队列大小是否大于 $1$ 即可。&lt;/p&gt;&#xA;&lt;p&gt;因为，如果队列大小大于 $1$，则选择任何一个元素都可以加入到拓扑序的最后下标，所以拓扑序不唯一。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-做法2&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 做法2&lt;/h2&gt;&#xA;&lt;p&gt;（以下是我考试时想出来的做法，思维难度较高，但整个构思过程中都没有思维跳跃）&lt;/p&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-1&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 1&lt;/h3&gt;&#xA;&lt;p&gt;首先，我们建出这个DAG，然后我们考虑，其实一个DAG唯一，有且仅当对于所有点对 $(u,v)$（$1 \leq u,v \leq n$），都满足以下两点之一：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;点 $u$ 可以到达点 $v$。&lt;/li&gt;&#xA;&lt;li&gt;点 $v$ 可以到达点 $u$。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;此处证明一下。&lt;/p&gt;&#xA;&lt;p&gt;其实，如果存在一个不满足上述条件的点对 $(u,v)$，那么整张图可能会张这样：（下面标记的 $(u,v)$ 只是其中一个）&lt;/p&gt;&#xA;&lt;p&gt;在这种情况里，我们直接把红色集合和蓝色集合里的拓扑序“交换”，变成：&lt;/p&gt;&#xA;&lt;p&gt;于是乎，就得到了另一个合法的拓扑序，证毕。&lt;/p&gt;&#xA;&lt;p&gt;关于如果满足条件，则拓扑序唯一，此处不多赘述，自行脑补。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-2&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 2&lt;/h3&gt;&#xA;&lt;p&gt;上述条件还可以继续变化，变成：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于所有点对 $(u,v)$（$1 \leq u,v \leq n$，且 $v$ 的拓扑序比 $u$ 的要大），都满足点 $u$ 可以到达点 $v$。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-3&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 3&lt;/h3&gt;&#xA;&lt;p&gt;我们考虑定义函数 $f(x)$ 代表拓扑序为 $x$ 的节点，是否能到达所有拓扑序为 $y$（$x&amp;lt;y$）的点。&lt;/p&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-4&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 4&lt;/h3&gt;&#xA;&lt;p&gt;我们考虑求 $f(x)$，我们可以枚举拓扑序为 $x$ 的节点 $u$ 的所有出点 $v$（设其拓扑序为 $y$，且排除 $y \leq x$ 的所有点）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>博弈论三种扩展题型</title>
      <link>https://qjwh.github.io/posts/aln/games/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/games/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;&#xD;&#xA;&lt;p&gt;下面是三道与博弈论相关的题目及其做法。&lt;/p&gt;&#xA;&lt;h1 id=&#34;text-stylecolorrgb0150136-题目1皮肤病&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题目1：皮肤病&lt;/h1&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-题面&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题面&lt;/h2&gt;&#xA;&lt;p&gt;（改编自《不可思议事件簿 第5册 魔法学院》，由艾教提供变体）&lt;/p&gt;&#xA;&lt;p&gt;（原题名称：加试难题）&lt;/p&gt;&#xA;&lt;p&gt;在一个学校内，共有 $100$ 个人，每个人都养了一只狗。&lt;/p&gt;&#xA;&lt;p&gt;但由于某些原因，校长确定了这 $100$ 条狗内，必然存在至少一条狗有皮肤病。&lt;/p&gt;&#xA;&lt;p&gt;现在那些学生要确定一下哪些狗有皮肤病。&lt;/p&gt;&#xA;&lt;p&gt;他们准备这样确定：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每天上午的时候，所有人看一下&lt;strong&gt;除了自己的狗之外&lt;/strong&gt;的所有狗。&lt;/li&gt;&#xA;&lt;li&gt;如果确认自己的狗病了，就在晚上敲一下宠物房内的钟。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;现在已知：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;无论谁，看那只狗，都能立刻确认它是否有皮肤病。&lt;/li&gt;&#xA;&lt;li&gt;假设皮肤病不会对狗的寿命造成影响，即所有的狗都不会死亡。&lt;/li&gt;&#xA;&lt;li&gt;皮肤病不能传染，并且忽略“人患病”造成的影响。&lt;/li&gt;&#xA;&lt;li&gt;所有人都绝顶聪明（废话&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;并且：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第 $1$ 天晚上，没有钟声响起。&lt;/li&gt;&#xA;&lt;li&gt;第 $2$ 天晚上，没有钟声响起。&lt;/li&gt;&#xA;&lt;li&gt;第 $3$ 天晚上，没有钟声响起。&lt;/li&gt;&#xA;&lt;li&gt;&amp;hellip;&lt;/li&gt;&#xA;&lt;li&gt;直到第 $10$ 天晚上，终于有钟声响起了。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;请问：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;那天晚上，共有多少人共同敲响了钟？&lt;/li&gt;&#xA;&lt;li&gt;在第 $10$ 天后，除了那些敲钟的人养的狗，是否会存在其他病了的狗？&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-答案&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 答案&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$10$ 个人&lt;/li&gt;&#xA;&lt;li&gt;不会&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-题解&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题解&lt;/h2&gt;&#xA;&lt;p&gt;我们考虑一下，如果说第 $1$ 天晚上有人敲钟，那么代表啥。&lt;/p&gt;&#xA;&lt;p&gt;我们从人的角度考虑，如果说一个人发现其他狗都是好狗（指没有皮肤病的狗），那么必然自己的狗有皮肤病 &lt;del&gt;（除了自己的，还有谁的？难不成是他自己？）&lt;/del&gt;。&lt;/p&gt;&#xA;&lt;p&gt;这种情况下，他便会去敲钟。&lt;/p&gt;&#xA;&lt;p&gt;但第 $1$ 天晚上没有钟声，所以每个人都观察到了至少 $1$ 个病狗，也就是说至少有 $2$ 个病狗。&lt;/p&gt;&#xA;&lt;p&gt;随后第 $2$ 天，如果说一个人观察到其他的狗内，只有 $1$ 个病狗，那么显然自己的狗也得有皮肤病。&lt;/p&gt;</description>
    </item>
    <item>
      <title>同余最短路</title>
      <link>https://qjwh.github.io/posts/aln/modsp/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/modsp/</guid>
      <description>&lt;text style=&#34;font-family:Lato,楷体&#34;&gt;&#xD;&#xA;&lt;p&gt;同余最短路看名字感觉很难，但其实非常简单，也好理解，先说一道题：&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-题目&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题目&lt;/h2&gt;&#xA;&lt;p&gt;原型：&lt;a href=&#34;https://www.luogu.com.cn/problem/P3403&#34;&gt;洛谷P3403 跳楼机&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;有一栋 $h$ 层的大楼（层数编号从 $1$ 到 $h$），有 $n+1$ 种移动方式：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;回到 $1$ 层&lt;/li&gt;&#xA;&lt;li&gt;向上走 $x_1 \sim x_n$ 层&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;楼层不是循环的，你无论如何都无法到达 $h+1$ 层或以上。&lt;/p&gt;&#xA;&lt;p&gt;最初你可以在任意一层（但也无关紧要），问你能到达多少个不同的楼层。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-题解&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题解&lt;/h2&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-分类&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 分类&lt;/h3&gt;&#xA;&lt;p&gt;我们按楼层模 $x_1$ 的余数分类，把楼层 $i$ 分到 $i \bmod x_1$ 类。&lt;/p&gt;&#xA;&lt;p&gt;这样分类有什么用呢？见下。&lt;/p&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-定义状态&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义状态&lt;/h3&gt;&#xA;&lt;p&gt;有了这个分类，我们可以定义状态 $d_i$（$i \in [0,x_1)$）代表不用「向上走 $x_1$ 层」操作能到达的、最小的第 $i$ 类楼层是多少。&lt;/p&gt;&#xA;&lt;p&gt;那么，由于有「向上走 $x_1$ 层」操作，所以 $d_i,d_i+x_1,d_i+2x_1,\dots$（比 $d_i$ 大或相等的第 $i$ 类楼层）都是可达的。&lt;/p&gt;&#xA;&lt;p&gt;接下来考虑转移这个状态。&lt;/p&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-转移&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 转移&lt;/h3&gt;&#xA;&lt;p&gt;其实也很好想，比如用一次「向上走 $x_2$ 层」操作，那么 $d_i$ 可以转移到 $d_{(i+x_2) \bmod x_1}$，转移代价为 $x_2$，所以：&lt;/p&gt;&#xA;&lt;p&gt;$d_{(i+x_2) \bmod x_1}=\min(d_{(i+x_2) \bmod x_1},d_i+x_2)$&lt;/p&gt;</description>
    </item>
    <item>
      <title>四边形不等式</title>
      <link>https://qjwh.github.io/posts/aln/quadrangleinequality/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/quadrangleinequality/</guid>
      <description>&lt;p&gt;（四边形不等式看标题可能觉得很难，其实比较简单）&lt;/p&gt;&#xA;&lt;p&gt;四边形不等式是一种DP优化的技巧，一般针对二维DP进行优化。&lt;/p&gt;&#xA;&lt;p&gt;在DP中，往往会有多个决策点，而其中就有一个是最优的，设 $d_{i,j}$ 的最优决策点为 $f_{i,j}$。&lt;/p&gt;&#xA;&lt;p&gt;（以下假设DP枚举决策点的复杂度为 $O(n)$，DP状态数为 $O(n^2)$）&lt;/p&gt;&#xA;&lt;p&gt;而四边形不等式就是说，如果满足 $f_{i,j-1} \leq f_{i,j} \leq f_{i+1,j}$，那么可以把DP枚举决策点的范围降至 $[f_{i,j-1},f_{i+1,j}]$，然后DP的复杂度就从 $O(n^3)$ 降到了 $O(n^2)$。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;而这个（复杂度）怎么证明呢？我们画一下 $f$ 数组的表：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/10dvj9bx.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;（此处，我们以 $i$ 为行号，以 $j$ 为列号，行、列号都从 $1$ 开始编号）&lt;/p&gt;&#xA;&lt;p&gt;然后，画几个标记：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/by8vj7bj.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;这些标记指的是，在转移 $d_{1,2}$ 的时候，转移点枚举的左右端点分别就是红箭头指向的两个数。&lt;/p&gt;&#xA;&lt;p&gt;同时，为了方便观察，此处还画了个蓝色的虚线。&lt;/p&gt;&#xA;&lt;p&gt;同理，还可以画出 $d_{2,3}$ 对应的标记：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/3kxqh955.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;以此类推：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/71kjzpi4.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;可以发现，其实这时候所有蓝线的长度（蓝线连接的两个数字的差值定义为这个蓝线的长度）之和，最多只有 $n$。&lt;/p&gt;&#xA;&lt;p&gt;而对于 $d_{1,3}$ 一“类”的标记：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/ia0bvgy6.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;可以发现，其实那些蓝线的长度之和也是最多只有 $n$。&lt;/p&gt;&#xA;&lt;p&gt;在画出所有蓝线之后：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/d9jiw70y.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;可以发现，一共就有 $n$ “类”蓝线，一“类”蓝线的长度之和最多 $n$，至此，可以证明复杂度（所有蓝线的长度之和）为 $O(n^2)$。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;接下来讲几类四边形不等式解决的经典题型：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第一类：$d_{l,r}=\min { d_{l,k}+d_{k+1,r} &lt;del&gt;|&lt;/del&gt; l \leq k \leq r }+w_{l,r}$，合并石子类。&lt;/li&gt;&#xA;&lt;li&gt;第二类：$d_{i,j}=\min { d_{k,j-1}+w_{k+1,i} &lt;del&gt;|&lt;/del&gt; 0 \leq k \leq i }$，区间分割类。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;（这两类对应的公式里的 $\min$ 也可以替换成 $\max$）&lt;/p&gt;</description>
    </item>
    <item>
      <title>基尔霍夫矩阵</title>
      <link>https://qjwh.github.io/posts/aln/kirchhoffmatrix/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/kirchhoffmatrix/</guid>
      <description>&lt;p&gt;基尔霍夫矩阵是用来求解生成树计数、求（权值）和相关题目的利器。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-0-求完全图的生成树数量prufer序列&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 0. 求完全图的生成树数量（Prufer序列）&lt;/h3&gt;&#xA;&lt;p&gt;要说基尔霍夫矩阵，就要从一道题目说起：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;给你 $n$，问 $n$ 个节点组成的无向无根树有多少种。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;这道题可以用Prufer序列去做。&lt;/p&gt;&#xA;&lt;p&gt;这里简单说一下Prufer序列的求法：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;对于一张无向无根树，重复执行以下操作直到只剩 $2$ 个或更少的点，最后得到的那个序列 $a$ 就是这棵树的Prufer序列：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;我们找到此时度为 $1$ 的节点，若有多个，找编号最小的，设找到的节点编号为 $x$。&lt;/li&gt;&#xA;&lt;li&gt;在 $a$ 的末尾添加：与 $x$ 有连边的那个唯一节点。&lt;/li&gt;&#xA;&lt;li&gt;删除 $x$。&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;Prufer序列别看求法非常简单，也没啥容易发现的性质，其实用处很大。&lt;/p&gt;&#xA;&lt;p&gt;Prufer序列满足一个性质，就是，所有无向无根树，都可以唯一地对应一个Prufer序列；所有Prufer序列都可以唯一地对应一棵树。&lt;/p&gt;&#xA;&lt;p&gt;所以，这道题就有解了，答案其实就是长为 $n-2$ 的Prufer序列有多少种。&lt;/p&gt;&#xA;&lt;p&gt;由于Prufer序列的每个元素的值都是从 $1$ 到 $n$ 的，所以答案就是 $n^{n-2}$，显然。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-11-求任意无向图的生成树数量基尔霍夫矩阵&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 1.1. 求任意无向图的生成树数量（基尔霍夫矩阵）&lt;/h3&gt;&#xA;&lt;p&gt;但如果把题目变化一下，就不能用Prufer序列去求了：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;给你一张 $n$ 个节点 $m$ 条边的无向图，问这张图的生成树有多少个。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;这题要用基尔霍夫矩阵。&lt;/p&gt;&#xA;&lt;p&gt;具体地，我们定义 $D$ 矩阵，求法：&lt;/p&gt;&#xA;&lt;p&gt;$&#xA;D_{i,j}=&#xA;\begin{cases}&#xA;0 &amp;amp; i \not= j \&#xA;\text{deg}(i) &amp;amp; i=j&#xA;\end{cases}&#xA;$&lt;/p&gt;&#xA;&lt;p&gt;其中，$\text{deg}(i)$ 代表这张图上 $i$ 的度是多少。&lt;/p&gt;</description>
    </item>
    <item>
      <title>平衡树</title>
      <link>https://qjwh.github.io/posts/aln/balancedtree/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/balancedtree/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;&#xD;&#xA;&lt;p&gt;说到平衡树，很多人的第一印象就是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;难学（知识点真多）&lt;/li&gt;&#xA;&lt;li&gt;难懂（特别是“旋转”和证明）&lt;/li&gt;&#xA;&lt;li&gt;难调（我的某个教练刚学平衡树的时候调了七个小时）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;下面我们就来从0开始讲平衡树。&lt;/p&gt;&#xA;&lt;p&gt;（注：网上大多数人说到“平衡树”默认指的是“Splay”而不是其他算法）&lt;/p&gt;&#xA;&lt;h1 id=&#34;text-stylecolorrgb0150136-定义&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义&lt;/h1&gt;&#xA;&lt;p&gt;其实平衡树（Balance Tree，简称BT）不算一种算法，而是一种统称。&lt;/p&gt;&#xA;&lt;p&gt;平衡树顾名思义就是非常平衡的树。&lt;/p&gt;&#xA;&lt;p&gt;比如说这棵树就非常不平衡：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/88bai0mt.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;而这棵树就比较平衡：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/w7w8hynq.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果说的更形式化，平衡就意味着，对于每个点，其所有子树的大小差都不超过 $1$。&lt;/p&gt;&#xA;&lt;p&gt;具体而言，对于每个点 $x$，如果我们把其所有儿子 $to$ 的子树大小都列出来，那么这个数组内最大值和最小值差不超过 $1$。&lt;/p&gt;&#xA;&lt;p&gt;而且，大多数平衡树都是二叉树，这一点是为了方便操作和设计算法。&lt;/p&gt;&#xA;&lt;h1 id=&#34;text-stylecolorrgb0150136-种类&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 种类&lt;/h1&gt;&#xA;&lt;p&gt;听完上面的定义，你就知道了，平衡树就是一类树状数据结构的统称。&lt;/p&gt;&#xA;&lt;p&gt;下面就来列举一下这类数据结构都有哪些，以及这些数据结构的简介。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-二叉搜索树binary-search-tree简称bst&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 二叉搜索树（Binary Search Tree，简称BST）&lt;/h2&gt;&#xA;&lt;p&gt;大多数平衡树的前置算法，这也就意味着，大多数的平衡树都是基于BST并进行优化、扩展后得到的算法。&lt;/p&gt;&#xA;&lt;p&gt;而BST也是线段树（Segment Tree，部分情况下会简称为ST）进行扩展后的算法。&lt;/p&gt;&#xA;&lt;p&gt;具体而言，权值线段树和BST都可以维护有序集合，但有时候只能用BST解决。&lt;/p&gt;&#xA;&lt;p&gt;BST其实就是把权值“当做”节点编号（讲的时候一般就这么讲，但写的时候不能这么写，是把权值存入该节点的结构体内）。&lt;/p&gt;&#xA;&lt;p&gt;然后对于每个点，它都有最多 $2$ 个儿子，左儿子权值 $&amp;lt;$ 当前点权值 $&amp;lt;$ 右儿子权值。&lt;/p&gt;&#xA;&lt;p&gt;这样就可以方便查找。&lt;/p&gt;&#xA;&lt;p&gt;优点：代码好写，容易讲明白&lt;/p&gt;&#xA;&lt;p&gt;缺点：解决题型少，需要写定期重构（又被称作“替罪羊树思想”），复杂度高&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-treap名字不是一个单词而是两个单词tree和heap的结合&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; Treap（名字不是一个单词，而是两个单词Tree和Heap的结合）&lt;/h2&gt;&#xA;&lt;p&gt;这个算法给每个节点都添加了一个“优先级”，并让“优先级”满足小/大根堆的性质。&lt;/p&gt;&#xA;&lt;p&gt;并且，这里还通过“旋转”操作（最头疼的地方来了）让树尽量平衡，这样会让树高稳定在 $O(\log n)$ 级别。&lt;/p&gt;&#xA;&lt;p&gt;（不过注意，在最坏情况下，复杂度会达到 $O(n)$，所以 $O(\log n)$ 只是期望）&lt;/p&gt;&#xA;&lt;p&gt;这样，复杂度就降下来了。&lt;/p&gt;&#xA;&lt;p&gt;优点：复杂度低，比较容易理解，解决题型多，且容易被识别出&lt;/p&gt;&#xA;&lt;p&gt;缺点：比较难写，细节较多，复杂度难证明&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-splay本意为张开但这里不是这个意思&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; Splay（本意为“张开”但这里不是这个意思）&lt;/h2&gt;&#xA;&lt;p&gt;这个算法对上面的“旋转”操作又做了一遍扩展，让其能够解决子串翻转问题。&lt;/p&gt;&#xA;&lt;p&gt;而且，由于它也会让整棵树尽量平衡，所以树高还是会稳定在 $O(\log n)$ 级别。&lt;/p&gt;</description>
    </item>
    <item>
      <title>整体二分</title>
      <link>https://qjwh.github.io/posts/aln/exbinarysearch/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/exbinarysearch/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;&#xD;&#xA;&lt;p&gt;整体二分类似于线段树上二分，在讲这个算法前，先引入几个问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-解决题型&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解决题型&lt;/h2&gt;&#xA;&lt;p&gt;整体二分一般解决的是如下的问题：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;给你一个【集合/序列/矩阵/树】，要求【静态/动态】维护所有【元素/区间/子矩阵/链/子树】中的第 $k$【可能每次给定】大元素，【可能强制在线】。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;下面是一堆例题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-例题1-动态查询集合第k大可离线&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 例题1 动态查询集合第k大（可离线）&lt;/h2&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-题意&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题意&lt;/h3&gt;&#xA;&lt;p&gt;让你维护一个初始为空的多重集合 $s$，并支持 $q$ 次操作，操作都是下面三种之一：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;添加一个数 $x$ 到集合 $s$ 中。&lt;/li&gt;&#xA;&lt;li&gt;在集合 $s$ 中删除一个数 $x$（保证元素存在）。&lt;/li&gt;&#xA;&lt;li&gt;查询集合第 $k$ 大（保证第 $k$ 大存在）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-数据范围&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 数据范围&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$1 \leq q \leq 2 \times 10^5$&lt;/li&gt;&#xA;&lt;li&gt;$0 \leq x \leq 10^9$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-题解&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题解&lt;/h3&gt;&#xA;&lt;p&gt;维护一个权值线段树（权值线段树其实就是一个维护值域的线段树），维护一段值域里有多少个数，每次询问在线段树上二分即可。&lt;/p&gt;&#xA;&lt;p&gt;具体地，对于线段树上某个节点对应的区间 $[l,r]$，这个节点上的值为集合中，值在 $[l,r]$ 的数的个数有多少。&lt;/p&gt;&#xA;&lt;p&gt;在询问时，我们要记录当前节点编号 $x$，$x$ 维护区间 $[l,r]$，以及要查询值在 $[l,r]$ 内的所有数的第 $k$ 大。&lt;/p&gt;&#xA;&lt;p&gt;当递归到某个状态后，我们看这个节点的左子树 $\text{lc}$ 内有多少个值，如果大于等于 $k$，则递归到左子树；否则递归到右子树，且 $k$ 减去(左子树内数的个数)。&lt;/p&gt;&#xA;&lt;p&gt;由于值域较大，权值线段树可能会爆，所以要先把所有询问离线下来，做个离散化，然后就可以把 $x$ 控制到 $q$ 级别，就不会爆了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>整除分块</title>
      <link>https://qjwh.github.io/posts/aln/divisionblock/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/divisionblock/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;&#xD;&#xA;&lt;p&gt;感谢&lt;a href=&#34;https://blog.csdn.net/qq_58207591/article/details/123883428&#34;&gt;这篇文章&lt;/a&gt;的作者&lt;/p&gt;&#xA;&lt;p&gt;整除分块主要解决求解 $\sum\limits_{i=1}^n \lfloor \frac{n}{i} \rfloor$ 的值。&lt;/p&gt;&#xA;&lt;p&gt;一看这个公式，可能毫无头绪，但画张图你就有点思路了：（$n=11$）&lt;/p&gt;&#xA;&lt;img src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/5by1ehmz.png&#34; width=&#34;65%&#34;&gt;&#xD;&#xA;&lt;p&gt;（灰色线：$y=\frac{11}{x}$，绿色点：$y=\lfloor \frac{11}{x} \rfloor$，橙色线：仅为辅助）&lt;/p&gt;&#xA;&lt;p&gt;这张图其实就是在提示我们：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;$\lfloor \frac{n}{i} \rfloor$ 的值随着 $i$ 的增长而非单调递减&lt;/li&gt;&#xA;&lt;li&gt;$\lfloor \frac{n}{i} \rfloor$ 的值往往会在一段区间内相等&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;所以，我们就有一个思路了，就是求出所有值（下面的“值”都代指的是 $\lfloor \frac{n}{i} \rfloor$）相等的极大区间集，然后就可以快速统计了。&lt;/p&gt;&#xA;&lt;p&gt;有人问，这不就是个常数级别的优化吗，怎么能叫“快速”呢？其实区间个数总是 $O(\sqrt{n})$ 级别，最多约 $2 \times \sqrt{n}$。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;证明：&lt;/p&gt;&#xA;&lt;p&gt;我们把 $i$ 分成两部分去考虑，一部分是 $i \leq \sqrt{n}$，另一部分是 $i&amp;gt;\sqrt{n}$。&lt;/p&gt;&#xA;&lt;p&gt;在第一部分内，$i$ 也就只有 $\sqrt{n}$ 种取值，$\lfloor \frac{n}{i} \rfloor$ 最多只有约 $\sqrt{n}$ 种取值。&lt;/p&gt;&#xA;&lt;p&gt;在第二部分内，$\lfloor \frac{n}{i} \rfloor$ 在 $i$ 最小时（$i=\sqrt{n}+1$）会达到最大值，约 $\sqrt{n}$；而上面说“$\lfloor \frac{n}{i} \rfloor$ 的值随着 $i$ 的增长而非单调递减”，所以易得 $\lfloor \frac{n}{i} \rfloor$ 最多也只有约 $\sqrt{n}$ 种取值。&lt;/p&gt;&#xA;&lt;p&gt;$\lfloor \frac{n}{i} \rfloor$ 的总取值种数最多只有第一、二部分的取值个数和，即 $2 \times \sqrt{n}$，证毕。&lt;/p&gt;</description>
    </item>
    <item>
      <title>斜率优化</title>
      <link>https://qjwh.github.io/posts/aln/slopeopm/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/slopeopm/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;&#xD;&#xA;&lt;p&gt;&lt;del&gt;（说是斜率优化，其实和斜率几乎没有关系）&lt;/del&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;del&gt;（e&amp;hellip;更新后确实有关系）&lt;/del&gt;&lt;/p&gt;&#xA;&lt;p&gt;其实斜率优化和决策二分栈（队列）很像，下面分几种类型来讲。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-一维斜率优化&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 一维斜率优化&lt;/h2&gt;&#xA;&lt;p&gt;针对形如 $d_i=\min\limits_{j=0}^{i-1} \big( d_j+w(j+1,i) \big)$ 的方程，而且需要满足决策单调性。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;此处重新说一下，如果我们发现一个转移点 $x$ 在 $d_i$ 的时候已经比另外一个转移点 $y$ 要更优了（$x&amp;gt;y$），那么转移点 $y$ 在后面（$d_{i+1}$ 及以后）就不可能比转移点 $x$ 要更优了，那么这个DP一定满足决策单调性，而且反过来也一样（见&amp;quot;决策单调性.md&amp;quot;）。&lt;/p&gt;&#xA;&lt;p&gt;其实证明是否满足单调性只用看：如果一个决策点 $x$ 如果在 $d_i$ 的转移中已经比决策点 $y$ 要优了，那么 $d_{i+1}$ 中是否仍然满足这个条件。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;证明了满足决策单调性后，就可以开始斜率优化了。&lt;/p&gt;&#xA;&lt;p&gt;我们首先要考虑推斜率式：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;其实斜率式就是把式子 $d_x+w(x+1,i)&amp;lt;d_y+w(y+1,i)$（$x&amp;gt;y$）不断移项、变化，直到式子左边只和 $x$、$y$ 有关，右边只和 $i$ 有关为止。&lt;/p&gt;&#xA;&lt;p&gt;此时的斜率式一般左边是个分数，而且这个分数还需要把分子和分母的下标对应：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;如果斜率式最后是像这样的：&lt;/p&gt;&#xA;&lt;p&gt;$\dfrac{d_x-d_y}{v_y-v_x}&amp;gt;-a_i$&lt;/p&gt;&#xA;&lt;p&gt;那么就不是个合法的斜率式，需要变成：&lt;/p&gt;&#xA;&lt;p&gt;$\dfrac{d_x-d_y}{v_x-v_y}&amp;lt;a_i$&lt;/p&gt;&#xA;&lt;p&gt;才是合法的。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;注意，这里说的是“合法的”，而不是“正确的”，其实最上方的斜率式也可以使用，就是不能叫“斜率式”了（斜率的公式是 $\dfrac{y_2-y_1}{x_2-x_1}$）。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;设此时的斜率式就是上面说的：&lt;/p&gt;&#xA;&lt;p&gt;$\dfrac{d_x-d_y}{v_x-v_y}&amp;lt;a_i$&lt;/p&gt;&#xA;&lt;p&gt;那么，我们就定义 $\text{slope}(y,x)=\dfrac{d_x-d_y}{v_x-v_y}$。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;有了上面函数，显然如果存在两个转移点 $x$ 和 $y$（$x&amp;gt;y$）在转移到 $d_i$ 的时候满足 $\text{slope}(x,y)&amp;lt;a_i$，那么就说明转移点 $x$ 比转移点 $y$ 更优，转移点 $y$ 在后面就不需要了。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;下面默认推出来的斜率式就是上式，并默认 $a$ 数组单调不降。&lt;/p&gt;</description>
    </item>
    <item>
      <title>树链剖分</title>
      <link>https://qjwh.github.io/posts/aln/treechaindivision/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/treechaindivision/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;&#xD;&#xA;&lt;p&gt;第一次看到树链剖分（简称树剖）可能觉得它非常的深奥，但其实树剖的原理非常简单，下面先说树剖大概的实现思路和解决题型。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-概览&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 概览&lt;/h2&gt;&#xA;&lt;p&gt;其实树剖就是把一棵树分成若干条链，使得每个点都出现在了刚好一条链上。&lt;/p&gt;&#xA;&lt;p&gt;并且，我们称在某条链上的边为“重（zhòng）边”，不在任何一条链上的边为“轻边”。&lt;/p&gt;&#xA;&lt;p&gt;然后，我们按某种规则去DFS，求出新的DFS序，然后解决对树上路径询问的问题。&lt;/p&gt;&#xA;&lt;p&gt;而且，通过合理的设计每条边的轻重，可以把复杂度控制在 $O(\log n)$ 级别。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-解决题型&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解决题型&lt;/h2&gt;&#xA;&lt;p&gt;上面也提到了，树剖就是用来解决对树上路径进行询问的问题的算法，当然也可以解决对子树询问的问题，不过属于大材小用了。&lt;/p&gt;&#xA;&lt;p&gt;此外，树剖属于工具类算法，所以往往会配合树状数组、线段树、分块等算法出现。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;我把算法分为了两类，“材料类算法”和“工具类算法”，其中：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;材料类算法可以单独考，比如：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数论&lt;/li&gt;&#xA;&lt;li&gt;推公式&lt;/li&gt;&#xA;&lt;li&gt;DP&lt;/li&gt;&#xA;&lt;li&gt;树状数组&lt;/li&gt;&#xA;&lt;li&gt;线段树&lt;/li&gt;&#xA;&lt;li&gt;&amp;hellip;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;工具类算法里面必须要套材料类算法才能考出来，比如：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;二分&lt;/li&gt;&#xA;&lt;li&gt;01分数规划（二分的一个分支）&lt;/li&gt;&#xA;&lt;li&gt;CDQ分治（需要配合树状数组）&lt;/li&gt;&#xA;&lt;li&gt;整体二分（需要配合树状数组）&lt;/li&gt;&#xA;&lt;li&gt;树剖（这里讲的）&lt;/li&gt;&#xA;&lt;li&gt;&amp;hellip;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;往往一些较难的题目，都是要用较难的材料类算法（比如DP），或者工具类算法配合材料类算法才能解决的题目。&lt;/p&gt;&#xA;&lt;p&gt;而对于后者，难度会更大一些，因为后者的关键在于&lt;strong&gt;转化&lt;/strong&gt;后使用工具类算法解决。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-算法实现&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 算法实现&lt;/h2&gt;&#xA;&lt;p&gt;下面说一下树剖的实现。&lt;/p&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-两遍dfs&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 两遍DFS&lt;/h3&gt;&#xA;&lt;p&gt;我们考虑DFS，当递归到点 $x$ 的时候，找到 $x$ 的儿子中，子树大小最大的那个儿子 $to$。&lt;/p&gt;&#xA;&lt;p&gt;然后，我们把 $x \to to$ 这条边设为重边，其他边设为轻边。&lt;/p&gt;&#xA;&lt;p&gt;得到每条边的轻重后，我们再做一遍DFS。&lt;/p&gt;&#xA;&lt;p&gt;而这一遍DFS是为了找到DFS序。&lt;/p&gt;&#xA;&lt;p&gt;而且，DFS序有一个要求，我们要先遍历有重边连接的儿子。&lt;/p&gt;&#xA;&lt;p&gt;这样的话，对于任意一条树上的链，链上所有点的DFS序连续，而且是由深度从浅到深依次递增。&lt;/p&gt;&#xA;&lt;p&gt;同时，我们还要求出，从一个点开始，不经过任何轻边，最多到哪个点。&lt;/p&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-解决询问&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解决询问&lt;/h3&gt;&#xA;&lt;p&gt;而对于一次路径上某值的询问，我们可以把这个路径拆成若干条链。&lt;/p&gt;&#xA;&lt;p&gt;可以证明链数不超过 $O(\log n)$，这一点会在下面“复杂度证明”中证明。&lt;/p&gt;&#xA;&lt;p&gt;而这些拆出的链，都是原树中的链的“子集”（一条链 $L_1$ 是另外一条链 $L_2$ 的子集，有且仅当 $L_1$ 中的点，$L_2$ 中也有，边同理）。&lt;/p&gt;&#xA;&lt;p&gt;所以，可以把一条路径，拆成最多 $O(\log n)$ 个DFS序区间。&lt;/p&gt;</description>
    </item>
    <item>
      <title>欧拉函数</title>
      <link>https://qjwh.github.io/posts/aln/eulerfunc/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/eulerfunc/</guid>
      <description>&lt;p&gt;欧拉函数记为 $\varphi$，$\varphi(n)$ 代表 $1 \sim n$ 内与 $n$ 互质的数的个数。&lt;/p&gt;&#xA;&lt;p&gt;欧拉函数有两种求法，下面分别说：&lt;/p&gt;&#xA;&lt;h3 id=&#34;直接求&#34;&gt;直接求&lt;/h3&gt;&#xA;&lt;p&gt;我们设 $p$ 为 $n$ 的质因子集合（非可重集），那么 $\varphi(n)=n \times \prod\limits_{x \in p} \left( \dfrac{x-1}{x} \right)$，原理：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;我们设 $s$ 为目前与 $n$ 互质的数的集合，初始为 ${ 1,2,\dots,n }$。&lt;/p&gt;&#xA;&lt;p&gt;每次遍历到一个 $p$ 中的数 $x$，就会筛掉这个集合中 $\dfrac{1}{x}$ 的数，即那些是 $x$ 的倍数的数，由于 $p$ 是去重后的质因子集合，所以当前集合的大小总是 $x$ 的倍数。&lt;/p&gt;&#xA;&lt;p&gt;所以这个做法就能证明了，每乘一次 $\dfrac{x-1}{x}$，都相当于筛掉当前集合内 $\dfrac{1}{x}$ 的数，集合大小动态维护。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;模板代码：（代码中的 $p$ 数组是提前筛出来的质数集合，$ind$ 为其大小）&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LL &lt;span style=&#34;color:#a6e22e&#34;&gt;phi&lt;/span&gt;(LL n){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(n &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    LL ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    rep(i, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, ind){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(n &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; p[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ret &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; ret &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; p[i], n &lt;span style=&#34;color:#f92672&#34;&gt;/=&lt;/span&gt; p[i];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(n &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; p[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) n &lt;span style=&#34;color:#f92672&#34;&gt;/=&lt;/span&gt; p[i];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) ret &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ret &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; ret &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; n;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ret;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;通过线性筛预处理&#34;&gt;通过线性筛预处理&lt;/h3&gt;&#xA;&lt;p&gt;线性筛模板：&lt;/p&gt;</description>
    </item>
    <item>
      <title>点分治</title>
      <link>https://qjwh.github.io/posts/aln/dfz/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/dfz/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;&#xD;&#xA;&lt;p&gt;点分治和树剖有一个相同点，就是算法都是从暴力经过一小步优化而来，但就是这一小步，让算法复杂度有了质的飞跃。&lt;/p&gt;&#xA;&lt;p&gt;下面来讲一下这个算法的原理。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-概览&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 概览&lt;/h2&gt;&#xA;&lt;p&gt;其实“点分治”也是一个名不副实的算法，看完下面的讲述你就会发现这个算法根“分治”几乎无关。&lt;/p&gt;&#xA;&lt;p&gt;点分治是专门解决树上路径统计的一种算法（树剖则是解决对树上路径的判断的算法）。&lt;/p&gt;&#xA;&lt;p&gt;点分治的思想很朴素，就是DFS一下 $\text{lca}$ 的节点编号 $x$，然后统计 $\text{lca}$ 值刚好为 $x$ 的、满足题目条件的路径的数量，并累加到答案。&lt;/p&gt;&#xA;&lt;p&gt;但直接进行统计还是炸裂的，点分治则是对这种统计方式做了一步优化&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-解决题型&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解决题型&lt;/h2&gt;&#xA;&lt;p&gt;上面说了，「点分治是专门解决树上路径统计的一种算法」，但并不是所有的树上路径统计都可以用点分治解决。&lt;/p&gt;&#xA;&lt;p&gt;其实看完下面的实现，你就能知道它解决什么类问题，不过这里还是说一下。&lt;/p&gt;&#xA;&lt;p&gt;就是首先，这个条件是形如“总和比某个值低”、“总和是某个值的倍数”等“可累加”的条件。&lt;/p&gt;&#xA;&lt;p&gt;其中“可累加”指的是，如果知道了 $A$ 部分的某个值，和 $B$ 部分的某个值，那么 $A$ 和 $B$ 部分合并后的部分是否合法也一定知道。&lt;/p&gt;&#xA;&lt;p&gt;但其他的条件目前还没有太明确，得自己去总结。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-算法实现&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 算法实现&lt;/h2&gt;&#xA;&lt;p&gt;下面说一下点分治的实现。&lt;/p&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-大体思路&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 大体思路&lt;/h3&gt;&#xA;&lt;p&gt;我们拿“路径长度（路径上的边的边权之和）刚好为 $k$”问题举例。&lt;/p&gt;&#xA;&lt;p&gt;注：原题链接&lt;a href=&#34;https://www.luogu.com.cn/problem/P3806&#34;&gt;P3806&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;就是我们考虑，当DFS到某个点 $x$ 的时候，就如上所说，设 $x$ 为 $\text{lca}$ 值。&lt;/p&gt;&#xA;&lt;p&gt;然后，我们按顺序遍历所有子节点 $to$。&lt;/p&gt;&#xA;&lt;p&gt;由于只要两个点 $y$、$z$ 满足 $y$ 和 $z$ 分别在 $x$ 的两个不同儿子及其子树内，那么 $\text{lca}(y,z)=x$。&lt;/p&gt;&#xA;&lt;p&gt;并且所有满足条件 $\text{lca}(y,z)=x$ 的对 $(y,z)$ 只有满足上述条件的对。&lt;/p&gt;&#xA;&lt;p&gt;所以，我们可以通过（另一种）DFS（方式）求出 $to$ 到 ( 所有 $to$ 及其子树内的点 ) 之间的距离（加上 $x \to to$ 的边权）的集合 $T$。&lt;/p&gt;</description>
    </item>
    <item>
      <title>生成随机数（未完工）</title>
      <link>https://qjwh.github.io/posts/aln/genrandomnumber/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/genrandomnumber/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/LU_ZHAO/article/details/104305240&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;引用头文件（常用）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//生成随机数、设定随机数种子&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;ctime&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//生成随机数种子（1）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//生成随机数种子（2）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//等待（sleep(...)或usleep(...)），该头文件现在不常用&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;随机种子&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;srand(time(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt; clock());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;注：随机种子为&lt;code&gt;time(0) ^ clock()&lt;/code&gt;，这个随机种子可以再毫秒级别内生成（大概率）不同的随机种子。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;取 $[l,r]$ 内的随机数&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#define random(l, r) (rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l))&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;注：&lt;code&gt;rand&lt;/code&gt;函数只能生成 $[1,32767]$ 内的随机数（见宏&lt;code&gt;RAND_MAX&lt;/code&gt;），大概只能生成位数 $\leq 5$ 的随机数；测试程序：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;LL ma &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(LL i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;){&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    srand(time(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt; clock());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    LL t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rand();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; t &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ma &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(ma, t);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    usleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;10000&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; ma &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以此处引用一个新方法：&lt;code&gt;mt19937&lt;/code&gt;（2022/12/24：现在开始使用&lt;code&gt;mt19937_64&lt;/code&gt;了，它可以生成 $[1,2^{64})$ 内的随机数，大一倍）。&lt;/p&gt;&#xA;&lt;p&gt;其实它的语法和&lt;code&gt;rand&lt;/code&gt;的语法差不多 &lt;del&gt;（才怪）&lt;/del&gt;，是这样的：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;引用头文件（常用）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;random&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//生成随机数、设定随机数种子&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;ctime&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//生成随机数种子（1）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//生成随机数种子（2）&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//等待（sleep(...)或usleep(...)），该头文件现在不常用&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;随机种子&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mt19937 &lt;span style=&#34;color:#a6e22e&#34;&gt;_rand&lt;/span&gt;(time(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt; clock());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注：这个随机种子也可以再毫秒级别内生成（大概率）不同的随机种子&lt;/p&gt;</description>
    </item>
    <item>
      <title>类欧几里得算法</title>
      <link>https://qjwh.github.io/posts/aln/similargcd/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/similargcd/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;&#xD;&#xA;&lt;p&gt;来源：&lt;a href=&#34;https://atcoder.jp/contests/abc372/tasks/abc372_g&#34;&gt;ABC372G&lt;/a&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc372/editorial/10988&#34;&gt;官方题解&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;贡献：&lt;a href=&#34;https://oi-wiki.org/math/number-theory/euclidean&#34;&gt;OI Wiki&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;这个算法确实挺妙的，所以我就写个笔记。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-定义&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义&lt;/h2&gt;&#xA;&lt;p&gt;这个算法需要用到一个函数：&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;f(a,b,c,n)=\sum\limits_{i=0}^n \left\lfloor \dfrac{\color{red}a\color{default}i+\color{blue}b\color{default}}{\color{green}c\color{default}} \right\rfloor&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;在下面参数 $a$、$b$、$c$ 都会用三种颜色标出，以便于区分。&lt;/p&gt;&#xA;&lt;p&gt;因为 $a$、$b$、$c$、$n$ 都很大，所以我们没法直接暴力求。&lt;/p&gt;&#xA;&lt;p&gt;数论分块显然也不彳亍。&lt;/p&gt;&#xA;&lt;p&gt;所以我们只能另辟蹊径了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-求值&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 求值&lt;/h2&gt;&#xA;&lt;p&gt;咱从简单到复杂走。&lt;/p&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-1&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 1&lt;/h3&gt;&#xA;&lt;p&gt;首先，我们可以知道：&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;\begin{aligned}&#xA;f(a,b,c,n)&amp;amp;=\sum\limits_{i=0}^n \left\lfloor \dfrac{\color{red}a\color{default}i+\color{blue}b\color{default}}{\color{green}c\color{default}} \right\rfloor \&#xA;&amp;amp;=\sum\limits_{i=0}^n \left\lfloor \dfrac{(\lfloor \frac{a}{c} \rfloor c + a \bmod c)i+(\lfloor \frac{b}{c} \rfloor c + b \bmod c)}{c} \right\rfloor \&#xA;&amp;amp;=\sum\limits_{i=0}^n \left\lfloor \dfrac{\lfloor \frac{a}{c} \rfloor c \cdot i + a \bmod c \cdot i+\lfloor \frac{b}{c} \rfloor c + b \bmod c}{c} \right\rfloor \&#xA;&amp;amp;=\sum\limits_{i=0}^n \left( \left\lfloor \frac{a}{c} \right\rfloor i + \left\lfloor \frac{b}{c} \right\rfloor + \left\lfloor \dfrac{a \bmod c \cdot i+b \bmod c}{c} \right\rfloor \right) \&#xA;&amp;amp;=\dfrac{n(n+1)}{2} \left\lfloor \frac{a}{c} \right\rfloor + (n+1) \left\lfloor \frac{b}{c} \right\rfloor + \sum\limits_{i=0}^n \left\lfloor \dfrac{\color{red}a \bmod c\color{default} \cdot i+\color{blue}b \bmod c\color{default}}{\color{green}c\color{default}} \right\rfloor \&#xA;&amp;amp;=\dfrac{n(n+1)}{2} \left\lfloor \frac{a}{c} \right\rfloor + (n+1) \left\lfloor \frac{b}{c} \right\rfloor + f(a \bmod c,b \bmod c,c,n) \&#xA;\end{aligned}&#xA;$$&lt;/p&gt;</description>
    </item>
    <item>
      <title>组合数学（待补充）</title>
      <link>https://qjwh.github.io/posts/aln/c/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/c/</guid>
      <description>&lt;text style=&#34;font-family:Lato,楷体&#34;&gt;&#xD;&#xA;&lt;p&gt;有人问，组合数学不是就一些简单的公式吗？不是的，其实组合数学是数学中的一个非常庞大的分支，接下来就举&lt;strong&gt;一些&lt;/strong&gt;例子。&lt;em&gt;（更新中）&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文主要讲各种数据范围下，求组合数的方式；以及球盒模型各种情况下的公式；最后是一些球盒模型的扩展情况。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;#%E7%90%83%E7%9B%92%E6%A8%A1%E5%9E%8B%E4%B8%BB%E8%A6%81%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93&#34;&gt;转到：球盒模型公式&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;#%E7%90%83%E7%9B%92%E6%A8%A1%E5%9E%8B%E6%89%A9%E5%B1%95%E4%B8%BB%E8%A6%81%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93&#34;&gt;转到：球盒模型扩展公式&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;（下面部分标题里的LaTeX公式更新后炸了，就凑合着看吧）&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-求组合数&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 求组合数&lt;/h2&gt;&#xA;&lt;p&gt;以下所有范围都可以当成是以下题目的某个Subtask：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;给你 $p$，代表模数。&lt;/p&gt;&#xA;&lt;p&gt;之后会给你一个 $q$，代表询问次数。&lt;/p&gt;&#xA;&lt;p&gt;每次询问给定 $n$ 和 $m$，问 $C_n^m \bmod p$ 的值。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;下面不给定 $q$ 的范围，因为不重要。&lt;/p&gt;&#xA;&lt;p&gt;以下全部默认 $n \geq m$。&lt;/p&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-范围1nm-leq-2000p-leq-1097&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 范围1：$n,m \leq 2000,p \leq 10^9+7$&lt;/h3&gt;&#xA;&lt;p&gt;先递推预处理，然后直接回答询问即可。&lt;/p&gt;&#xA;&lt;p&gt;递推式：$C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;预处理复杂度：$O(n^2)$&lt;/li&gt;&#xA;&lt;li&gt;查询复杂度：$O(1)$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-范围2nm-leq-106p-leq-1097ptext-is-prime&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 范围2：$n,m \leq 10^6,p \leq 10^9+7,p\text{ is prime}$&lt;/h3&gt;&#xA;&lt;h4 id=&#34;text-stylecolorrgb0150136-1&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 1&lt;/h4&gt;&#xA;&lt;p&gt;先预处理阶乘，然后直接回答询问即可。&lt;/p&gt;&#xA;&lt;p&gt;回答询问式：$C_n^m=\dfrac{n!}{m!(n-m)!}$。&lt;/p&gt;&#xA;&lt;p&gt;为了节省时间复杂度，此处还可以预处理一下阶乘的逆元。&lt;/p&gt;&#xA;&lt;h4 id=&#34;text-stylecolorrgb0150136-2&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 2&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;预处理复杂度：$O(n)$&lt;/li&gt;&#xA;&lt;li&gt;查询复杂度：$O(1)$&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-范围3nm-leq-106p-leq-1097&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 范围3：$n,m \leq 10^6,p \leq 10^9+7$&lt;/h3&gt;&#xA;&lt;h4 id=&#34;text-stylecolorrgb0150136-1-1&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 1&lt;/h4&gt;&#xA;&lt;p&gt;可以发现，范围2与范围3唯一的不同就是，范围3把质数的条件去掉了。&lt;/p&gt;&#xA;&lt;p&gt;而把质数的条件后，就没法求逆元了，因为逆元可能不存在。&lt;/p&gt;&#xA;&lt;p&gt;所以我们考虑换做法。&lt;/p&gt;&#xA;&lt;h4 id=&#34;text-stylecolorrgb0150136-2-1&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 2&lt;/h4&gt;&#xA;&lt;p&gt;我们考虑把模数做个质因数分解，变成 ${p_1}^{a_1} \times {p_2}^{a_2} \times {p_3}^{a_3} \times \dots \times {p_k}^{a_k}$。&lt;/p&gt;</description>
    </item>
    <item>
      <title>网络流</title>
      <link>https://qjwh.github.io/posts/aln/flow/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/flow/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;&#xD;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-前言&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 前言&lt;/h2&gt;&#xA;&lt;p&gt;首先，网络流不是一个算法，而是一个整合包（玩MC玩的），说白了就是网络流是多个算法的统称：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;最大流&#xA;&lt;ul&gt;&#xA;&lt;li&gt;EK&lt;/li&gt;&#xA;&lt;li&gt;Dinic&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;最小割&lt;/li&gt;&#xA;&lt;li&gt;费用流&lt;/li&gt;&#xA;&lt;li&gt;&amp;hellip;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;而且，有些不常用的，可能就不会提，粘个OI Wiki的链接就不详细写了。&lt;/p&gt;&#xA;&lt;p&gt;接下来就按照这个目录挨个讲一下每个算法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-最大流&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 最大流&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;如果有哪里没有说清楚，可以看&lt;a href=&#34;https://oi-wiki.org/graph/flow/max-flow/&#34;&gt;这里&lt;/a&gt;，里面还有我没有说到的最大流类型。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;看到最大流这个名字很多人都很陌生，这里就先从定义说起。&lt;/p&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-定义&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义&lt;/h3&gt;&#xA;&lt;p&gt;还是拆词法，“网络流”就可以大致理解为“网络”上的“流”，接下来就挨个说一下这两个的定义。&lt;/p&gt;&#xA;&lt;h4 id=&#34;text-stylecolorrgb0150136-网络&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 网络&lt;/h4&gt;&#xA;&lt;p&gt;先说网络的定义。&lt;del&gt;（当然不是Internet）&lt;/del&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们在理解的时候可以认为是管道，但实际上它是一张特殊的&lt;strong&gt;有向&lt;/strong&gt;图。&lt;/p&gt;&#xA;&lt;p&gt;建设管道的必然知道，管道内流过的水，准确来说是单位时间内流过的水，必然是有上限限制的，否则管道就炸了。&lt;/p&gt;&#xA;&lt;p&gt;这里也一样，对于每条边 $x \to y$，都有一个函数 $c(x,y)$ 表示这条边的限制，又称&lt;strong&gt;容量&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;如果在图上没有这条边，则统一规定 $c(x,y)=0$。&lt;/p&gt;&#xA;&lt;p&gt;最后，还是跟最短路一样，它有一个起点和一个终点，又称&lt;strong&gt;源点&lt;/strong&gt; $S$ 和&lt;strong&gt;汇点&lt;/strong&gt; $T$（$S \not= T$）。&lt;/p&gt;&#xA;&lt;h4 id=&#34;text-stylecolorrgb0150136-流函数&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 流函数&lt;/h4&gt;&#xA;&lt;p&gt;再说流函数。&lt;/p&gt;&#xA;&lt;p&gt;流函数就是说，在真实操作中，一个单位时间内一条边 $x \to y$ 流过的水量 $f(x,y)$。&lt;/p&gt;&#xA;&lt;p&gt;这里默认保证每个单位时间内都得流过这么多。&lt;/p&gt;&#xA;&lt;p&gt;其实很好理解。&lt;/p&gt;&#xA;&lt;h4 id=&#34;text-stylecolorrgb0150136-流函数性质&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 流函数性质&lt;/h4&gt;&#xA;&lt;p&gt;顺便说一下流函数要满足的性质。&lt;/p&gt;&#xA;&lt;p&gt;首先，源点可以无限输出水，汇点可以无限输入水。&lt;/p&gt;&#xA;&lt;p&gt;接下来就是一堆性质：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对于每个 $x,y$，显然 $f(x,y) \leq c(x,y)$（&lt;strong&gt;容量限制&lt;/strong&gt;）。&lt;/li&gt;&#xA;&lt;li&gt;对于每个 $x,y$，$f(x,y)=-f(y,x)$（&lt;strong&gt;斜对称&lt;/strong&gt;）。&lt;/li&gt;&#xA;&lt;li&gt;对于每个 $x$，满足不是源点也不是汇点，$\sum\limits_{u \to x} f(u,x)=\sum\limits_{x \to v} f(x,v)$（&lt;strong&gt;流量守恒&lt;/strong&gt;）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这里说一下最后一点性质。&lt;/p&gt;</description>
    </item>
    <item>
      <title>莫队算法</title>
      <link>https://qjwh.github.io/posts/aln/modui/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/modui/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;&#xD;&#xA;&lt;h1 id=&#34;text-stylecolorrgb0150136-普通莫队算法&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 普通莫队算法&lt;/h1&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-概览&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 概览&lt;/h2&gt;&#xA;&lt;p&gt;莫队其实是分块的变化版，没有完全分块。&lt;/p&gt;&#xA;&lt;p&gt;但莫队的题目一般比分块的题目比较好看一些，其中的“好看”指的是很好看出这是个莫队/分块的题。&lt;/p&gt;&#xA;&lt;p&gt;接下来说一下莫队能解决的题型。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-解决题型&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解决题型&lt;/h2&gt;&#xA;&lt;p&gt;莫队一般解决以下问题：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;给你一些信息，和 $q$ 次询问，每次询问可以抽象为一个区间。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;而且这个问题还要满足一些条件：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可以离线&lt;/li&gt;&#xA;&lt;li&gt;不能有修改（当然带修莫队支持修改，不过普通莫队就不行了）&lt;/li&gt;&#xA;&lt;li&gt;从 $[l,r]$ 的答案可以很快转移到 $[l-1,r]$、$[l+1,r]$、$[l,r-1]$、$[l,r+1]$ 的答案&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-解决方法&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解决方法&lt;/h2&gt;&#xA;&lt;p&gt;这种题型有个解决方法。&lt;/p&gt;&#xA;&lt;p&gt;还是先从暴力说起。&lt;/p&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-暴力做法&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 暴力做法&lt;/h3&gt;&#xA;&lt;p&gt;看见这个问题的最后一个条件没？这个条件就启发我们从第一个问题的答案，暴力调整左、右端点，去得到第二个问题的答案，以此类推。&lt;/p&gt;&#xA;&lt;p&gt;这种暴力做法的复杂度一般为 $O($ 任意相邻两个问题的左、右端点差之和 $)$。&lt;/p&gt;&#xA;&lt;p&gt;而这个算法可以用一种数据卡掉：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;左、右端点的值的最大值 $n$ 调到最大，把询问次数 $q$ 也调到最大。&lt;/li&gt;&#xA;&lt;li&gt;然后的 $q$ 次询问里，交替询问 $1 \sim n$ 和 $n \sim n$。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;于是，复杂度被卡到 $O(qn)$。&lt;/p&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-一次优化&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 一次优化&lt;/h3&gt;&#xA;&lt;p&gt;这个做法的复杂度是无法接受的，所以我们考虑优化。&lt;/p&gt;&#xA;&lt;p&gt;我们不如把所有询问离线，然后考虑交换询问处理的顺序以减少复杂度。&lt;/p&gt;&#xA;&lt;p&gt;一种方式就是把左、右端点分别作为第一、二关键字，然后做排序。&lt;/p&gt;&#xA;&lt;p&gt;但这样就会被排序后所有询问的右端点一大一小的数据卡到 $O(qn)$ 的复杂度。&lt;/p&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-二次优化&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 二次优化&lt;/h3&gt;&#xA;&lt;p&gt;这样排序还是不好，还是会被卡掉，于是我们考虑变换比较函数。&lt;/p&gt;&#xA;&lt;p&gt;直接双关键字比较不好，那我们就分块后进行双关键字比较。&lt;/p&gt;&#xA;&lt;p&gt;具体地，遇到两个询问，先按左端点所属块编号从小到大排序，如果相同，则按右端点（不是所属块编号，是原本的下标）从小到大排序。&lt;/p&gt;&#xA;&lt;p&gt;这样的话，复杂度就是 $O(n \sqrt n+q \sqrt n)$ 的复杂度了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>行列式</title>
      <link>https://qjwh.github.io/posts/aln/hanglieshi/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/hanglieshi/</guid>
      <description>&lt;p&gt;要说行列式，就得先说一下矩阵（其实是方阵）的秩的定义。&lt;/p&gt;&#xA;&lt;p&gt;对于一个方阵，其秩的定义就是矩阵里线性无关的极大值。&lt;/p&gt;&#xA;&lt;p&gt;听这个定义有点难懂，这里解释一下。&lt;/p&gt;&#xA;&lt;p&gt;其实一个方阵就可以被当做是一个没有右项的方程集。&lt;/p&gt;&#xA;&lt;p&gt;而一个方阵的秩就可以当做是，这个没有右项的方程集在经过高斯消元后，非 $0$ 行的数量。&lt;/p&gt;&#xA;&lt;p&gt;有了这个定义，矩阵的秩还可以被当做是，这个没有右项的方程集中，不会被其他方程替代掉的方程数量：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;解释一下，如果方程长这样：&lt;/p&gt;&#xA;&lt;p&gt;$&#xA;\begin{cases}&#xA;-x_1+2x_2+5x_3=11 \&#xA;2x_1=8 \&#xA;x_1+2x_2+5x_3=19&#xA;\end{cases}&#xA;$&lt;/p&gt;&#xA;&lt;p&gt;那么，其实第三个方程式可以通过前两个方程式推出来，也就称作第三个方程式可以被前两个方程式替代掉。&lt;/p&gt;&#xA;&lt;p&gt;知道了“替代”的定义后，就知道了一件事，就是上面说的“会被其他方程替代掉的方程”，这些方程可以直接从方程组里去掉，而不影响最终的解。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;所以，我们就可以对奥数里的一个点做一个更简洁的解释：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;在奥数里，讲了解 $n$ 元一次方程（组）的方法。&lt;/p&gt;&#xA;&lt;p&gt;同时还说了，在这个 $n$ 元一次方程组内，如果“有用”的方程数量，刚好等于未知数的数量，或者大于未知数的数量，那么这个方程组就有唯一解。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;这一点可以被更简洁地解释为：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;这个 $n$ 元一次方程组，转化为“高斯矩阵”，并删除最后一列后（变成 $n \times n$ 的方阵），如果这个方阵的秩刚好为 $n$，那么这个方程组就有唯一解。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;然后，我们回归正题，说行列式。&lt;/p&gt;&#xA;&lt;p&gt;行列式是对于一个方阵来讲的，一个方阵有行列式有且仅当这个方程的秩刚好等于方阵的大小（行或者列）。&lt;/p&gt;&#xA;&lt;p&gt;行列式的定义此处不讲，因为：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;太复杂了&lt;/li&gt;&#xA;&lt;li&gt;（几乎）没有用处&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;行列式的计算方法是用的高斯消元。&lt;/p&gt;&#xA;&lt;p&gt;在高斯消元的思路里，提到了三种“基本行变换”：（以下全部以高斯矩阵的角度去说）&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;将一行全部乘上一个非 $0$ 实数 $x$，解不变。&lt;/li&gt;&#xA;&lt;li&gt;将一行内的所有元素对应地加上/减去另一行对应的元素乘上一个非 $0$ 实数 $x$，解不变。&lt;/li&gt;&#xA;&lt;li&gt;交换两行，解不变。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这三种基本行变换在执行前后，行列式并不是都不变的：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;将一行全部乘上一个非 $0$ 实数 $x$，行列式也会乘上 $x$。&lt;/li&gt;&#xA;&lt;li&gt;将一行内的所有元素对应地加上/减去另一行对应的元素乘上一个非 $0$ 实数 $x$，行列式不变。&lt;/li&gt;&#xA;&lt;li&gt;交换两行，行列式变号（负数变成正数，反之亦然）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;所以我们只用写一下高斯消元，然后处理一下对行列式的值的变化即可。&lt;/p&gt;&#xA;&lt;p&gt;但这儿还有一点问题，就是行列式怎么求。&lt;/p&gt;&#xA;&lt;p&gt;求法很好记，如果说当前方阵是个上三角矩阵（设方阵叫 $a$，那么 $a$ 是个上三角矩阵有且仅当对于所有的 $(i,j)$，如果满足 $i&amp;gt;j$，那么 $a_{i,j}$ 一定要等于 $0$，当然其他方格不做要求），那么这个方阵的行列式就是这个方阵中正对角线上的元素的乘积。&lt;/p&gt;</description>
    </item>
    <item>
      <title>阶和原根</title>
      <link>https://qjwh.github.io/posts/aln/orderandpr/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/orderandpr/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;&#xD;&#xA;&lt;p&gt;按照正常的思路我们都直接将算法，但这会先讲一道题，然后再讲它的定义和求法。&lt;/p&gt;&#xA;&lt;p&gt;参考：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/676549667&#34;&gt;ABC335G题解&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/ac-evil/p/12809289.html&#34;&gt;阶和原根&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-背景&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 背景&lt;/h2&gt;&#xA;&lt;p&gt;是一场&lt;a href=&#34;https://atcoder.jp/contests/abc335&#34;&gt;ABC335&lt;/a&gt;里的&lt;a href=&#34;https://atcoder.jp/contests/abc335/tasks/abc335_g&#34;&gt;G题&lt;/a&gt;，当时在赛场上大概留了一个多小时的时间，但一直都在想用&lt;a href=&#34;https://qjwh.github.io/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BSGS%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%9D%E7%89%88%EF%BC%89.md&#34;&gt;BSGS&lt;/a&gt;，但显然最后没想出来。&lt;/p&gt;&#xA;&lt;p&gt;而这题的瓶颈就在下面问题：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;对于两个数 $a,b$，是否存在一个 $x$ 使得同余方程 $a^x \equiv b \pmod p$ 有解。&lt;/p&gt;&#xA;&lt;p&gt;$a,b,p \leq 10^{13}$（原题数据范围）&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;大家看到的第一眼显然可以用&lt;a href=&#34;https://qjwh.github.io/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BSGS%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%9D%E7%89%88%EF%BC%89.md&#34;&gt;BSGS&lt;/a&gt;求。&lt;/p&gt;&#xA;&lt;p&gt;但这个算法是 $O(\sqrt p)$ 的（如果涉及到具体实现的话，可能还得乘个 $\log \sqrt p$，就是&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;lower_bound&lt;/code&gt;查找的复杂度），比较适用于单组询问，很难推广应用。&lt;/p&gt;&#xA;&lt;p&gt;所以还有另外一种方式，比较适用于多组询问。&lt;/p&gt;&#xA;&lt;p&gt;是我们求出来 $a$ 和 $b$ 的阶，即 $\text{ord}_p a$ 和 $\text{ord}_p b$，看 $\text{ord}_p b$ 是否是 $\text{ord}_p a$ 的因子（$\text{ord}_p b \mid \text{ord}_p a$）即可。&lt;/p&gt;&#xA;&lt;p&gt;这里先不证这个结论是否正确，但相信大家第一次看到“阶”的时候定然是一头雾水的，下面我就来说一下它的定义和求法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;text-stylecolorrgb0150136-定义&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义&lt;/h2&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-阶&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 阶&lt;/h3&gt;&#xA;&lt;p&gt;阶的话，跟逆元相似，还是需要两个值，只不过这里叫做“$a$ 在模 $p$ 意义下的&lt;strong&gt;阶&lt;/strong&gt;”而已，换汤不换料。&lt;/p&gt;&#xA;&lt;p&gt;这个表示方法就是 $\text{ord}_p a$。&lt;/p&gt;&#xA;&lt;p&gt;它的定义是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;给你整数 $a$、$p$。&lt;/li&gt;&#xA;&lt;li&gt;找到最小的 $x$，使得同余方程 $a^x \equiv 1 \pmod p$ 成立。&lt;/li&gt;&#xA;&lt;li&gt;这个 $x$，就是$a$ 在模 $p$ 意义下的阶。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;text-stylecolorrgb0150136-原根&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 原根&lt;/h3&gt;&#xA;&lt;p&gt;但说到阶，我们定要讲一下它的孪生兄弟，原根了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>马拉车算法</title>
      <link>https://qjwh.github.io/posts/aln/manacher/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/aln/manacher/</guid>
      <description>&lt;text style=&#34;font-family:Lato,楷体&#34;&gt;&#xD;&#xA;&lt;p&gt;马拉车算法其实就是解决一个字符串中由某个位置为中心的最大回文串长度：（下图中蓝色部分为字符串，绿色框中的值就是以这个位置为中心的最大回文串长度）&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/z9ugcm59.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;其次，我们发现最底下的一排绿色数字涉及到空隙，所以我们可以把字符串扩展一下：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;比如，原字符串是 $\texttt{abccabbc}$，那么扩展之后就是：&lt;/p&gt;&#xA;&lt;p&gt;（LaTeX炸了）&#xA;$\texttt{\color{RoyalBlue}@\color{default}#\color{default}a\color{RoyalBlue}#\color{default}b\color{RoyalBlue}#\color{default}c\color{RoyalBlue}#\color{default}c\color{RoyalBlue}#\color{default}a\color{RoyalBlue}#\color{default}b\color{RoyalBlue}#\color{default}b\color{RoyalBlue}#\color{default}c\color{RoyalBlue}#\color{RoyalBlue}&amp;amp;}$&lt;/p&gt;&#xA;&lt;p&gt;第一个和最后一个字符可以自己定，但是最好不要和原字符串中的字符、中间插入的字符冲突（相等）。&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;注：其实还有第二种扩展方法：&lt;/p&gt;&#xA;&lt;p&gt;$\texttt{\color{RoyalBlue}#\color{default}a\color{RoyalBlue}#\color{default}b\color{RoyalBlue}#\color{default}c\color{RoyalBlue}#\color{default}c\color{RoyalBlue}#\color{default}a\color{RoyalBlue}#\color{default}b\color{RoyalBlue}#\color{default}b\color{RoyalBlue}#\color{default}c\color{RoyalBlue}#\color{default}}$&lt;/p&gt;&#xA;&lt;p&gt;还是，中间字符不能与原串字符相等。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;下面统一设「以下标 $i$ 为中心的最大回文串长度&lt;strong&gt;除以 $2$ 并下取整&lt;/strong&gt;」后的答案为 $p_i$。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;然后，我们就开始求 $p$ 数组了，当我们求到 $p_i$ 的时候，我们看前面求出的 $p_j+j$ 的最大值是多少（设为 $r$），即 $\max\limits_{j=1}^{i-1} { p_j+j }$，同时求出最大的 $p_j+j$ 对应的 $j$（设为 $c$）。&lt;/p&gt;&#xA;&lt;p&gt;并且，我们求出 $i$ 的对称点 $i&amp;rsquo;$，对称中心为 $c$，显然 $i&amp;rsquo;=2c-i$。&lt;/p&gt;&#xA;&lt;p&gt;然后，分类讨论：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;注：图中 $r$ 的意思与上面说的 $r$ 的意思有冲突，统一以上面说的定义为准。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;$i&amp;gt;r$，那么暴力算 $p_i$。&#xA;&lt;img src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/cqrtkobp.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;$r-i \geq p_{i&amp;rsquo;}$，那么 $p_i=p_{i&amp;rsquo;}$。&#xA;&lt;img src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/muq7kao8.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;li&gt;$r-i&amp;lt;p_{i&amp;rsquo;}$，那么让 $p_i=r-i$，继续暴力扩展。&#xA;&lt;img src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/zzacfutp.png&#34; alt=&#34;&#34;&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;最后就是时间复杂度问题了。&lt;/p&gt;&#xA;&lt;p&gt;关于时间复杂度的证明，我们可以分类讨论 $p_i$ 是用那种情况求值的：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;用情况1转移：$r$ 肯定会增加。&lt;/li&gt;&#xA;&lt;li&gt;用情况2转移：复杂度忽略。&lt;/li&gt;&#xA;&lt;li&gt;用情况3转移：$r$ 也肯定会增加。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;由于每时每刻，$r$ 都小于等于 $n$，所以总复杂度就是 $O(n)$ 的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【漂流本电子稿】06 - 友谊的旅途（未完工）</title>
      <link>https://qjwh.github.io/posts/plb/plb06/</link>
      <pubDate>Sun, 09 Feb 2025 09:30:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/plb/plb06/</guid>
      <description></description>
    </item>
    <item>
      <title>【漂流本电子稿】05 - 个人自传（内容缺失）</title>
      <link>https://qjwh.github.io/posts/plb/plb05/</link>
      <pubDate>Sun, 09 Feb 2025 09:29:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/plb/plb05/</guid>
      <description></description>
    </item>
    <item>
      <title>【漂流本电子稿】04 - 离别开出花</title>
      <link>https://qjwh.github.io/posts/plb/plb04/</link>
      <pubDate>Sun, 09 Feb 2025 09:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/plb/plb04/</guid>
      <description>&lt;p&gt;温馨提示：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在读本文章的时候，请勿玩梗。本文与题目同名歌曲无关。&lt;/li&gt;&#xA;&lt;li&gt;本文不聊班务。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h1 id=&#34;离别开出花&#34;&gt;离别开出花&lt;/h1&gt;&#xA;&lt;p&gt;&lt;em&gt;（《一个组合的相遇与分离》文学版）&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;不知道在那次座位洗牌之后，有多少人与自己的好友远离。所以今天我就来与大家讲一下7-29-39组合 $^1$ 的相遇与分离，看看离别如何开出花。&lt;/p&gt;&#xA;&lt;h2 id=&#34;从相遇到全盛&#34;&gt;从相遇到全盛&lt;/h2&gt;&#xA;&lt;p&gt;在那个春末 $^2$，偶然之间，我们相遇了。&lt;/p&gt;&#xA;&lt;p&gt;大概从那时候开始，我的心中便有了他们俩较为清晰的印象。&lt;/p&gt;&#xA;&lt;p&gt;朱熠辰是一个开朗的、好学的男生。我与他相伴的时间最长，他问我的问题自然也是很多的。他问过我英语，到了八上也问过我化学。所有他在当时没有搞明白的，不是问我就是问老师。$^3$ 他在听到一些有趣的事情的时候会笑，露出了两个酒窝，眼睛几乎眯成一条缝。&lt;/p&gt;&#xA;&lt;p&gt;柳旻辰是一个友善的、外向的女生。我记得她经常与我交流，可以聊课上那些有趣的事情，可以问对方自己不会的问题，可以一起讨论难题……我至今仍然记得她那双明亮如星辰般的眼睛，那如夏日清晨的露珠般的明朗的笑，和她那清脆中带着一些柔和的声音。&lt;/p&gt;&#xA;&lt;p&gt;在我们一起的那些天，我们几乎没有发生过任何矛盾。&lt;/p&gt;&#xA;&lt;h2 id=&#34;相伴地久天长&#34;&gt;相伴地久天长？&lt;/h2&gt;&#xA;&lt;p&gt;时光如白驹过隙，走过暮春，走过盛夏，暮秋九月的一天 $^4$，班主任突然要再次换座位。&lt;/p&gt;&#xA;&lt;p&gt;在最后一次回答了朱熠辰问我的关于英语比较级的问题，最后一次告诉了柳旻辰一个化学式的写法 $^5$ 之后，我们便走出了教室。&lt;/p&gt;&#xA;&lt;p&gt;最终，不出意外地，我们分离了。&lt;/p&gt;&#xA;&lt;p&gt;我还记得，那天傍晚天是阴沉沉的，正如我们的心。&lt;/p&gt;&#xA;&lt;p&gt;当时我的心情久久不能平复，直到第二天，晚风吹过，才抚平回忆留下的疤。&lt;/p&gt;&#xA;&lt;h2 id=&#34;结语-6&#34;&gt;结语 $^6$&lt;/h2&gt;&#xA;&lt;p&gt;即使在座位换了之后，那些之前的话语似乎仍然在我的耳旁响起，那些之前的画面似乎仍然在我眼前重演。在化学课上，当我再次听见“碳酸钙” $^7$ 的时候感觉内心百感交集——也许是想念之前坐在一起的生活了吧。&lt;/p&gt;&#xA;&lt;p&gt;不管是跟他们中的谁，都会经常和我讨论问题，我们能在课堂上、课间内共同进步。在和他们一起的时候，他们愿意解答我的问题，愿意聆听我的所有话语，这对我之后的性格影响很大，我变得喜欢与周围人讨论化学题目 $^8$，我变得乐于解答同桌问我的几乎所有问题 $^9$……所以我说过，他们让我展现出了自己最好的一面，可以说这是对一个同桌最好的评价。&lt;/p&gt;&#xA;&lt;p&gt;如果把时间轴缩小，我和你们的相遇，好像就是为了分离。但与其这么说，不如说，这次分离是为了将来更好的相遇。我不知道将来会怎样，也许在命运的安排里，我们只能在一起这么长时间。但在我找到一个更好的“安身之地”之前——这大概是不可能了 $^{10}$，我一直等待着我，能够在将来的某一天，日出，进班，坐在你们中间，日光透过窗户照在了柳旻辰问我的一道化学题上 $^{11}$，我打开手表告诉朱熠辰今天是几月几号……&lt;/p&gt;&#xA;&lt;p&gt;但是不管怎样，感谢你们与我走过七十九个日日夜夜，也感谢你们陪我度过的六百八十九个小时中的每一分、每一秒；感谢你们回答我的每一个问题，也感谢你们问过我的每一个疑问；感谢你们在我2024年的风景线上画上最美的一道彩虹，也感谢你们在我七下、八上的生活中点上最亮的一盏灯。&lt;/p&gt;&#xA;&lt;p&gt;离别开出花，希望那朵花能永远在我心中扎根，让我想起那过去的美好，让我向往于未来的重逢。&lt;/p&gt;&#xA;&lt;p&gt;（谨以此文，纪念7-29-39组合相遇的五周月与分离的第十九天）&lt;/p&gt;&#xA;&lt;p&gt;听风的秋&lt;br&gt;&#xA;2024年10月15日 $^{12}$&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;备注：&lt;br&gt;&#xA;$^1$ 由三个人的学号按照升序排序组成。&lt;br&gt;&#xA;$^2$ 指2024年5月15日。&lt;br&gt;&#xA;$^3$ 不太记得真实发生什么了。&lt;br&gt;&#xA;$^4$ 指2024年9月26日。这里说“暮秋”只是为了衬托心情，实际上九月只是初秋。&lt;br&gt;&#xA;$^5$ 虚构的。&lt;br&gt;&#xA;$^6$ 这部分有修改，不要认为全是上一篇的内容。&lt;br&gt;&#xA;$^7$ 碳酸钙（CaCO3）也被我称作“卡（kǎ）扣三”，是在化学中较为常见的沉淀，我之前和他们讨论化学的时候经常提到这个元素。&lt;br&gt;&#xA;$^8$ 纯属虚构。&lt;br&gt;&#xA;$^9$ 特殊情况除外。&lt;br&gt;&#xA;$^{10}$ 因为我在还和他们一起的时候，认为只有他们组是最好的地方。&lt;br&gt;&#xA;$^{11}$ 纯属虚构。&lt;br&gt;&#xA;$^{12}$ 一稿：2024/9/30，二稿：2024/10/8，三稿：2024/10/10，四稿：2024/10/12，五稿：2024/10/14。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;后记：&lt;br&gt;&#xA;有人可能会问为何我这么急迫地想在9月27日就写一个千字长文说这件事，是因为我觉得在当下情绪还未完全稳定的时候，情感的抒发会更加自然、真实，事实证明确实如此，我周围很多人都表示写得很感人——这算是我创作的最大鼓励。另外那篇文章也告诉了我一个道理，真正好的情感抒发，并不是语速、语调、背景音乐的增益，而是来自自己内心深处真挚、深刻的情感流露。&lt;br&gt;&#xA;这或许是我写过的所有作文中，修改过程最波折，草稿数量最多，修改周期最长的一篇作文。比如第5段末尾对柳旻辰的描写，这三句话，我改了五次。这篇作文我存了六个草稿，历时十五天终于完工。&lt;br&gt;&#xA;感谢英语祁老师、朱熠辰对本作文创作的肯定与鼓励，感谢杜仔希、柳旻辰对本作文提供细节上的修改意见，最后也感谢赵老师的耐心地、不断地指导。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【漂流本电子稿】03 - 一个组合的相遇与分离</title>
      <link>https://qjwh.github.io/posts/plb/plb03/</link>
      <pubDate>Sun, 09 Feb 2025 09:20:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/plb/plb03/</guid>
      <description>&lt;h1 id=&#34;一个组合的相遇与分离&#34;&gt;一个组合的相遇与分离&lt;/h1&gt;&#xA;&lt;p&gt;&lt;em&gt;（纪实性抒情文章）&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;不知道在9月26日座位洗牌之后，有多少人与自己的好友远离。所以我今天就来与大家讲一下7-29-39组合 $^1$ 的相遇与分离的全过程。&lt;/p&gt;&#xA;&lt;h2 id=&#34;从相遇到全盛&#34;&gt;从相遇到全盛&lt;/h2&gt;&#xA;&lt;p&gt;2024年5月15日，在我从杭州回来之后，我便加入了这个组合。最初的时候，我想让我或者朱熠辰离开本组，因为我坐在了中间 $^2$。但好在，我坚持了下来。6月4日 $^3$，因为杨梓荆坐在了朱熠辰的旁边 $^4$，他主动提议与我交换位置。自此，我们之间再也没有发生在座位上的争执。&lt;/p&gt;&#xA;&lt;p&gt;大概从那时候开始，我的心中便有了他们俩较为立体的形象。朱熠辰是一个开朗的、好学的、礼貌的男生，他经常问我问题，在不小心碰到我的左手臂的时候会说一句抱歉，尽管我说过这没事儿。柳旻辰是一个友善的、“社恐”的 $^5$ 女生，我在七下、八上的时候都没有多少天和她做同桌，但在八上的时候她与我讨论的那些化学问题我却记忆犹新。&lt;/p&gt;&#xA;&lt;p&gt;但是他们俩有一个共同的特点，他们总是能够bring out the best in me（让我展示出最好的一面），可以说，这是对一个朋友的最好的评价 $^6$。&lt;/p&gt;&#xA;&lt;p&gt;在我们一起的那些天，我们几乎没有发生过任何矛盾。&lt;/p&gt;&#xA;&lt;h2 id=&#34;从全盛到分离&#34;&gt;从全盛到分离&lt;/h2&gt;&#xA;&lt;p&gt;这一场面一直持续到9月11日 $^7$，在秦老师的要求下，我与朱熠辰再次把座位换了回来，只不过正如上文注释所说，我并没有在意。9月14日 $^8$，班级座位排布进行了调整，但好在我们没有被拆散。&lt;/p&gt;&#xA;&lt;p&gt;在之后的几天，我们互相之间好像很珍惜这些时光，似乎当时我们就有被拆散的预感，讨论的频率突然增多，也互相帮助过很多次。&lt;/p&gt;&#xA;&lt;p&gt;事实证明，遗憾地，我们的预感是真的。9月26日，我们进行了一遍班级座位的大洗牌。现在，我、朱熠辰、柳旻辰除了座位组成了一个直角三角形之外，被彻底拆散了。&lt;/p&gt;&#xA;&lt;p&gt;我的心情被震撼了一晚上。$^9$&lt;/p&gt;&#xA;&lt;h2 id=&#34;结语-10&#34;&gt;结语 $^{10}$&lt;/h2&gt;&#xA;&lt;p&gt;如果把时间轴缩小，我和你们的相遇，好像就是为了分离。但与其这么说，不如说，这次分离是为了将来更好的相遇。我不知道命运会怎样，但在我找到一个更好的“安身之地”之前，我一直等待着我们，能够在将来的某一天，在这个班级里——亦或是在高中部的班级里，能够再次坐到一起，问对方比较级的用法、氢氧化钠的化学式…… $^{11}$&lt;/p&gt;&#xA;&lt;p&gt;【英文抒情段】$^{12}$ $^{13}$ $^{14}$ $^{15}$&lt;/p&gt;&#xA;&lt;p&gt;现在，我与他们也很少能够近距离相见了。我们能在值日的时候以同一组的组员的身份再见一次，但也只能在哪个时候这样相见。唉！还说什么呢？怀念！怀念！$^{16}$&lt;/p&gt;&#xA;&lt;p&gt;听风的秋&lt;br&gt;&#xA;2024年9月27日&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;备注：&lt;br&gt;&#xA;$^1$ 由三个人的学号按照升序排序组成。&lt;br&gt;&#xA;$^2$ 当时的我很想坐在最右边，但我现在已经不在意了。&lt;br&gt;&#xA;$^3$ 估算的时间。&lt;br&gt;&#xA;$^4$ 实际上中间隔着一个走廊，当时的局势大概是39 29 7（走廊）26。&lt;br&gt;&#xA;$^5$ 她这么说的，但我实际上不这么认为，我认为她是开朗的、外向的。&lt;br&gt;&#xA;$^6$ 英语老师这么说的。&lt;br&gt;&#xA;$^7$ 估算的时间。&lt;br&gt;&#xA;$^8$ 估算的时间。&lt;br&gt;&#xA;$^9$ 这句话夸张了，只是为了凸显出对我的影响之大。&lt;br&gt;&#xA;$^{10}$ 为了更好地抒情，所以这里改成了第二人称描述。&lt;br&gt;&#xA;$^{11}$ 感谢赵老师的指导。&lt;br&gt;&#xA;$^{12}$ 所有的“you”都是指的“你们”。&lt;br&gt;&#xA;$^{13}$ 从5月15日开始计算，包括9月26日当天，不包括暑假我不在的这段时间。&lt;br&gt;&#xA;$^{14}$ 估算的，仅供参考。&lt;br&gt;&#xA;$^{15}$ 感谢英语老师的指导。&lt;br&gt;&#xA;$^{16}$ 仿照老舍《我的母亲》结尾段。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【漂流本电子稿】02 - 忆2023暑假</title>
      <link>https://qjwh.github.io/posts/plb/plb02/</link>
      <pubDate>Sun, 09 Feb 2025 09:09:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/plb/plb02/</guid>
      <description>&lt;p&gt;因为原定的稿子需要二次修改一下，所以中秋假期没有来得及，这次漂流本就写之前写好的一个稿子了。&lt;/p&gt;&#xA;&lt;h1 id=&#34;忆2023暑假-1&#34;&gt;忆2023暑假 $^1$&lt;/h1&gt;&#xA;&lt;p&gt;&lt;em&gt;（为何对2023暑假如此怀恋）&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;2023暑假一直以来被认为是一段极其美好的时光，下面我将谈谈为何2023暑假如此让我怀恋。&lt;/p&gt;&#xA;&lt;h2 id=&#34;当时的生活&#34;&gt;当时的生活&lt;/h2&gt;&#xA;&lt;p&gt;2023年6月20日，随着毕业考的结考铃声响起，小学的六年时光画上了一个完美的句号 $^2$。同月23日，2023暑假便正式开始了。&lt;/p&gt;&#xA;&lt;p&gt;整个暑假有两个月长，所以时间就很充裕。在路上再也不用跟时间赛跑，眼前看到的是悠闲的暑假生活。在去卫生间的路上我可以看看隔壁学科教室里面人的在干什么，在从羽毛球场回来的路上可以慢慢地在学校小径上端详路边的花开草盛，在走向买饭的店的路上可以和机房里的人边走边聊。&lt;/p&gt;&#xA;&lt;p&gt;除此之外，我还可以腾出很多时间。&lt;/p&gt;&#xA;&lt;p&gt;而腾出的时间用来干什么呢？有一大部分，我会用来运动。&lt;/p&gt;&#xA;&lt;p&gt;当时傍晚六点到六点半是自由活动时间，在这段时间内可以在外面的场地内打球。我在五月份开始自己练习羽毛球，在这里终于找到了更好的对手了——当时机房内几乎所有人（当然还有机房外的）都会打羽毛球。我便在与他们双打的时候增强了团队合作能力，羽毛球水平便飞速增长。“晚风吹起你鬓间的白发，抚平回忆留下的疤”，看着羽毛球在空中飞舞，晚霞在远处绽放，鸟儿在空中飞过，我的心情也得到了放松。同时羽毛球还有一个好处，可以帮助长身高，我当时身高的增长速度也达到了前所未有的快。&lt;/p&gt;&#xA;&lt;p&gt;在一周内唯一放假的周日。我早上仍然有（几乎）一个上午的娱乐时间。&lt;/p&gt;&#xA;&lt;p&gt;无论是哪一天，上床时间一般都在十点半左右 $^3$。&lt;/p&gt;&#xA;&lt;h2 id=&#34;骤然的变化&#34;&gt;骤然的变化&lt;/h2&gt;&#xA;&lt;p&gt;“彩云易散琉璃脆，世间好物不坚牢”，最终，上面的美好时光在岁月的力量之下无奈退出了历史舞台——初中生活开始了。&lt;/p&gt;&#xA;&lt;p&gt;踏入初中，七门学科的学业压力骤然而至。整块整块的时间转为了碎片化的时间，所以我必须让脑子无时无刻地超负荷运转 $^4$；同时因为作业的增多，能够留给娱乐与运动的时间越来越少，而睡眠也被大幅度压缩 $^5$，这就导致了发育上的瓶颈……长久以来，客观来讲，这的确是非常累的一件事，但我似乎早已适应 $^6$。&lt;/p&gt;&#xA;&lt;p&gt;而且，在生活中，我似乎无时无刻都在拼尽全力地跑，我自然不会关注路边新开的花花草草，这些美好便在一声声脚步声中错过了。&lt;/p&gt;&#xA;&lt;p&gt;所以，在快节奏的生活中，有时候，我们慢下来，不也是一种很好的体验？&lt;/p&gt;&#xA;&lt;p&gt;听风的秋&lt;br&gt;&#xA;2024年9月16日&lt;/p&gt;&#xA;&lt;p&gt;“它就像一阵风起，吹散我心头的烦恼；它就像一颗星星，照亮我前行的方向”  $^7$&lt;br&gt;&#xA;——2023暑假总评&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;备注：&lt;br&gt;&#xA;$^1$ 初步定稿：2024/6/8，二次修改：2024/6/10，三次修改：2024/9/16。感谢赵老师的指导。&lt;br&gt;&#xA;$^2$ 其实之后我还去了一次小学，但理论上这一天就已经毕业了。&lt;br&gt;&#xA;$^3$ 数据仅供参考，我也忘记当时的具体时间了，但不会超过十一点。&lt;br&gt;&#xA;$^4$ 此处为夸张表述，但这种情况的确是有的。&lt;br&gt;&#xA;$^5$ 相关数据显示，最低时候睡眠只有5.5h，最长一般也不会超过7h。&lt;br&gt;&#xA;$^6$ 这里是为了侧面突出超负荷运转的持续时间的久。&lt;br&gt;&#xA;$^7$ 本诗以2023暑假的回忆曲《起风了》和《星星点灯》改编而来，本段不属于正文，只是突出2023暑假的美好。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;后记：&lt;br&gt;&#xA;我在2023暑假的时候，并没有认为它有多美好，我当时还认为“这肯定比不上2022暑假”。但到了初中，进入了快节奏生活，我才意识到当时有多么美好、难忘、难以再现。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【漂流本电子稿】01 - 独立生活之得（内容缺失）</title>
      <link>https://qjwh.github.io/posts/plb/plb01/</link>
      <pubDate>Sun, 09 Feb 2025 09:00:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/plb/plb01/</guid>
      <description></description>
    </item>
    <item>
      <title>【村新晚报】2025W01</title>
      <link>https://qjwh.github.io/posts/cxep/2025w01/</link>
      <pubDate>Sat, 08 Feb 2025 22:30:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/cxep/2025w01/</guid>
      <description>&lt;h2 id=&#34;关于此工程&#34;&gt;关于此工程&lt;/h2&gt;&#xA;&lt;p&gt;此工程立项与2025年2月7日，原名「“朝花夕拾”每日杂记」，用于发布这一天内发生的重要事情或者一些杂记。&lt;/p&gt;&#xA;&lt;p&gt;目前定于每晚22:30左右进行发布，标签为「村新晚报」，进入本站即可查看。&lt;/p&gt;&#xA;&lt;p&gt;每篇文章内大约有3~4个话题，若有未展示完的会留到后面展示。&lt;/p&gt;&#xA;&lt;h2 id=&#34;关于漂流本同步&#34;&gt;关于漂流本同步&lt;/h2&gt;&#xA;&lt;p&gt;在之后我会逐渐把之前漂流本的电子稿尽量恢复并递交到这里，标签为「漂流本电子稿」。&lt;/p&gt;&#xA;&lt;p&gt;由于数据同步问题，可能需要等到寒假之后才能开始。&lt;/p&gt;&#xA;&lt;h2 id=&#34;文章编号命名&#34;&gt;文章编号命名&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;寒假：[当前年份]+W+[两位数]，如2024W15&lt;/li&gt;&#xA;&lt;li&gt;暑假：[当前年份]+S+[两位数]，如2023S63&lt;/li&gt;&#xA;&lt;li&gt;上半学期：[当前年份]+G+[当前年级]+A+[三位数]，如2024G8A009&lt;/li&gt;&#xA;&lt;li&gt;下半学期：[当前年份]+G+[当前年级]+B+[三位数]，如2025G8B018&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;农历新年目标公示&#34;&gt;农历新年目标公示&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;生理：身高175cm+，体重50kg+，调节作息&lt;/li&gt;&#xA;&lt;li&gt;florr：获得更多的U，达到Lv90+&lt;/li&gt;&#xA;&lt;li&gt;信竞：进E队，突破当前阶段进入省选，CF状态恢复&lt;/li&gt;&#xA;&lt;li&gt;友谊：发展有必要发展的发展中友谊（如王若凡、朱熠辰、刘奕杰、周馨姌等），继续保持当前活跃友谊（如陈翊焓、姜皓天、刘思源等）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;后续还在更新……&lt;/p&gt;</description>
    </item>
    <item>
      <title>Hello, world!</title>
      <link>https://qjwh.github.io/posts/test/</link>
      <pubDate>Sat, 08 Feb 2025 11:00:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/test/</guid>
      <description>&lt;p&gt;This page is just for test&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;$123$&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;123&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;$x^2$&lt;/p&gt;&#xA;&lt;p&gt;$\color{green}(\sum a_i) \color{default} 123$&lt;/p&gt;&#xA;&lt;h1 id=&#34;456&#34;&gt;456&lt;/h1&gt;&#xA;&lt;h2 id=&#34;456-1&#34;&gt;456&lt;/h2&gt;&#xA;&lt;h1 id=&#34;123&#34;&gt;123&lt;/h1&gt;&#xA;&lt;h2 id=&#34;123-1&#34;&gt;123&lt;/h2&gt;&#xA;&lt;h3 id=&#34;123-2&#34;&gt;123&lt;/h3&gt;&#xA;&lt;h4 id=&#34;123-3&#34;&gt;123&lt;/h4&gt;&#xA;&lt;h5 id=&#34;123-4&#34;&gt;123&lt;/h5&gt;&#xA;&lt;h6 id=&#34;123-5&#34;&gt;123&lt;/h6&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;&#xA;&lt;p&gt;123&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
