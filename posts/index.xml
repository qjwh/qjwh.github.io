<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on CXBlog</title>
    <link>https://qjwh.github.io/posts/</link>
    <description>Recent content in Posts on CXBlog</description>
    <generator>Hugo -- 0.143.1</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 27 Feb 2025 22:39:42 +0800</lastBuildDate>
    <atom:link href="https://qjwh.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【娱乐】florr.io更新快报</title>
      <link>https://qjwh.github.io/posts/play/florr_upds/</link>
      <pubDate>Thu, 27 Feb 2025 22:39:42 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/play/florr_upds/</guid>
      <description>官方渠道 实时更新</description>
    </item>
    <item>
      <title>20250211代码源比赛</title>
      <link>https://qjwh.github.io/posts/oi/competition/20250211%E4%BB%A3%E7%A0%81%E6%BA%90%E6%AF%94%E8%B5%9B/</link>
      <pubDate>Tue, 11 Feb 2025 21:49:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/competition/20250211%E4%BB%A3%E7%A0%81%E6%BA%90%E6%AF%94%E8%B5%9B/</guid>
      <description>&lt;h2 id=&#34;text-stylecolorrgb0150136-赛时记录&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 赛时记录&lt;/h2&gt;
&lt;p&gt;比赛一开始（$11$ 分钟）就过了A。&lt;/p&gt;
&lt;p&gt;后来一直在B题思考正解。&lt;/p&gt;
&lt;p&gt;在比赛达到 $2h$ 之后，我发现正解已经没希望了，结论假了。&lt;/p&gt;
&lt;p&gt;所以改成了暴力。&lt;/p&gt;
&lt;p&gt;事实上我先写的C，因为感觉B不太有希望，C一眼 $20$ 分。&lt;/p&gt;
&lt;p&gt;之后回头看B，干了最低档。&lt;/p&gt;
&lt;p&gt;最后是D，思考了一下可以做 $45$ 分，搞了。&lt;/p&gt;
&lt;p&gt;此时里比赛结束还有 $27$ 分钟，所以回头看了一下，发现C题的暴力很多。&lt;/p&gt;
&lt;p&gt;先后搞了子任务 $1 \sim 3$，总共 $70$ 分。&lt;/p&gt;
&lt;p&gt;然后比赛就结束了。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-估分-vs-结果&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 估分 VS 结果&lt;/h2&gt;
&lt;p&gt;估分：$100+10+70+45=225$&lt;/p&gt;
&lt;p&gt;结果：$100+25+0+30=155$&lt;/p&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-挂分原因&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 挂分原因&lt;/h3&gt;
&lt;p&gt;关于B为啥多了 $15$ 分，我也不知道。&lt;/p&gt;
&lt;p&gt;C很复杂：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子任务1 $T \leq 100,n \leq 10$ 挂了：赋值消耗时间复杂度太多，在&lt;code&gt;swap&lt;/code&gt;的时候回溯写挂了。&lt;/li&gt;
&lt;li&gt;子任务2 $k=0$ 挂了：赋值消耗时间复杂度太多。&lt;/li&gt;
&lt;li&gt;子任务3 $k=1$ 挂了：做法假了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;D：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子任务3 $T=1,k \leq 15$ 挂了：实现的时候没有预处理 $s$、$e$ 的答案，导致询问次数太多TLE。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-策略&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 策略&lt;/h2&gt;
&lt;p&gt;感觉还是卡B太久。&lt;/p&gt;
&lt;p&gt;事实上这次A非常确信做法正确，事实就是正确的，但后面的题没有对拍，导致总共挂了 $85$ 分。&lt;/p&gt;
&lt;p&gt;之后无论对于正解还是暴力都得对拍，如果认为有挂的概率的那种。&lt;/p&gt;</description>
    </item>
    <item>
      <title>策略更改</title>
      <link>https://qjwh.github.io/posts/oi/competition/%E7%AD%96%E7%95%A5%E6%9B%B4%E6%94%B9/</link>
      <pubDate>Mon, 10 Feb 2025 17:30:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/competition/%E7%AD%96%E7%95%A5%E6%9B%B4%E6%94%B9/</guid>
      <description>&lt;p&gt;跳题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一道题认为难写，先看后面的题，也许有好写的部分分甚至是正解&lt;/li&gt;
&lt;li&gt;如果一道题写完了挂了，认为很对：
&lt;ul&gt;
&lt;li&gt;找不到错误数据，就规定一段时间（一般为5~10分钟，或者直接执行），然后立刻跳题&lt;/li&gt;
&lt;li&gt;找到了错误数据，就可以调时间长一些&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果要在开场把所有题读完（OI赛制专用），遇到难读的题目可以先不读&lt;/li&gt;
&lt;li&gt;如果要把剩下的时间全部用在一道题上，先去吃其他题的保底，再开始写这道题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对拍（OI赛制专用）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果说一道题强数据好造、暴力好写，那么一定要对拍&lt;/li&gt;
&lt;li&gt;即使是模拟赛也要对拍，不止是正式比赛，把模拟赛当做正式比赛认真对待&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比赛后写一下总结，包括以下内容：
&lt;ul&gt;
&lt;li&gt;赛时记录，什么时候在干什么&lt;/li&gt;
&lt;li&gt;估分 VS 得分&lt;/li&gt;
&lt;li&gt;挂分原因（BBE）&lt;/li&gt;
&lt;li&gt;赛后想一下赛时没有想到的部分分/满分/更优做法&lt;/li&gt;
&lt;li&gt;策略总结+调整&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>【娱乐】炒饭每日小测验食用指南</title>
      <link>https://qjwh.github.io/posts/play/xiaoce_fun_daily/</link>
      <pubDate>Sun, 09 Feb 2025 19:38:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/play/xiaoce_fun_daily/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://xiaoce.fun/daily&#34;&gt;网址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每天北京时间0点整会更新所有测验。&lt;/p&gt;
&lt;p&gt;这里只说部分，其他的自行摸索。&lt;/p&gt;
&lt;h2 id=&#34;猜城猜城3d猜国猜旗天眼乡音城景&#34;&gt;猜城/猜城3D/猜国/猜旗/天眼/乡音/城景&lt;/h2&gt;
&lt;h3 id=&#34;线索&#34;&gt;线索&lt;/h3&gt;
&lt;p&gt;会给你关于这个行政区/国家的信息（如果是猜旗则随着你的猜测会逐步揭开）。&lt;/p&gt;
&lt;p&gt;你有 $6$ 次机会去猜，输入方式是类似于查找然后点击的方式（可以自己试试就知道是啥意思了）。&lt;/p&gt;
&lt;h3 id=&#34;判题&#34;&gt;判题&lt;/h3&gt;
&lt;p&gt;每次猜完后会告诉你答案在你猜的答案的（大致）哪个方位（八方向），以及距离是多少。&lt;/p&gt;
&lt;p&gt;天眼不会告诉你方位，只会告诉你距离，所以非常难猜，没有足够实力不要去挑战。&lt;/p&gt;
&lt;p&gt;不用管后面的百分比，这个是接近程度，按照距离除以一个很大的数去计算。&lt;/p&gt;
&lt;p&gt;一旦猜对则游戏结束。&lt;/p&gt;
&lt;h2 id=&#34;填省填国填歌&#34;&gt;填省/填国/填歌&lt;/h2&gt;
&lt;h3 id=&#34;线索-1&#34;&gt;线索&lt;/h3&gt;
&lt;p&gt;给你一个表格，表头有限制条件。&lt;/p&gt;
&lt;h3 id=&#34;判题-1&#34;&gt;判题&lt;/h3&gt;
&lt;p&gt;需要在表格内每一个方格填入数据库内同时满足行、列表头上的条件的元素。&lt;/p&gt;
&lt;p&gt;尝试机会有限，看最上面的生命值。&lt;/p&gt;
&lt;p&gt;填完则游戏结束。&lt;/p&gt;
&lt;h2 id=&#34;猜word&#34;&gt;猜Word&lt;/h2&gt;
&lt;h3 id=&#34;线索-2&#34;&gt;线索&lt;/h3&gt;
&lt;p&gt;跟Wordle一模一样。&lt;/p&gt;
&lt;h3 id=&#34;判题-2&#34;&gt;判题&lt;/h3&gt;
&lt;p&gt;跟阴阳小游戏很像，但不同的是可以告诉你每个位置是匹配还是错位。&lt;/p&gt;
&lt;p&gt;匹配显示为绿色，错位则是黄色，没有则是灰色。&lt;/p&gt;
&lt;h2 id=&#34;歌词诗文&#34;&gt;歌词/诗文&lt;/h2&gt;
&lt;h3 id=&#34;线索-3&#34;&gt;线索&lt;/h3&gt;
&lt;p&gt;一开始所有格子都是黑色的状态。&lt;/p&gt;
&lt;p&gt;你有无限次机会，每次可以输入一个字，然后这个字在这首歌（包括歌名、歌手、歌词）或诗（包括诗名、作者、内容）内出现的所有位置都会揭开。&lt;/p&gt;
&lt;h3 id=&#34;判题-3&#34;&gt;判题&lt;/h3&gt;
&lt;p&gt;如果猜的字没有出现，则会提示“未出现”并将该字以红色背景显示在最底下。&lt;/p&gt;
&lt;p&gt;如果猜过，则会提示“猜过”并不执行任何操作。&lt;/p&gt;
&lt;p&gt;将歌名或诗名完全揭开即可。&lt;/p&gt;
&lt;h2 id=&#34;连句&#34;&gt;连句&lt;/h2&gt;
&lt;h3 id=&#34;规则&#34;&gt;规则&lt;/h3&gt;
&lt;p&gt;给你一个表格，你要在里面找到固定数量（可以看最底下）的诗句或者歌词。&lt;/p&gt;
&lt;p&gt;可以通过八方向的一条链表示该诗句，连接的时候可以交叉，可以自己玩一下。&lt;/p&gt;
&lt;p&gt;每个字只能使用一次。&lt;/p&gt;
&lt;h3 id=&#34;判题-4&#34;&gt;判题&lt;/h3&gt;
&lt;p&gt;尝试机会有限，看最上面的生命值。&lt;/p&gt;
&lt;p&gt;如果连句成功则会标记为绿色，并不能再选。&lt;/p&gt;
&lt;p&gt;全部为绿色则游戏结束。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【娱乐】交流必备 florr中那些特殊的简写或别称</title>
      <link>https://qjwh.github.io/posts/play/florr_simple_name/</link>
      <pubDate>Sun, 09 Feb 2025 17:05:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/play/florr_simple_name/</guid>
      <description>&lt;p&gt;更新中……&lt;/p&gt;
&lt;h2 id=&#34;稀有度&#34;&gt;稀有度&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Common：绿&lt;/li&gt;
&lt;li&gt;Unusual：un/黄&lt;/li&gt;
&lt;li&gt;Rare：蓝&lt;/li&gt;
&lt;li&gt;Epic：紫&lt;/li&gt;
&lt;li&gt;Legendary：l/红&lt;/li&gt;
&lt;li&gt;Mythic：m/青&lt;/li&gt;
&lt;li&gt;Ultra：u/ul/粉&lt;/li&gt;
&lt;li&gt;Super：s/书青&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;合成&#34;&gt;合成&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;合成Mythic：合青&lt;/li&gt;
&lt;li&gt;合成Ultra：合粉/河粉&lt;/li&gt;
&lt;li&gt;合成Super：合苏（su）&lt;/li&gt;
&lt;li&gt;合成Ultra并失败：冒青烟&lt;/li&gt;
&lt;li&gt;合成Super并失败：冒粉烟&lt;/li&gt;
&lt;li&gt;用x个花瓣合成并成功：x=1（如5=1）&lt;/li&gt;
&lt;li&gt;用x个花瓣合成并失败：-数字（如-2，但通常此处x=5）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;花瓣&#34;&gt;花瓣&lt;/h2&gt;
&lt;p&gt;默认可以叫花瓣的英文名和大家普遍公认的中文名。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ant Egg：agg/egg&lt;/li&gt;
&lt;li&gt;Antennae：ante/触&lt;/li&gt;
&lt;li&gt;Basil：比勒（一般不叫它罗勒）&lt;/li&gt;
&lt;li&gt;Beetle Egg：bgg&lt;/li&gt;
&lt;li&gt;Bone：骨/装&lt;/li&gt;
&lt;li&gt;Bubble：泡&lt;/li&gt;
&lt;li&gt;Claw：头发（一般不叫他爪子/蟹爪）&lt;/li&gt;
&lt;li&gt;Dandelion：dande&lt;/li&gt;
&lt;li&gt;Dice：色（shǎi）&lt;/li&gt;
&lt;li&gt;Faster：罚&lt;/li&gt;
&lt;li&gt;Iris：毒药&lt;/li&gt;
&lt;li&gt;Lightning：lāi&lt;/li&gt;
&lt;li&gt;Magic Eye：me/魔眼&lt;/li&gt;
&lt;li&gt;Magnet：mag&lt;/li&gt;
&lt;li&gt;Mana Orb：orb（拼写式读法）&lt;/li&gt;
&lt;li&gt;Pincer：品色/拼刺儿&lt;/li&gt;
&lt;li&gt;Powder：pow&lt;/li&gt;
&lt;li&gt;Rice：米&lt;/li&gt;
&lt;li&gt;Shovel：铲&lt;/li&gt;
&lt;li&gt;Sponge：海&lt;/li&gt;
&lt;li&gt;Third Eye：te/三眼&lt;/li&gt;
&lt;li&gt;Uranium：uran&lt;/li&gt;
&lt;li&gt;Wing：羽毛&lt;/li&gt;
&lt;li&gt;Yggdrasil：ygg（一般不叫它世界树）&lt;/li&gt;
&lt;li&gt;Yucca：于夹（一般不叫它丝兰）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;生物&#34;&gt;生物&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Queen Ant：queen&lt;/li&gt;
&lt;li&gt;Starfish：兴（xìng）禹（yú）&lt;/li&gt;
&lt;li&gt;黄色瓢虫：shiny&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>2-SAT算法</title>
      <link>https://qjwh.github.io/posts/oi/aln/2sat/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/2sat/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-前言&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 前言&lt;/h2&gt;
&lt;p&gt;2-SAT中的SAT是适定性（Satisfiability）问题的简称，一般形式为 $k$ - 适定性问题，简称 $k$ - SAT，但由于 $k&amp;gt;2$ 时问题为NP完全问题（只有指数级别复杂度的解法，或者多项式级别复杂度的&lt;strong&gt;相似&lt;/strong&gt;解法），而 $k=1$ 时都不用解了 &lt;del&gt;（废话）&lt;/del&gt; ，所以下面全部考虑 $k=2$ 的情况。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-定义&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义&lt;/h2&gt;
&lt;p&gt;2-SAT问题简单来说就是，有 $n$ 个集合，每个集合包含两个元素（集合 $i$ 包含元素 $2i-1$ 和 $2i$，但其实编号是无关紧要的，任意都行），你必须要在&lt;strong&gt;每个&lt;/strong&gt;集合里分别选择&lt;strong&gt;刚好&lt;/strong&gt;一个元素，但某些元素之间可能有矛盾，即这两个元素不能在一种方案里被同时选择，问你是否有解，报告出来，如果有解，输出一种方案（可能不用输出）。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-题目&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题目&lt;/h2&gt;
&lt;p&gt;看上面的定义可能有点难懂，这里举个题目。&lt;/p&gt;
&lt;p&gt;有一场宴会，这场宴会只有 $n$ 对幸运夫妻可以参加，每对夫妻里只能选择&lt;strong&gt;刚好&lt;/strong&gt;一个人去参加这场宴会。&lt;/p&gt;
&lt;p&gt;但部分人之间可能有矛盾，会给出所有有矛盾的两人编号。&lt;/p&gt;
&lt;p&gt;问你，是否可以构造一种合法方案，如果不行，报告无解，否则输出一种方案。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-解法&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解法&lt;/h2&gt;
&lt;p&gt;（下面统一默认要解决的是实际问题，不是定义里的问题）&lt;/p&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-定义点边&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义点、边&lt;/h3&gt;
&lt;p&gt;我们考虑把夫妻编个名字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一对夫妻：A男、A女&lt;/li&gt;
&lt;li&gt;第二对夫妻：B男、B女&lt;/li&gt;
&lt;li&gt;第三对夫妻：C男、C女&lt;/li&gt;
&lt;li&gt;以此类推&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后，我们考虑建图。&lt;/p&gt;
&lt;p&gt;但这个建图就要用到一点思维了。&lt;/p&gt;
&lt;p&gt;我们不以其他的定义定义点，我们就把一个点当做一个&lt;strong&gt;现实&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$1$ 号点代表第一对夫妻是A男参与宴会，$2$ 号点代表A女参与宴会&lt;/li&gt;
&lt;li&gt;$3$ 号点代表第二对夫妻是B男参与宴会，$4$ 号点代表B女参与宴会&lt;/li&gt;
&lt;li&gt;$5$ 号点代表第三对夫妻是C男参与宴会，$6$ 号点代表C女参与宴会&lt;/li&gt;
&lt;li&gt;以此类推&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;边的定义也很难思考出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一条&lt;strong&gt;有向边&lt;/strong&gt; $u \to v$，代表现实 $u$ &lt;strong&gt;满足&lt;/strong&gt;了，现实 $v$ 也要&lt;strong&gt;满足&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;text-stylecolorrgb0150136-举个例子&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 举个例子&lt;/h4&gt;
&lt;p&gt;所以，如果说A男和B女、C男和A女之间都有矛盾，那么就需要在：&lt;/p&gt;</description>
    </item>
    <item>
      <title>BSGS算法</title>
      <link>https://qjwh.github.io/posts/oi/aln/bsgs/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/bsgs/</guid>
      <description>&lt;p&gt;&lt;strong&gt;basic&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;BSGS算法英文名叫“baby-step giant-step”，又称“大步小步算法”。&lt;/p&gt;
&lt;p&gt;这个算法听名字似乎是个随机化算法，但实际上是数论算法。&lt;/p&gt;
&lt;p&gt;具体地，这个算法解决的是 $a^x \equiv b \pmod{p}$ 的解，其中 $a$、$b$、$p$ 是已知的（$0 \leq a,b&amp;lt;p$，保证 $\gcd(a,p)=1$），$x$ 是要求的。&lt;/p&gt;
&lt;p&gt;这个算法甚至可以求出所有的 $x$，但为了好讲，我们先考虑如何求出是否有解，以下代码中&lt;code&gt;YES&lt;/code&gt;就代表确定有解了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;force algorithm&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，有一个暴力算法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;rep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;INF&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ksm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;YES&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但这个算法是 $O(\infty)$ 的，我们考虑优化。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;optimization algorithm 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们考虑 $x$ 的上界，根据欧拉定理，$a^{\varphi(p)} \equiv 1 \pmod{p}$，我们就可以确定，$x$ 的上界就是 $\varphi(p)$（准确来说减 $1$ 也彳亍），因为如果 $x&amp;gt;\varphi(p)$，那么 $a^x$ 就等于 $a^{x-\varphi(p)}$，也就成为了一个循环，所以上界就是 $\varphi(p)$。&lt;/p&gt;
&lt;p&gt;由于 $\varphi(p)&amp;lt;p$，所以可以把 $p$ &lt;strong&gt;当做&lt;/strong&gt;是质数，$x$ 的上界也就是 $p-1$ 了。&lt;/p&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;rep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ksm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;YES&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;optimization algorithm 2 (BSGS)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但这个算法还是可能会TLE，我们继续考虑优化&lt;/p&gt;
&lt;p&gt;我们定义 $q=\left\lceil \sqrt{p} \right\rceil$，那么我们其实就可以把 $x$ 表示为 $q$ 进制下的两位数，具体地，我们把 $x$ 表示为了 $Aq+B$（$0 \leq A,B&amp;lt;q$），然后上述公式就可以化成 $a^{Aq+B} \equiv b \pmod{p}$，即 $a^{Aq} \times a^B \equiv b \pmod{p}$。&lt;/p&gt;</description>
    </item>
    <item>
      <title>CDQ分治</title>
      <link>https://qjwh.github.io/posts/oi/aln/cdq/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/cdq/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;
&lt;p&gt;CDQ分治是一种解决三维、四维偏序的算法。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-三维偏序&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 三维偏序&lt;/h2&gt;
&lt;p&gt;三维偏序问题形如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有 $q$ 次询问，每次询问有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改：会给定 $t$、$x$、$y$、$v$，表示在时刻 $t$，在二维坐标 $(x,y)$ 上加上权值 $v$，修改会永久改变权值 &lt;del&gt;（废话）&lt;/del&gt;。&lt;/li&gt;
&lt;li&gt;查询：会给定 $t$、$x$、$y$，表示求在时刻 $t$ 时，所有满足 $x&amp;rsquo; \leq x$，$y&amp;rsquo; \leq y$ 的二维坐标 $(x&amp;rsquo;,y&amp;rsquo;)$ 上的权值和。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;$q \leq 2 \times 10^5$&lt;/li&gt;
&lt;li&gt;$t,x,y \leq 2 \times 10^5$&lt;/li&gt;
&lt;li&gt;$v \leq 10^9$&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;这种问题都有一个通用的解决方法，就是CDQ分治，接下来我们讲一下算法的原理。&lt;/p&gt;
&lt;p&gt;我们先把所有的询问离线下来，然后按时刻（第一维）升序排序，显然排序前和排序后，相同询问答案不变。&lt;/p&gt;
&lt;p&gt;接下来我们定义函数 $\text{solve}(l,r)$，代表只考虑 $l \sim r$ 内的修改，然后准确回答 $l \sim r$ 内的询问。&lt;/p&gt;
&lt;p&gt;既然是分治，我们就要构建好整个分治思路，像这道题，就这样做：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到 $mid$ 为区间 $[l,r]$ 的中点 $\left\lfloor \dfrac{l+r}{2} \right\rfloor$。&lt;/li&gt;
&lt;li&gt;考虑 $l \sim mid$ 内的修改对 $l \sim mid$ 内的询问的影响：递归调用 $\text{solve}(l,mid)$。&lt;/li&gt;
&lt;li&gt;考虑 $mid+1 \sim r$ 内的修改对 $mid+1 \sim r$ 内的询问的影响：递归调用 $\text{solve}(mid+1,r)$。&lt;/li&gt;
&lt;li&gt;考虑 $l \sim mid$ 内的修改对 $mid+1 \sim r$ 内的询问的影响：
&lt;ul&gt;
&lt;li&gt;把 $l \sim mid$ 内的修改，和 $mid+1 \sim r$ 内的询问，统统存入一个数组 $b$。&lt;/li&gt;
&lt;li&gt;把 $b$ 中所有元素按 $x$ 坐标（第二维）升序排序。
&lt;blockquote&gt;
&lt;p&gt;有人对这一步的正确性有疑问，此处解释一下。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kruskal重构树</title>
      <link>https://qjwh.github.io/posts/oi/aln/kruskalcgs/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/kruskalcgs/</guid>
      <description>&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;老师讲解&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/Fighting_Peter/article/details/109149369&#34;&gt;Fighting_Peter 的文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实Kruskal重构树并不难。&lt;/p&gt;
&lt;h2 id=&#34;概览&#34;&gt;概览&lt;/h2&gt;
&lt;p&gt;首先，Kruskal重构树，顾名思义就是把整棵树重构。&lt;/p&gt;
&lt;p&gt;并且其是基于Kruskal算法的。&lt;/p&gt;
&lt;p&gt;它能解决很多问题，并且变种很多。&lt;/p&gt;
&lt;p&gt;但我们先从基础的实现说起。&lt;/p&gt;
&lt;h2 id=&#34;实现过程&#34;&gt;实现过程&lt;/h2&gt;
&lt;p&gt;我们考虑，在Kruskal算法里，我们每次会合并两个并查集集合。&lt;/p&gt;
&lt;p&gt;准确来说是在两个点 $u$、$v$ 之间加一个边权为 $w$ 的无向边。&lt;/p&gt;
&lt;p&gt;那么，我们就考虑，在重构树里，我们找到 $u$ 和 $v$ 分别所在的子树，把这两个子树的根拎出来，设为 $u&amp;rsquo;$ 和 $v&amp;rsquo;$。&lt;/p&gt;
&lt;p&gt;然后，我们就新建一个点 $w$，然后把 $u&amp;rsquo;$ 和 $v&amp;rsquo;$ 的父亲设为 $w$。&lt;/p&gt;
&lt;p&gt;此时我们就得到了另外一棵树。&lt;/p&gt;
&lt;p&gt;比如说这个例子：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/4t6kbaq1.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;而在代码中，我们需要给这些方点一个别的编号，而不是以 $w$ 作为编号，否则会重，并且会炸。&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性&lt;/h2&gt;
&lt;p&gt;我们讲一些Kruskal重构树的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这棵树一定是二叉树。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原树中的点放到重构树上一定是叶子，重构树上其他点都是原树中的边权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;节点个数一定是 $2n-1$，且 $2n-1$ 一定是根。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是最小生成树，那么这棵重构树一定是大根堆&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，否则是小根堆。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原图中两个点 $u$、$v$ 之间所有路径上的边权最大值的最小值，就是该图的最小生成树重构树上，$u$ 和 $v$​ 的LCA的权值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;尚未想到证明方式&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于一个最小生成树上的点 $x$，其只通过（边权）不超过 $v$ 的边，能到的点集；和 $x$ 在重构树上深度最浅的、权值 $\leq v$ 的点 $y$ 的子树内（叶子）节点集合，是一样的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里稍微证明一下。&lt;/p&gt;
&lt;p&gt;就是我们根据上面的性质，可以发现，设后者对应集合为 $S$，那么显然 $S$ 内的点，和 $x$ 点，的LCA的权值一定不超过 $v$，显然。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Lucas定理</title>
      <link>https://qjwh.github.io/posts/oi/aln/lucas/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/lucas/</guid>
      <description>&lt;p&gt;（以下全部假设 $C_n^m$ 中的 $n$ 和 $m$ 都很大，最大能达到 $10^{18}$）&lt;/p&gt;
&lt;h2 id=&#34;lucas定理&#34;&gt;Lucas定理&lt;/h2&gt;
&lt;p&gt;Lucas定理往往用于求组合数的结果且&lt;strong&gt;模数较小&lt;/strong&gt;的题目。&lt;/p&gt;
&lt;p&gt;其实定理很简单，也很好记，$\Large C_n^m=C_{\lfloor \frac{n}{p} \rfloor}^{\lfloor \frac{m}{p} \rfloor} \times \color{orange} C_{n \bmod p}^{m \bmod p}$，在 $p$ 为质数的条件成立。&lt;/p&gt;
&lt;p&gt;上面之所以强调模数较小，是因为我们需要通过预处理阶乘的方式去求橙色项的值。&lt;/p&gt;
&lt;p&gt;代码实现很简单，此处略。&lt;/p&gt;
&lt;p&gt;但有个注意点，在我的代码模板里，由于求&lt;code&gt;facny&lt;/code&gt;数组是递推求出的，而不是每个分别去用&lt;code&gt;getny&lt;/code&gt;求出的，所以调用&lt;code&gt;init&lt;/code&gt;函数时，传参应该是&lt;code&gt;MOD-1&lt;/code&gt;而不是&lt;code&gt;MOD&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;exlucas定理&#34;&gt;exLucas定理&lt;/h2&gt;
&lt;p&gt;&lt;del&gt;（前方高能）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;这个定理还是解决求 $C_n^m \bmod p$ 的值的问题，$p$ 仍然很小，但&lt;strong&gt;不保证是质数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据M2579的做法，我们可以考虑对 $p$ 做一个唯一分解，分解成 ${p_1}^{a_1} \times {p_2}^{a_2} \times {p_3}^{a_3} \times \dots \times {p_k}^{a_k}$。&lt;/p&gt;
&lt;p&gt;然后，分别求出 $C_n^m \bmod {p_1}^{a_1}$ 的值、$C_n^m \bmod {p_2}^{a_2}$ 的值、$C_n^m \bmod {p_3}^{a_3}$ 的值、&amp;hellip;、$C_n^m \bmod {p_k}^{a_k}$ 的值，然后就可以用CRT求出 $C_n^m \bmod p$ 的值了。&lt;/p&gt;
&lt;p&gt;在M2579内，$p$ 唯一分解后，每个 $a_i$ 都等于 $1$，所以直接用Lucas定理就可以求，但在一般的题目中，指数不一定都等于 $1$，所以才要用到exLucas定理。&lt;/p&gt;</description>
    </item>
    <item>
      <title>nth_element（未完工）</title>
      <link>https://qjwh.github.io/posts/oi/aln/nthelement/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/nthelement/</guid>
      <description></description>
    </item>
    <item>
      <title>wqs二分</title>
      <link>https://qjwh.github.io/posts/oi/aln/wqs/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/wqs/</guid>
      <description>&lt;p&gt;感谢&lt;a href=&#34;https://www.acwing.com/file_system/file/content/whole/index/content/5873556/&#34;&gt;这篇文章&lt;/a&gt;的作者。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;wqs二分一般解决这类问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有 $n$ 个物品，你要选出恰好 $m$ 个（下称“选择物品个数限制”），可能有限制（下称“其他限制”），你要最大/小化某个权值。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;但除此之外，还有一些限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果我们设 $g_i$ 为选出恰好 $i$ 个时的最大/小权值，那么 $g$ 函数就应该是上凸（求最大权值）/下凹（求最小权值）的，即斜率单调递减（上凸）/递增（下凹）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一般来说&lt;/strong&gt;，如果没有任何限制（包括选择物品个数限制和其他限制），那么答案是很好求的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一般来说&lt;/strong&gt;，如果没有其他限制，那么选择物品数量越多，最小权值就越大/小。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;以下是&lt;a href=&#34;https://www.luogu.com.cn/problem/P5633&#34;&gt;P5633&lt;/a&gt;的题解，顺带着讲了wqs二分的原理和应用。&lt;/p&gt;
&lt;p&gt;在原题中，我们可以以标号为 $s$ 点在最小生成树上的出度为横坐标，以这个出度对应的答案为纵坐标，画出图像：（网上粘的图，只画了部分横坐标的情况）&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.acwing.com/media/article/image/2022/06/21/58579_3af7039bf1-%E4%B8%8B%E5%87%B8%E5%A3%B3.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;显然D和E点就是最小值点。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;接下来就是wqs二分的重点了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;wqs二分也是二分，那它二分什么值呢，它二分的是斜率 $mid$。&lt;/p&gt;
&lt;p&gt;具体而言，一个斜率就对应若干条平行的边，而总有一条边是完全切这个凸包的，如 $mid=-1$ 的时候，上图中被且的那个点就刚好是C点：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.acwing.com/media/article/image/2022/06/21/58579_3213b178f1-%E5%88%87%E7%BA%BF.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果我们设题目要求 $s$ 的度数要恰好为 $6$，那么 $mid=-1$ 的时候被切的那个点C的纵坐标就是答案了。&lt;/p&gt;
&lt;p&gt;但此时我们就有两个问题了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何求出被切的那个点的下标？&lt;/li&gt;
&lt;li&gt;就算求出了下标，那这个点的纵坐标又如何计算？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来我们来解决这两个问题。&lt;/p&gt;
&lt;p&gt;首先，这个切线肯定是所有经过某个点且斜率等于 $mid$ 的直线中截距最小的点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;具体地，根据切线的性质，在上述例子中，经过C点的斜率等于 $mid$ 的直线（即切线），与经过D点的斜率等于 $mid$ 的直线、经过E点的斜率等于 $mid$ 的直线相比，切线的截距肯定最小，后两者的截距肯定更大。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;其次，显然，经过点 $(x,y)$ 且斜率等于 $k$ 的直线（肯定唯一），其截距一定等于 $y-kx$（$y=kx+b$，$b=y-kx$）。&lt;/p&gt;
&lt;p&gt;而在二分的&lt;code&gt;calc&lt;/code&gt;函数（此处不是&lt;code&gt;check&lt;/code&gt;函数了，&lt;code&gt;calc&lt;/code&gt;函数的返回值、返回值含义以及应用见下）中，我们已经知道了上述公式中的 $k$ 了（$k=mid$），所以我们只要让 $y-kx$ 最小、斜率为 $k$ 且经过了某个图上的点即可。&lt;/p&gt;
&lt;p&gt;考虑到上述公式中的 $x$ 未知，所以我们可以干脆把所有 $s$ 的出边的边权都减 $mid$。&lt;em&gt;（关于是加、减还是都彳亍的问题存疑）&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>博弈论三种扩展题型</title>
      <link>https://qjwh.github.io/posts/oi/aln/games/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/games/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;
&lt;p&gt;下面是三道与博弈论相关的题目及其做法。&lt;/p&gt;
&lt;h1 id=&#34;text-stylecolorrgb0150136-题目1皮肤病&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题目1：皮肤病&lt;/h1&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-题面&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题面&lt;/h2&gt;
&lt;p&gt;（改编自《不可思议事件簿 第5册 魔法学院》，由艾教提供变体）&lt;/p&gt;
&lt;p&gt;（原题名称：加试难题）&lt;/p&gt;
&lt;p&gt;在一个学校内，共有 $100$ 个人，每个人都养了一只狗。&lt;/p&gt;
&lt;p&gt;但由于某些原因，校长确定了这 $100$ 条狗内，必然存在至少一条狗有皮肤病。&lt;/p&gt;
&lt;p&gt;现在那些学生要确定一下哪些狗有皮肤病。&lt;/p&gt;
&lt;p&gt;他们准备这样确定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每天上午的时候，所有人看一下&lt;strong&gt;除了自己的狗之外&lt;/strong&gt;的所有狗。&lt;/li&gt;
&lt;li&gt;如果确认自己的狗病了，就在晚上敲一下宠物房内的钟。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在已知：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无论谁，看那只狗，都能立刻确认它是否有皮肤病。&lt;/li&gt;
&lt;li&gt;假设皮肤病不会对狗的寿命造成影响，即所有的狗都不会死亡。&lt;/li&gt;
&lt;li&gt;皮肤病不能传染，并且忽略“人患病”造成的影响。&lt;/li&gt;
&lt;li&gt;所有人都绝顶聪明（废话&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并且：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 $1$ 天晚上，没有钟声响起。&lt;/li&gt;
&lt;li&gt;第 $2$ 天晚上，没有钟声响起。&lt;/li&gt;
&lt;li&gt;第 $3$ 天晚上，没有钟声响起。&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;li&gt;直到第 $10$ 天晚上，终于有钟声响起了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请问：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;那天晚上，共有多少人共同敲响了钟？&lt;/li&gt;
&lt;li&gt;在第 $10$ 天后，除了那些敲钟的人养的狗，是否会存在其他病了的狗？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-答案&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 答案&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;$10$ 个人&lt;/li&gt;
&lt;li&gt;不会&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-题解&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题解&lt;/h2&gt;
&lt;p&gt;我们考虑一下，如果说第 $1$ 天晚上有人敲钟，那么代表啥。&lt;/p&gt;
&lt;p&gt;我们从人的角度考虑，如果说一个人发现其他狗都是好狗（指没有皮肤病的狗），那么必然自己的狗有皮肤病 &lt;del&gt;（除了自己的，还有谁的？难不成是他自己？）&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;这种情况下，他便会去敲钟。&lt;/p&gt;
&lt;p&gt;但第 $1$ 天晚上没有钟声，所以每个人都观察到了至少 $1$ 个病狗，也就是说至少有 $2$ 个病狗。&lt;/p&gt;
&lt;p&gt;随后第 $2$ 天，如果说一个人观察到其他的狗内，只有 $1$ 个病狗，那么显然自己的狗也得有皮肤病。&lt;/p&gt;</description>
    </item>
    <item>
      <title>点分治</title>
      <link>https://qjwh.github.io/posts/oi/aln/dfz/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/dfz/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;
&lt;p&gt;点分治和树剖有一个相同点，就是算法都是从暴力经过一小步优化而来，但就是这一小步，让算法复杂度有了质的飞跃。&lt;/p&gt;
&lt;p&gt;下面来讲一下这个算法的原理。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-概览&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 概览&lt;/h2&gt;
&lt;p&gt;其实“点分治”也是一个名不副实的算法，看完下面的讲述你就会发现这个算法根“分治”几乎无关。&lt;/p&gt;
&lt;p&gt;点分治是专门解决树上路径统计的一种算法（树剖则是解决对树上路径的判断的算法）。&lt;/p&gt;
&lt;p&gt;点分治的思想很朴素，就是DFS一下 $\text{lca}$ 的节点编号 $x$，然后统计 $\text{lca}$ 值刚好为 $x$ 的、满足题目条件的路径的数量，并累加到答案。&lt;/p&gt;
&lt;p&gt;但直接进行统计还是炸裂的，点分治则是对这种统计方式做了一步优化&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-解决题型&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解决题型&lt;/h2&gt;
&lt;p&gt;上面说了，「点分治是专门解决树上路径统计的一种算法」，但并不是所有的树上路径统计都可以用点分治解决。&lt;/p&gt;
&lt;p&gt;其实看完下面的实现，你就能知道它解决什么类问题，不过这里还是说一下。&lt;/p&gt;
&lt;p&gt;就是首先，这个条件是形如“总和比某个值低”、“总和是某个值的倍数”等“可累加”的条件。&lt;/p&gt;
&lt;p&gt;其中“可累加”指的是，如果知道了 $A$ 部分的某个值，和 $B$ 部分的某个值，那么 $A$ 和 $B$ 部分合并后的部分是否合法也一定知道。&lt;/p&gt;
&lt;p&gt;但其他的条件目前还没有太明确，得自己去总结。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-算法实现&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 算法实现&lt;/h2&gt;
&lt;p&gt;下面说一下点分治的实现。&lt;/p&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-大体思路&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 大体思路&lt;/h3&gt;
&lt;p&gt;我们拿“路径长度（路径上的边的边权之和）刚好为 $k$”问题举例。&lt;/p&gt;
&lt;p&gt;注：原题链接&lt;a href=&#34;https://www.luogu.com.cn/problem/P3806&#34;&gt;P3806&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;就是我们考虑，当DFS到某个点 $x$ 的时候，就如上所说，设 $x$ 为 $\text{lca}$ 值。&lt;/p&gt;
&lt;p&gt;然后，我们按顺序遍历所有子节点 $to$。&lt;/p&gt;
&lt;p&gt;由于只要两个点 $y$、$z$ 满足 $y$ 和 $z$ 分别在 $x$ 的两个不同儿子及其子树内，那么 $\text{lca}(y,z)=x$。&lt;/p&gt;
&lt;p&gt;并且所有满足条件 $\text{lca}(y,z)=x$ 的对 $(y,z)$ 只有满足上述条件的对。&lt;/p&gt;
&lt;p&gt;所以，我们可以通过（另一种）DFS（方式）求出 $to$ 到 ( 所有 $to$ 及其子树内的点 ) 之间的距离（加上 $x \to to$ 的边权）的集合 $T$。&lt;/p&gt;</description>
    </item>
    <item>
      <title>基尔霍夫矩阵</title>
      <link>https://qjwh.github.io/posts/oi/aln/kirchhoffmatrix/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/kirchhoffmatrix/</guid>
      <description>&lt;p&gt;基尔霍夫矩阵是用来求解生成树计数、求（权值）和相关题目的利器。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-0-求完全图的生成树数量prufer序列&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 0. 求完全图的生成树数量（Prufer序列）&lt;/h3&gt;
&lt;p&gt;要说基尔霍夫矩阵，就要从一道题目说起：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给你 $n$，问 $n$ 个节点组成的无向无根树有多少种。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;这道题可以用Prufer序列去做。&lt;/p&gt;
&lt;p&gt;这里简单说一下Prufer序列的求法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一张无向无根树，重复执行以下操作直到只剩 $2$ 个或更少的点，最后得到的那个序列 $a$ 就是这棵树的Prufer序列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们找到此时度为 $1$ 的节点，若有多个，找编号最小的，设找到的节点编号为 $x$。&lt;/li&gt;
&lt;li&gt;在 $a$ 的末尾添加：与 $x$ 有连边的那个唯一节点。&lt;/li&gt;
&lt;li&gt;删除 $x$。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;Prufer序列别看求法非常简单，也没啥容易发现的性质，其实用处很大。&lt;/p&gt;
&lt;p&gt;Prufer序列满足一个性质，就是，所有无向无根树，都可以唯一地对应一个Prufer序列；所有Prufer序列都可以唯一地对应一棵树。&lt;/p&gt;
&lt;p&gt;所以，这道题就有解了，答案其实就是长为 $n-2$ 的Prufer序列有多少种。&lt;/p&gt;
&lt;p&gt;由于Prufer序列的每个元素的值都是从 $1$ 到 $n$ 的，所以答案就是 $n^{n-2}$，显然。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-11-求任意无向图的生成树数量基尔霍夫矩阵&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 1.1. 求任意无向图的生成树数量（基尔霍夫矩阵）&lt;/h3&gt;
&lt;p&gt;但如果把题目变化一下，就不能用Prufer序列去求了：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一张 $n$ 个节点 $m$ 条边的无向图，问这张图的生成树有多少个。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;这题要用基尔霍夫矩阵。&lt;/p&gt;
&lt;p&gt;具体地，我们定义 $D$ 矩阵，求法：&lt;/p&gt;
&lt;p&gt;$
D_{i,j}=
\begin{cases}
0 &amp;amp; i \not= j \
\text{deg}(i) &amp;amp; i=j
\end{cases}
$&lt;/p&gt;
&lt;p&gt;其中，$\text{deg}(i)$ 代表这张图上 $i$ 的度是多少。&lt;/p&gt;</description>
    </item>
    <item>
      <title>阶和原根</title>
      <link>https://qjwh.github.io/posts/oi/aln/orderandpr/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/orderandpr/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;
&lt;p&gt;按照正常的思路我们都直接将算法，但这会先讲一道题，然后再讲它的定义和求法。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/676549667&#34;&gt;ABC335G题解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/ac-evil/p/12809289.html&#34;&gt;阶和原根&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-背景&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 背景&lt;/h2&gt;
&lt;p&gt;是一场&lt;a href=&#34;https://atcoder.jp/contests/abc335&#34;&gt;ABC335&lt;/a&gt;里的&lt;a href=&#34;https://atcoder.jp/contests/abc335/tasks/abc335_g&#34;&gt;G题&lt;/a&gt;，当时在赛场上大概留了一个多小时的时间，但一直都在想用&lt;a href=&#34;https://qjwh.github.io/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BSGS%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%9D%E7%89%88%EF%BC%89.md&#34;&gt;BSGS&lt;/a&gt;，但显然最后没想出来。&lt;/p&gt;
&lt;p&gt;而这题的瓶颈就在下面问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于两个数 $a,b$，是否存在一个 $x$ 使得同余方程 $a^x \equiv b \pmod p$ 有解。&lt;/p&gt;
&lt;p&gt;$a,b,p \leq 10^{13}$（原题数据范围）&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;大家看到的第一眼显然可以用&lt;a href=&#34;https://qjwh.github.io/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BSGS%E7%AE%97%E6%B3%95%EF%BC%88%E5%88%9D%E7%89%88%EF%BC%89.md&#34;&gt;BSGS&lt;/a&gt;求。&lt;/p&gt;
&lt;p&gt;但这个算法是 $O(\sqrt p)$ 的（如果涉及到具体实现的话，可能还得乘个 $\log \sqrt p$，就是&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;lower_bound&lt;/code&gt;查找的复杂度），比较适用于单组询问，很难推广应用。&lt;/p&gt;
&lt;p&gt;所以还有另外一种方式，比较适用于多组询问。&lt;/p&gt;
&lt;p&gt;是我们求出来 $a$ 和 $b$ 的阶，即 $\text{ord}_p a$ 和 $\text{ord}_p b$，看 $\text{ord}_p b$ 是否是 $\text{ord}_p a$ 的因子（$\text{ord}_p b \mid \text{ord}_p a$）即可。&lt;/p&gt;
&lt;p&gt;这里先不证这个结论是否正确，但相信大家第一次看到“阶”的时候定然是一头雾水的，下面我就来说一下它的定义和求法。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-定义&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义&lt;/h2&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-阶&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 阶&lt;/h3&gt;
&lt;p&gt;阶的话，跟逆元相似，还是需要两个值，只不过这里叫做“$a$ 在模 $p$ 意义下的&lt;strong&gt;阶&lt;/strong&gt;”而已，换汤不换料。&lt;/p&gt;
&lt;p&gt;这个表示方法就是 $\text{ord}_p a$。&lt;/p&gt;
&lt;p&gt;它的定义是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给你整数 $a$、$p$。&lt;/li&gt;
&lt;li&gt;找到最小的 $x$，使得同余方程 $a^x \equiv 1 \pmod p$ 成立。&lt;/li&gt;
&lt;li&gt;这个 $x$，就是$a$ 在模 $p$ 意义下的阶。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-原根&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 原根&lt;/h3&gt;
&lt;p&gt;但说到阶，我们定要讲一下它的孪生兄弟，原根了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>决策单调性</title>
      <link>https://qjwh.github.io/posts/oi/aln/juecedandiaoxing/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/juecedandiaoxing/</guid>
      <description>&lt;h2 id=&#34;二维决策单调性&#34;&gt;二维决策单调性&lt;/h2&gt;
&lt;p&gt;对于形如 $d_{i,j}=\min\limits_{k=0}^{i-1} \Big( d_{k,j-1}+w(k+1,i) \Big)$ 的方程，我们尝试记录 $f_{i,j}$ 代表 $d_{i,j}$ 的最优转移点（$k$ 变量），如果有 $f_{i,j-1} \leq f_{i,j} \leq f_{i+1,j}$，那么就是经典的四边形不等式优化，复杂度为 $O(n^2)$，证明此处略（在&amp;quot;四边形不等式相关.md&amp;quot;里有）。&lt;/p&gt;
&lt;p&gt;但是，如果只有 $f_{i,j} \leq f_{i+1,j}$，那么就不能用四边形不等式优化了，需要用分治的方式优化。&lt;/p&gt;
&lt;p&gt;具体地，我们从小到大枚举 $j$，然后转移所有的 $d_{i,j}$。&lt;/p&gt;
&lt;p&gt;定义分治函数&lt;code&gt;dp(l,r,jl,jr)&lt;/code&gt;代表我们要转移所有的 $d_{i,j}$（$l \leq i \leq r$），并且保证所有在本次分治转移范围内的 $d_{i,j}$ 的转移点 $f_{i,j}$ 都在 $[jl,jr]$ 内。&lt;/p&gt;
&lt;p&gt;我们可以先求出 $[l,r]$ 的中点 $mid$，然后转移 $d_{mid,j}$：暴力枚举转移点 $k$（当然，要在 $[jl,jr]$ 内）进行转移，并递归&lt;code&gt;dp(l,mid-1,jl,最终转移点)&lt;/code&gt;和&lt;code&gt;dp(mid+1,r,最终转移点,jr)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该算法复杂度为 $O(n^2 \log n)$，证明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先，枚举 $j$ 的复杂度 $O(n)$。&lt;/p&gt;
&lt;p&gt;其次，只看 $[jl,jr]$，$[jl,jr]$ 在递归的过程中就形成了个线段树的类似结构，只不过单层内可能有部分重叠位置，而且划分点（上面说的“最终转移点”）可能不是中点，不过无关紧要。&lt;/p&gt;
&lt;p&gt;然后，再看 $[l,r]$，$[l,r]$ 在递归过程中也形成了类似于线段树的结构，并且易证这个递归树深度是不会超过 $\log n$ 的。&lt;/p&gt;
&lt;p&gt;有了深度的保证，而且一层内的 $[jl,jr]$ 区间长度和最多只有 $O(n)$ 级别，所以一次分治的复杂度就是 $O(n \log n)$。&lt;/p&gt;</description>
    </item>
    <item>
      <title>类欧几里得算法</title>
      <link>https://qjwh.github.io/posts/oi/aln/similargcd/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/similargcd/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;
&lt;p&gt;来源：&lt;a href=&#34;https://atcoder.jp/contests/abc372/tasks/abc372_g&#34;&gt;ABC372G&lt;/a&gt;&lt;a href=&#34;https://atcoder.jp/contests/abc372/editorial/10988&#34;&gt;官方题解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;贡献：&lt;a href=&#34;https://oi-wiki.org/math/number-theory/euclidean&#34;&gt;OI Wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个算法确实挺妙的，所以我就写个笔记。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-定义&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义&lt;/h2&gt;
&lt;p&gt;这个算法需要用到一个函数：&lt;/p&gt;
&lt;p&gt;$$
f(a,b,c,n)=\sum\limits_{i=0}^n \left\lfloor \dfrac{\color{red}a\color{default}i+\color{blue}b\color{default}}{\color{green}c\color{default}} \right\rfloor
$$&lt;/p&gt;
&lt;p&gt;在下面参数 $a$、$b$、$c$ 都会用三种颜色标出，以便于区分。&lt;/p&gt;
&lt;p&gt;因为 $a$、$b$、$c$、$n$ 都很大，所以我们没法直接暴力求。&lt;/p&gt;
&lt;p&gt;数论分块显然也不彳亍。&lt;/p&gt;
&lt;p&gt;所以我们只能另辟蹊径了。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-求值&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 求值&lt;/h2&gt;
&lt;p&gt;咱从简单到复杂走。&lt;/p&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-1&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 1&lt;/h3&gt;
&lt;p&gt;首先，我们可以知道：&lt;/p&gt;
&lt;p&gt;$$
\begin{aligned}
f(a,b,c,n)&amp;amp;=\sum\limits_{i=0}^n \left\lfloor \dfrac{\color{red}a\color{default}i+\color{blue}b\color{default}}{\color{green}c\color{default}} \right\rfloor \
&amp;amp;=\sum\limits_{i=0}^n \left\lfloor \dfrac{(\lfloor \frac{a}{c} \rfloor c + a \bmod c)i+(\lfloor \frac{b}{c} \rfloor c + b \bmod c)}{c} \right\rfloor \
&amp;amp;=\sum\limits_{i=0}^n \left\lfloor \dfrac{\lfloor \frac{a}{c} \rfloor c \cdot i + a \bmod c \cdot i+\lfloor \frac{b}{c} \rfloor c + b \bmod c}{c} \right\rfloor \
&amp;amp;=\sum\limits_{i=0}^n \left( \left\lfloor \frac{a}{c} \right\rfloor i + \left\lfloor \frac{b}{c} \right\rfloor + \left\lfloor \dfrac{a \bmod c \cdot i+b \bmod c}{c} \right\rfloor \right) \
&amp;amp;=\dfrac{n(n+1)}{2} \left\lfloor \frac{a}{c} \right\rfloor + (n+1) \left\lfloor \frac{b}{c} \right\rfloor + \sum\limits_{i=0}^n \left\lfloor \dfrac{\color{red}a \bmod c\color{default} \cdot i+\color{blue}b \bmod c\color{default}}{\color{green}c\color{default}} \right\rfloor \
&amp;amp;=\dfrac{n(n+1)}{2} \left\lfloor \frac{a}{c} \right\rfloor + (n+1) \left\lfloor \frac{b}{c} \right\rfloor + f(a \bmod c,b \bmod c,c,n) \
\end{aligned}
$$&lt;/p&gt;</description>
    </item>
    <item>
      <title>马拉车算法</title>
      <link>https://qjwh.github.io/posts/oi/aln/manacher/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/manacher/</guid>
      <description>&lt;text style=&#34;font-family:Lato,楷体&#34;&gt;
&lt;p&gt;马拉车算法其实就是解决一个字符串中由某个位置为中心的最大回文串长度：（下图中蓝色部分为字符串，绿色框中的值就是以这个位置为中心的最大回文串长度）&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/z9ugcm59.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;其次，我们发现最底下的一排绿色数字涉及到空隙，所以我们可以把字符串扩展一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;比如，原字符串是 $\texttt{abccabbc}$，那么扩展之后就是：&lt;/p&gt;
&lt;p&gt;（LaTeX炸了）
$\texttt{\color{RoyalBlue}@\color{default}#\color{default}a\color{RoyalBlue}#\color{default}b\color{RoyalBlue}#\color{default}c\color{RoyalBlue}#\color{default}c\color{RoyalBlue}#\color{default}a\color{RoyalBlue}#\color{default}b\color{RoyalBlue}#\color{default}b\color{RoyalBlue}#\color{default}c\color{RoyalBlue}#\color{RoyalBlue}&amp;amp;}$&lt;/p&gt;
&lt;p&gt;第一个和最后一个字符可以自己定，但是最好不要和原字符串中的字符、中间插入的字符冲突（相等）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：其实还有第二种扩展方法：&lt;/p&gt;
&lt;p&gt;$\texttt{\color{RoyalBlue}#\color{default}a\color{RoyalBlue}#\color{default}b\color{RoyalBlue}#\color{default}c\color{RoyalBlue}#\color{default}c\color{RoyalBlue}#\color{default}a\color{RoyalBlue}#\color{default}b\color{RoyalBlue}#\color{default}b\color{RoyalBlue}#\color{default}c\color{RoyalBlue}#\color{default}}$&lt;/p&gt;
&lt;p&gt;还是，中间字符不能与原串字符相等。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;下面统一设「以下标 $i$ 为中心的最大回文串长度&lt;strong&gt;除以 $2$ 并下取整&lt;/strong&gt;」后的答案为 $p_i$。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;然后，我们就开始求 $p$ 数组了，当我们求到 $p_i$ 的时候，我们看前面求出的 $p_j+j$ 的最大值是多少（设为 $r$），即 $\max\limits_{j=1}^{i-1} { p_j+j }$，同时求出最大的 $p_j+j$ 对应的 $j$（设为 $c$）。&lt;/p&gt;
&lt;p&gt;并且，我们求出 $i$ 的对称点 $i&amp;rsquo;$，对称中心为 $c$，显然 $i&amp;rsquo;=2c-i$。&lt;/p&gt;
&lt;p&gt;然后，分类讨论：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：图中 $r$ 的意思与上面说的 $r$ 的意思有冲突，统一以上面说的定义为准。&lt;/p&gt;&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$i&amp;gt;r$，那么暴力算 $p_i$。
&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/cqrtkobp.png&#34;&gt;&lt;/li&gt;
&lt;li&gt;$r-i \geq p_{i&amp;rsquo;}$，那么 $p_i=p_{i&amp;rsquo;}$。
&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/muq7kao8.png&#34;&gt;&lt;/li&gt;
&lt;li&gt;$r-i&amp;lt;p_{i&amp;rsquo;}$，那么让 $p_i=r-i$，继续暴力扩展。
&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/zzacfutp.png&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后就是时间复杂度问题了。&lt;/p&gt;
&lt;p&gt;关于时间复杂度的证明，我们可以分类讨论 $p_i$ 是用那种情况求值的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用情况1转移：$r$ 肯定会增加。&lt;/li&gt;
&lt;li&gt;用情况2转移：复杂度忽略。&lt;/li&gt;
&lt;li&gt;用情况3转移：$r$ 也肯定会增加。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于每时每刻，$r$ 都小于等于 $n$，所以总复杂度就是 $O(n)$ 的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>欧拉函数</title>
      <link>https://qjwh.github.io/posts/oi/aln/eulerfunc/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/eulerfunc/</guid>
      <description>&lt;p&gt;欧拉函数记为 $\varphi$，$\varphi(n)$ 代表 $1 \sim n$ 内与 $n$ 互质的数的个数。&lt;/p&gt;
&lt;p&gt;欧拉函数有两种求法，下面分别说：&lt;/p&gt;
&lt;h3 id=&#34;直接求&#34;&gt;直接求&lt;/h3&gt;
&lt;p&gt;我们设 $p$ 为 $n$ 的质因子集合（非可重集），那么 $\varphi(n)=n \times \prod\limits_{x \in p} \left( \dfrac{x-1}{x} \right)$，原理：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们设 $s$ 为目前与 $n$ 互质的数的集合，初始为 ${ 1,2,\dots,n }$。&lt;/p&gt;
&lt;p&gt;每次遍历到一个 $p$ 中的数 $x$，就会筛掉这个集合中 $\dfrac{1}{x}$ 的数，即那些是 $x$ 的倍数的数，由于 $p$ 是去重后的质因子集合，所以当前集合的大小总是 $x$ 的倍数。&lt;/p&gt;
&lt;p&gt;所以这个做法就能证明了，每乘一次 $\dfrac{x-1}{x}$，都相当于筛掉当前集合内 $\dfrac{1}{x}$ 的数，集合大小动态维护。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;模板代码：（代码中的 $p$ 数组是提前筛出来的质数集合，$ind$ 为其大小）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;LL&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;phi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LL&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;LL&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;rep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;通过线性筛预处理&#34;&gt;通过线性筛预处理&lt;/h3&gt;
&lt;p&gt;线性筛模板：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;shai&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LL&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;rep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LL&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;线性筛有一个性质，就是在第二重循环里，每次都会筛掉数 $i \times p_j$，而 $p_j$ 正是这个数（$i \times p_j$）的最小质因子。&lt;/p&gt;</description>
    </item>
    <item>
      <title>判断拓扑序是否唯一</title>
      <link>https://qjwh.github.io/posts/oi/aln/judgetopounique/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/judgetopounique/</guid>
      <description>&lt;text style=&#34;font-family:Lato,楷体&#34;&gt;
&lt;p&gt;我们现在要解决一个问题，就如标题所说，我们要判断一个DAG的拓扑序是否唯一。&lt;/p&gt;
&lt;p&gt;以下说两种做法。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-做法1推荐&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 做法1（推荐）&lt;/h2&gt;
&lt;p&gt;在拓扑排序时，我们只要每时每刻都判断一下，此时的队列大小是否大于 $1$ 即可。&lt;/p&gt;
&lt;p&gt;因为，如果队列大小大于 $1$，则选择任何一个元素都可以加入到拓扑序的最后下标，所以拓扑序不唯一。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-做法2&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 做法2&lt;/h2&gt;
&lt;p&gt;（以下是我考试时想出来的做法，思维难度较高，但整个构思过程中都没有思维跳跃）&lt;/p&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-1&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 1&lt;/h3&gt;
&lt;p&gt;首先，我们建出这个DAG，然后我们考虑，其实一个DAG唯一，有且仅当对于所有点对 $(u,v)$（$1 \leq u,v \leq n$），都满足以下两点之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点 $u$ 可以到达点 $v$。&lt;/li&gt;
&lt;li&gt;点 $v$ 可以到达点 $u$。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;此处证明一下。&lt;/p&gt;
&lt;p&gt;其实，如果存在一个不满足上述条件的点对 $(u,v)$，那么整张图可能会张这样：（下面标记的 $(u,v)$ 只是其中一个）&lt;/p&gt;
&lt;p&gt;在这种情况里，我们直接把红色集合和蓝色集合里的拓扑序“交换”，变成：&lt;/p&gt;
&lt;p&gt;于是乎，就得到了另一个合法的拓扑序，证毕。&lt;/p&gt;
&lt;p&gt;关于如果满足条件，则拓扑序唯一，此处不多赘述，自行脑补。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-2&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 2&lt;/h3&gt;
&lt;p&gt;上述条件还可以继续变化，变成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于所有点对 $(u,v)$（$1 \leq u,v \leq n$，且 $v$ 的拓扑序比 $u$ 的要大），都满足点 $u$ 可以到达点 $v$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-3&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 3&lt;/h3&gt;
&lt;p&gt;我们考虑定义函数 $f(x)$ 代表拓扑序为 $x$ 的节点，是否能到达所有拓扑序为 $y$（$x&amp;lt;y$）的点。&lt;/p&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-4&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 4&lt;/h3&gt;
&lt;p&gt;我们考虑求 $f(x)$，我们可以枚举拓扑序为 $x$ 的节点 $u$ 的所有出点 $v$（设其拓扑序为 $y$，且排除 $y \leq x$ 的所有点）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>平衡树</title>
      <link>https://qjwh.github.io/posts/oi/aln/balancedtree/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/balancedtree/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;
&lt;p&gt;说到平衡树，很多人的第一印象就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;难学（知识点真多）&lt;/li&gt;
&lt;li&gt;难懂（特别是“旋转”和证明）&lt;/li&gt;
&lt;li&gt;难调（我的某个教练刚学平衡树的时候调了七个小时）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们就来从0开始讲平衡树。&lt;/p&gt;
&lt;p&gt;（注：网上大多数人说到“平衡树”默认指的是“Splay”而不是其他算法）&lt;/p&gt;
&lt;h1 id=&#34;text-stylecolorrgb0150136-定义&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义&lt;/h1&gt;
&lt;p&gt;其实平衡树（Balance Tree，简称BT）不算一种算法，而是一种统称。&lt;/p&gt;
&lt;p&gt;平衡树顾名思义就是非常平衡的树。&lt;/p&gt;
&lt;p&gt;比如说这棵树就非常不平衡：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/88bai0mt.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;而这棵树就比较平衡：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/w7w8hynq.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果说的更形式化，平衡就意味着，对于每个点，其所有子树的大小差都不超过 $1$。&lt;/p&gt;
&lt;p&gt;具体而言，对于每个点 $x$，如果我们把其所有儿子 $to$ 的子树大小都列出来，那么这个数组内最大值和最小值差不超过 $1$。&lt;/p&gt;
&lt;p&gt;而且，大多数平衡树都是二叉树，这一点是为了方便操作和设计算法。&lt;/p&gt;
&lt;h1 id=&#34;text-stylecolorrgb0150136-种类&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 种类&lt;/h1&gt;
&lt;p&gt;听完上面的定义，你就知道了，平衡树就是一类树状数据结构的统称。&lt;/p&gt;
&lt;p&gt;下面就来列举一下这类数据结构都有哪些，以及这些数据结构的简介。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-二叉搜索树binary-search-tree简称bst&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 二叉搜索树（Binary Search Tree，简称BST）&lt;/h2&gt;
&lt;p&gt;大多数平衡树的前置算法，这也就意味着，大多数的平衡树都是基于BST并进行优化、扩展后得到的算法。&lt;/p&gt;
&lt;p&gt;而BST也是线段树（Segment Tree，部分情况下会简称为ST）进行扩展后的算法。&lt;/p&gt;
&lt;p&gt;具体而言，权值线段树和BST都可以维护有序集合，但有时候只能用BST解决。&lt;/p&gt;
&lt;p&gt;BST其实就是把权值“当做”节点编号（讲的时候一般就这么讲，但写的时候不能这么写，是把权值存入该节点的结构体内）。&lt;/p&gt;
&lt;p&gt;然后对于每个点，它都有最多 $2$ 个儿子，左儿子权值 $&amp;lt;$ 当前点权值 $&amp;lt;$ 右儿子权值。&lt;/p&gt;
&lt;p&gt;这样就可以方便查找。&lt;/p&gt;
&lt;p&gt;优点：代码好写，容易讲明白&lt;/p&gt;
&lt;p&gt;缺点：解决题型少，需要写定期重构（又被称作“替罪羊树思想”），复杂度高&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-treap名字不是一个单词而是两个单词tree和heap的结合&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; Treap（名字不是一个单词，而是两个单词Tree和Heap的结合）&lt;/h2&gt;
&lt;p&gt;这个算法给每个节点都添加了一个“优先级”，并让“优先级”满足小/大根堆的性质。&lt;/p&gt;
&lt;p&gt;并且，这里还通过“旋转”操作（最头疼的地方来了）让树尽量平衡，这样会让树高稳定在 $O(\log n)$ 级别。&lt;/p&gt;
&lt;p&gt;（不过注意，在最坏情况下，复杂度会达到 $O(n)$，所以 $O(\log n)$ 只是期望）&lt;/p&gt;
&lt;p&gt;这样，复杂度就降下来了。&lt;/p&gt;
&lt;p&gt;优点：复杂度低，比较容易理解，解决题型多，且容易被识别出&lt;/p&gt;
&lt;p&gt;缺点：比较难写，细节较多，复杂度难证明&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-splay本意为张开但这里不是这个意思&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; Splay（本意为“张开”但这里不是这个意思）&lt;/h2&gt;
&lt;p&gt;这个算法对上面的“旋转”操作又做了一遍扩展，让其能够解决子串翻转问题。&lt;/p&gt;
&lt;p&gt;而且，由于它也会让整棵树尽量平衡，所以树高还是会稳定在 $O(\log n)$ 级别。&lt;/p&gt;</description>
    </item>
    <item>
      <title>生成随机数（未完工）</title>
      <link>https://qjwh.github.io/posts/oi/aln/genrandomnumber/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/genrandomnumber/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/LU_ZHAO/article/details/104305240&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引用头文件（常用）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//生成随机数、设定随机数种子
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;ctime&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//生成随机数种子（1）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//生成随机数种子（2）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//等待（sleep(...)或usleep(...)），该头文件现在不常用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;随机种子&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;srand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;注：随机种子为&lt;code&gt;time(0) ^ clock()&lt;/code&gt;，这个随机种子可以再毫秒级别内生成（大概率）不同的随机种子。&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;取 $[l,r]$ 内的随机数&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define random(l, r) (rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;注：&lt;code&gt;rand&lt;/code&gt;函数只能生成 $[1,32767]$ 内的随机数（见宏&lt;code&gt;RAND_MAX&lt;/code&gt;），大概只能生成位数 $\leq 5$ 的随机数；测试程序：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;LL&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ma&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LL&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;srand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;LL&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;ma&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ma&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;usleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ma&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以此处引用一个新方法：&lt;code&gt;mt19937&lt;/code&gt;（2022/12/24：现在开始使用&lt;code&gt;mt19937_64&lt;/code&gt;了，它可以生成 $[1,2^{64})$ 内的随机数，大一倍）。&lt;/p&gt;
&lt;p&gt;其实它的语法和&lt;code&gt;rand&lt;/code&gt;的语法差不多 &lt;del&gt;（才怪）&lt;/del&gt;，是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;引用头文件（常用）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;random&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//生成随机数、设定随机数种子
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;ctime&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//生成随机数种子（1）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//生成随机数种子（2）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//等待（sleep(...)或usleep(...)），该头文件现在不常用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;随机种子&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;mt19937&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_rand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注：这个随机种子也可以再毫秒级别内生成（大概率）不同的随机种子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;取 $[l,r]$ 内的随机数 &lt;del&gt;（就差一个字符&lt;code&gt;_&lt;/code&gt;而已）&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define random(l, r) (_rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l))
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;据测试，这个函数可以生成在&lt;code&gt;unsigned int&lt;/code&gt;范围内的随机数（即可以生成 $[1,2^{32})$ 内的随机数），测试程序：&lt;/p&gt;</description>
    </item>
    <item>
      <title>树链剖分</title>
      <link>https://qjwh.github.io/posts/oi/aln/treechaindivision/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/treechaindivision/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;
&lt;p&gt;第一次看到树链剖分（简称树剖）可能觉得它非常的深奥，但其实树剖的原理非常简单，下面先说树剖大概的实现思路和解决题型。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-概览&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 概览&lt;/h2&gt;
&lt;p&gt;其实树剖就是把一棵树分成若干条链，使得每个点都出现在了刚好一条链上。&lt;/p&gt;
&lt;p&gt;并且，我们称在某条链上的边为“重（zhòng）边”，不在任何一条链上的边为“轻边”。&lt;/p&gt;
&lt;p&gt;然后，我们按某种规则去DFS，求出新的DFS序，然后解决对树上路径询问的问题。&lt;/p&gt;
&lt;p&gt;而且，通过合理的设计每条边的轻重，可以把复杂度控制在 $O(\log n)$ 级别。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-解决题型&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解决题型&lt;/h2&gt;
&lt;p&gt;上面也提到了，树剖就是用来解决对树上路径进行询问的问题的算法，当然也可以解决对子树询问的问题，不过属于大材小用了。&lt;/p&gt;
&lt;p&gt;此外，树剖属于工具类算法，所以往往会配合树状数组、线段树、分块等算法出现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我把算法分为了两类，“材料类算法”和“工具类算法”，其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;材料类算法可以单独考，比如：
&lt;ul&gt;
&lt;li&gt;数论&lt;/li&gt;
&lt;li&gt;推公式&lt;/li&gt;
&lt;li&gt;DP&lt;/li&gt;
&lt;li&gt;树状数组&lt;/li&gt;
&lt;li&gt;线段树&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工具类算法里面必须要套材料类算法才能考出来，比如：
&lt;ul&gt;
&lt;li&gt;二分&lt;/li&gt;
&lt;li&gt;01分数规划（二分的一个分支）&lt;/li&gt;
&lt;li&gt;CDQ分治（需要配合树状数组）&lt;/li&gt;
&lt;li&gt;整体二分（需要配合树状数组）&lt;/li&gt;
&lt;li&gt;树剖（这里讲的）&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;往往一些较难的题目，都是要用较难的材料类算法（比如DP），或者工具类算法配合材料类算法才能解决的题目。&lt;/p&gt;
&lt;p&gt;而对于后者，难度会更大一些，因为后者的关键在于&lt;strong&gt;转化&lt;/strong&gt;后使用工具类算法解决。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-算法实现&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 算法实现&lt;/h2&gt;
&lt;p&gt;下面说一下树剖的实现。&lt;/p&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-两遍dfs&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 两遍DFS&lt;/h3&gt;
&lt;p&gt;我们考虑DFS，当递归到点 $x$ 的时候，找到 $x$ 的儿子中，子树大小最大的那个儿子 $to$。&lt;/p&gt;
&lt;p&gt;然后，我们把 $x \to to$ 这条边设为重边，其他边设为轻边。&lt;/p&gt;
&lt;p&gt;得到每条边的轻重后，我们再做一遍DFS。&lt;/p&gt;
&lt;p&gt;而这一遍DFS是为了找到DFS序。&lt;/p&gt;
&lt;p&gt;而且，DFS序有一个要求，我们要先遍历有重边连接的儿子。&lt;/p&gt;
&lt;p&gt;这样的话，对于任意一条树上的链，链上所有点的DFS序连续，而且是由深度从浅到深依次递增。&lt;/p&gt;
&lt;p&gt;同时，我们还要求出，从一个点开始，不经过任何轻边，最多到哪个点。&lt;/p&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-解决询问&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解决询问&lt;/h3&gt;
&lt;p&gt;而对于一次路径上某值的询问，我们可以把这个路径拆成若干条链。&lt;/p&gt;
&lt;p&gt;可以证明链数不超过 $O(\log n)$，这一点会在下面“复杂度证明”中证明。&lt;/p&gt;
&lt;p&gt;而这些拆出的链，都是原树中的链的“子集”（一条链 $L_1$ 是另外一条链 $L_2$ 的子集，有且仅当 $L_1$ 中的点，$L_2$ 中也有，边同理）。&lt;/p&gt;
&lt;p&gt;所以，可以把一条路径，拆成最多 $O(\log n)$ 个DFS序区间。&lt;/p&gt;</description>
    </item>
    <item>
      <title>四边形不等式</title>
      <link>https://qjwh.github.io/posts/oi/aln/quadrangleinequality/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/quadrangleinequality/</guid>
      <description>&lt;p&gt;（四边形不等式看标题可能觉得很难，其实比较简单）&lt;/p&gt;
&lt;p&gt;四边形不等式是一种DP优化的技巧，一般针对二维DP进行优化。&lt;/p&gt;
&lt;p&gt;在DP中，往往会有多个决策点，而其中就有一个是最优的，设 $d_{i,j}$ 的最优决策点为 $f_{i,j}$。&lt;/p&gt;
&lt;p&gt;（以下假设DP枚举决策点的复杂度为 $O(n)$，DP状态数为 $O(n^2)$）&lt;/p&gt;
&lt;p&gt;而四边形不等式就是说，如果满足 $f_{i,j-1} \leq f_{i,j} \leq f_{i+1,j}$，那么可以把DP枚举决策点的范围降至 $[f_{i,j-1},f_{i+1,j}]$，然后DP的复杂度就从 $O(n^3)$ 降到了 $O(n^2)$。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;而这个（复杂度）怎么证明呢？我们画一下 $f$ 数组的表：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/10dvj9bx.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;（此处，我们以 $i$ 为行号，以 $j$ 为列号，行、列号都从 $1$ 开始编号）&lt;/p&gt;
&lt;p&gt;然后，画几个标记：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/by8vj7bj.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;这些标记指的是，在转移 $d_{1,2}$ 的时候，转移点枚举的左右端点分别就是红箭头指向的两个数。&lt;/p&gt;
&lt;p&gt;同时，为了方便观察，此处还画了个蓝色的虚线。&lt;/p&gt;
&lt;p&gt;同理，还可以画出 $d_{2,3}$ 对应的标记：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/3kxqh955.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;以此类推：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/71kjzpi4.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以发现，其实这时候所有蓝线的长度（蓝线连接的两个数字的差值定义为这个蓝线的长度）之和，最多只有 $n$。&lt;/p&gt;
&lt;p&gt;而对于 $d_{1,3}$ 一“类”的标记：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/ia0bvgy6.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以发现，其实那些蓝线的长度之和也是最多只有 $n$。&lt;/p&gt;
&lt;p&gt;在画出所有蓝线之后：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/d9jiw70y.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以发现，一共就有 $n$ “类”蓝线，一“类”蓝线的长度之和最多 $n$，至此，可以证明复杂度（所有蓝线的长度之和）为 $O(n^2)$。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;接下来讲几类四边形不等式解决的经典题型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一类：$d_{l,r}=\min { d_{l,k}+d_{k+1,r} &lt;del&gt;|&lt;/del&gt; l \leq k \leq r }+w_{l,r}$，合并石子类。&lt;/li&gt;
&lt;li&gt;第二类：$d_{i,j}=\min { d_{k,j-1}+w_{k+1,i} &lt;del&gt;|&lt;/del&gt; 0 \leq k \leq i }$，区间分割类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（这两类对应的公式里的 $\min$ 也可以替换成 $\max$）&lt;/p&gt;</description>
    </item>
    <item>
      <title>同余最短路</title>
      <link>https://qjwh.github.io/posts/oi/aln/modsp/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/modsp/</guid>
      <description>&lt;text style=&#34;font-family:Lato,楷体&#34;&gt;
&lt;p&gt;同余最短路看名字感觉很难，但其实非常简单，也好理解，先说一道题：&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-题目&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题目&lt;/h2&gt;
&lt;p&gt;原型：&lt;a href=&#34;https://www.luogu.com.cn/problem/P3403&#34;&gt;洛谷P3403 跳楼机&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有一栋 $h$ 层的大楼（层数编号从 $1$ 到 $h$），有 $n+1$ 种移动方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回到 $1$ 层&lt;/li&gt;
&lt;li&gt;向上走 $x_1 \sim x_n$ 层&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;楼层不是循环的，你无论如何都无法到达 $h+1$ 层或以上。&lt;/p&gt;
&lt;p&gt;最初你可以在任意一层（但也无关紧要），问你能到达多少个不同的楼层。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-题解&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题解&lt;/h2&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-分类&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 分类&lt;/h3&gt;
&lt;p&gt;我们按楼层模 $x_1$ 的余数分类，把楼层 $i$ 分到 $i \bmod x_1$ 类。&lt;/p&gt;
&lt;p&gt;这样分类有什么用呢？见下。&lt;/p&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-定义状态&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义状态&lt;/h3&gt;
&lt;p&gt;有了这个分类，我们可以定义状态 $d_i$（$i \in [0,x_1)$）代表不用「向上走 $x_1$ 层」操作能到达的、最小的第 $i$ 类楼层是多少。&lt;/p&gt;
&lt;p&gt;那么，由于有「向上走 $x_1$ 层」操作，所以 $d_i,d_i+x_1,d_i+2x_1,\dots$（比 $d_i$ 大或相等的第 $i$ 类楼层）都是可达的。&lt;/p&gt;
&lt;p&gt;接下来考虑转移这个状态。&lt;/p&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-转移&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 转移&lt;/h3&gt;
&lt;p&gt;其实也很好想，比如用一次「向上走 $x_2$ 层」操作，那么 $d_i$ 可以转移到 $d_{(i+x_2) \bmod x_1}$，转移代价为 $x_2$，所以：&lt;/p&gt;
&lt;p&gt;$d_{(i+x_2) \bmod x_1}=\min(d_{(i+x_2) \bmod x_1},d_i+x_2)$&lt;/p&gt;</description>
    </item>
    <item>
      <title>网络流</title>
      <link>https://qjwh.github.io/posts/oi/aln/flow/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/flow/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-前言&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 前言&lt;/h2&gt;
&lt;p&gt;首先，网络流不是一个算法，而是一个整合包（玩MC玩的），说白了就是网络流是多个算法的统称：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大流
&lt;ul&gt;
&lt;li&gt;EK&lt;/li&gt;
&lt;li&gt;Dinic&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;最小割&lt;/li&gt;
&lt;li&gt;费用流&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而且，有些不常用的，可能就不会提，粘个OI Wiki的链接就不详细写了。&lt;/p&gt;
&lt;p&gt;接下来就按照这个目录挨个讲一下每个算法。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-最大流&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 最大流&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;如果有哪里没有说清楚，可以看&lt;a href=&#34;https://oi-wiki.org/graph/flow/max-flow/&#34;&gt;这里&lt;/a&gt;，里面还有我没有说到的最大流类型。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;看到最大流这个名字很多人都很陌生，这里就先从定义说起。&lt;/p&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-定义&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义&lt;/h3&gt;
&lt;p&gt;还是拆词法，“网络流”就可以大致理解为“网络”上的“流”，接下来就挨个说一下这两个的定义。&lt;/p&gt;
&lt;h4 id=&#34;text-stylecolorrgb0150136-网络&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 网络&lt;/h4&gt;
&lt;p&gt;先说网络的定义。&lt;del&gt;（当然不是Internet）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;我们在理解的时候可以认为是管道，但实际上它是一张特殊的&lt;strong&gt;有向&lt;/strong&gt;图。&lt;/p&gt;
&lt;p&gt;建设管道的必然知道，管道内流过的水，准确来说是单位时间内流过的水，必然是有上限限制的，否则管道就炸了。&lt;/p&gt;
&lt;p&gt;这里也一样，对于每条边 $x \to y$，都有一个函数 $c(x,y)$ 表示这条边的限制，又称&lt;strong&gt;容量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果在图上没有这条边，则统一规定 $c(x,y)=0$。&lt;/p&gt;
&lt;p&gt;最后，还是跟最短路一样，它有一个起点和一个终点，又称&lt;strong&gt;源点&lt;/strong&gt; $S$ 和&lt;strong&gt;汇点&lt;/strong&gt; $T$（$S \not= T$）。&lt;/p&gt;
&lt;h4 id=&#34;text-stylecolorrgb0150136-流函数&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 流函数&lt;/h4&gt;
&lt;p&gt;再说流函数。&lt;/p&gt;
&lt;p&gt;流函数就是说，在真实操作中，一个单位时间内一条边 $x \to y$ 流过的水量 $f(x,y)$。&lt;/p&gt;
&lt;p&gt;这里默认保证每个单位时间内都得流过这么多。&lt;/p&gt;
&lt;p&gt;其实很好理解。&lt;/p&gt;
&lt;h4 id=&#34;text-stylecolorrgb0150136-流函数性质&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 流函数性质&lt;/h4&gt;
&lt;p&gt;顺便说一下流函数要满足的性质。&lt;/p&gt;
&lt;p&gt;首先，源点可以无限输出水，汇点可以无限输入水。&lt;/p&gt;
&lt;p&gt;接下来就是一堆性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于每个 $x,y$，显然 $f(x,y) \leq c(x,y)$（&lt;strong&gt;容量限制&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;对于每个 $x,y$，$f(x,y)=-f(y,x)$（&lt;strong&gt;斜对称&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;对于每个 $x$，满足不是源点也不是汇点，$\sum\limits_{u \to x} f(u,x)=\sum\limits_{x \to v} f(x,v)$（&lt;strong&gt;流量守恒&lt;/strong&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里说一下最后一点性质。&lt;/p&gt;</description>
    </item>
    <item>
      <title>斜率优化</title>
      <link>https://qjwh.github.io/posts/oi/aln/slopeopm/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/slopeopm/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;
&lt;p&gt;&lt;del&gt;（说是斜率优化，其实和斜率几乎没有关系）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;（e&amp;hellip;更新后确实有关系）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;其实斜率优化和决策二分栈（队列）很像，下面分几种类型来讲。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-一维斜率优化&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 一维斜率优化&lt;/h2&gt;
&lt;p&gt;针对形如 $d_i=\min\limits_{j=0}^{i-1} \big( d_j+w(j+1,i) \big)$ 的方程，而且需要满足决策单调性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此处重新说一下，如果我们发现一个转移点 $x$ 在 $d_i$ 的时候已经比另外一个转移点 $y$ 要更优了（$x&amp;gt;y$），那么转移点 $y$ 在后面（$d_{i+1}$ 及以后）就不可能比转移点 $x$ 要更优了，那么这个DP一定满足决策单调性，而且反过来也一样（见&amp;quot;决策单调性.md&amp;quot;）。&lt;/p&gt;
&lt;p&gt;其实证明是否满足单调性只用看：如果一个决策点 $x$ 如果在 $d_i$ 的转移中已经比决策点 $y$ 要优了，那么 $d_{i+1}$ 中是否仍然满足这个条件。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;证明了满足决策单调性后，就可以开始斜率优化了。&lt;/p&gt;
&lt;p&gt;我们首先要考虑推斜率式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;其实斜率式就是把式子 $d_x+w(x+1,i)&amp;lt;d_y+w(y+1,i)$（$x&amp;gt;y$）不断移项、变化，直到式子左边只和 $x$、$y$ 有关，右边只和 $i$ 有关为止。&lt;/p&gt;
&lt;p&gt;此时的斜率式一般左边是个分数，而且这个分数还需要把分子和分母的下标对应：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果斜率式最后是像这样的：&lt;/p&gt;
&lt;p&gt;$\dfrac{d_x-d_y}{v_y-v_x}&amp;gt;-a_i$&lt;/p&gt;
&lt;p&gt;那么就不是个合法的斜率式，需要变成：&lt;/p&gt;
&lt;p&gt;$\dfrac{d_x-d_y}{v_x-v_y}&amp;lt;a_i$&lt;/p&gt;
&lt;p&gt;才是合法的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，这里说的是“合法的”，而不是“正确的”，其实最上方的斜率式也可以使用，就是不能叫“斜率式”了（斜率的公式是 $\dfrac{y_2-y_1}{x_2-x_1}$）。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;
&lt;p&gt;设此时的斜率式就是上面说的：&lt;/p&gt;
&lt;p&gt;$\dfrac{d_x-d_y}{v_x-v_y}&amp;lt;a_i$&lt;/p&gt;
&lt;p&gt;那么，我们就定义 $\text{slope}(y,x)=\dfrac{d_x-d_y}{v_x-v_y}$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有了上面函数，显然如果存在两个转移点 $x$ 和 $y$（$x&amp;gt;y$）在转移到 $d_i$ 的时候满足 $\text{slope}(x,y)&amp;lt;a_i$，那么就说明转移点 $x$ 比转移点 $y$ 更优，转移点 $y$ 在后面就不需要了。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;下面默认推出来的斜率式就是上式，并默认 $a$ 数组单调不降。&lt;/p&gt;</description>
    </item>
    <item>
      <title>行列式</title>
      <link>https://qjwh.github.io/posts/oi/aln/hanglieshi/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/hanglieshi/</guid>
      <description>&lt;p&gt;要说行列式，就得先说一下矩阵（其实是方阵）的秩的定义。&lt;/p&gt;
&lt;p&gt;对于一个方阵，其秩的定义就是矩阵里线性无关的极大值。&lt;/p&gt;
&lt;p&gt;听这个定义有点难懂，这里解释一下。&lt;/p&gt;
&lt;p&gt;其实一个方阵就可以被当做是一个没有右项的方程集。&lt;/p&gt;
&lt;p&gt;而一个方阵的秩就可以当做是，这个没有右项的方程集在经过高斯消元后，非 $0$ 行的数量。&lt;/p&gt;
&lt;p&gt;有了这个定义，矩阵的秩还可以被当做是，这个没有右项的方程集中，不会被其他方程替代掉的方程数量：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解释一下，如果方程长这样：&lt;/p&gt;
&lt;p&gt;$
\begin{cases}
-x_1+2x_2+5x_3=11 \
2x_1=8 \
x_1+2x_2+5x_3=19
\end{cases}
$&lt;/p&gt;
&lt;p&gt;那么，其实第三个方程式可以通过前两个方程式推出来，也就称作第三个方程式可以被前两个方程式替代掉。&lt;/p&gt;
&lt;p&gt;知道了“替代”的定义后，就知道了一件事，就是上面说的“会被其他方程替代掉的方程”，这些方程可以直接从方程组里去掉，而不影响最终的解。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;所以，我们就可以对奥数里的一个点做一个更简洁的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在奥数里，讲了解 $n$ 元一次方程（组）的方法。&lt;/p&gt;
&lt;p&gt;同时还说了，在这个 $n$ 元一次方程组内，如果“有用”的方程数量，刚好等于未知数的数量，或者大于未知数的数量，那么这个方程组就有唯一解。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;这一点可以被更简洁地解释为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个 $n$ 元一次方程组，转化为“高斯矩阵”，并删除最后一列后（变成 $n \times n$ 的方阵），如果这个方阵的秩刚好为 $n$，那么这个方程组就有唯一解。&lt;/p&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;然后，我们回归正题，说行列式。&lt;/p&gt;
&lt;p&gt;行列式是对于一个方阵来讲的，一个方阵有行列式有且仅当这个方程的秩刚好等于方阵的大小（行或者列）。&lt;/p&gt;
&lt;p&gt;行列式的定义此处不讲，因为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;太复杂了&lt;/li&gt;
&lt;li&gt;（几乎）没有用处&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;行列式的计算方法是用的高斯消元。&lt;/p&gt;
&lt;p&gt;在高斯消元的思路里，提到了三种“基本行变换”：（以下全部以高斯矩阵的角度去说）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将一行全部乘上一个非 $0$ 实数 $x$，解不变。&lt;/li&gt;
&lt;li&gt;将一行内的所有元素对应地加上/减去另一行对应的元素乘上一个非 $0$ 实数 $x$，解不变。&lt;/li&gt;
&lt;li&gt;交换两行，解不变。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这三种基本行变换在执行前后，行列式并不是都不变的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将一行全部乘上一个非 $0$ 实数 $x$，行列式也会乘上 $x$。&lt;/li&gt;
&lt;li&gt;将一行内的所有元素对应地加上/减去另一行对应的元素乘上一个非 $0$ 实数 $x$，行列式不变。&lt;/li&gt;
&lt;li&gt;交换两行，行列式变号（负数变成正数，反之亦然）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以我们只用写一下高斯消元，然后处理一下对行列式的值的变化即可。&lt;/p&gt;
&lt;p&gt;但这儿还有一点问题，就是行列式怎么求。&lt;/p&gt;
&lt;p&gt;求法很好记，如果说当前方阵是个上三角矩阵（设方阵叫 $a$，那么 $a$ 是个上三角矩阵有且仅当对于所有的 $(i,j)$，如果满足 $i&amp;gt;j$，那么 $a_{i,j}$ 一定要等于 $0$，当然其他方格不做要求），那么这个方阵的行列式就是这个方阵中正对角线上的元素的乘积。&lt;/p&gt;</description>
    </item>
    <item>
      <title>一个非常重要的语法点</title>
      <link>https://qjwh.github.io/posts/oi/aln/animportantgrammer/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/animportantgrammer/</guid>
      <description>&lt;p&gt;说一个非常重要的语法错误。&lt;/p&gt;
&lt;p&gt;如果你写这样一句话：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newnode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;v&lt;/code&gt;为一个&lt;code&gt;vector&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt;为不越界的非负整数，且不会变化。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newnode()&lt;/code&gt;函数内会向&lt;code&gt;vector&lt;/code&gt;内&lt;code&gt;push_back&lt;/code&gt;一个新元素，并返回加入元素（即最后一个元素）的下标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么，你会发现，&lt;code&gt;v[x]&lt;/code&gt;的值并不是这样变化的：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1,2,3,4,5,6,7,...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而是类似于这样的：（非真实输出结果，仅供参考）&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1,1,2,2,3,4,4,5,6,7,8,8,9,10,11,12,13,14,15,16,16,17,18,19,20,...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你会发现部分情况下，&lt;code&gt;v[x]&lt;/code&gt;没有变化！&lt;/p&gt;
&lt;p&gt;这实际上是因为&lt;code&gt;vector&lt;/code&gt;的内部机制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;会有一个&lt;code&gt;capacity&lt;/code&gt;，就是提供的内存大小。&lt;/p&gt;
&lt;p&gt;每次&lt;code&gt;push_back&lt;/code&gt;的时候，如果说加入后，不超过当前的&lt;code&gt;capacity&lt;/code&gt;，就会直接加入。&lt;/p&gt;
&lt;p&gt;否则，&lt;code&gt;vector&lt;/code&gt;会新开辟一块等于当前&lt;code&gt;capacity&lt;/code&gt;的两倍（这个在不同编辑器上是不一样的，有些可能是每次新增 $5$ 个）的新空间，并把原本的数据拷进这块新空间内。&lt;/p&gt;
&lt;p&gt;比如说现在的&lt;code&gt;vector&lt;/code&gt;是：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;内存354~357位置：3 1 2 4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;且&lt;code&gt;capacity&lt;/code&gt;是 $4$，那么我们如果尝试&lt;code&gt;push_back&lt;/code&gt;一个 $5$，则&lt;code&gt;vector&lt;/code&gt;就会发现大于了&lt;code&gt;capacity&lt;/code&gt;，便会新开一块等于当前&lt;code&gt;capacity&lt;/code&gt;的两倍的空间：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;内存354~357位置：3 1 2 4
内存382~389位置：
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并把当前数据拷进去：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;内存354~357位置：3 1 2 4
内存382~389位置：3 1 2 4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在新空间内加入 $5$：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;内存354~357位置：3 1 2 4
内存382~389位置：3 1 2 4 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并把所有&lt;code&gt;v[x]&lt;/code&gt;指向的内存都改成&lt;code&gt;382~389&lt;/code&gt;这块新内存内对应的地方。&lt;/p&gt;
&lt;p&gt;不过由于C++的赋值机制，系统会先找到要赋值给的变量的指针，然后求出要赋的值，赋给以前找到的指针。&lt;em&gt;（这一步是推测，可能不准确）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;所以就会导致把&lt;code&gt;newnode()&lt;/code&gt;的值赋给了原本的&lt;code&gt;v[x]&lt;/code&gt;，导致输出的时候访问的新&lt;code&gt;v[x]&lt;/code&gt;值出错。&lt;/p&gt;
&lt;p&gt;解决方法也很简单，把&lt;code&gt;newnode()&lt;/code&gt;用个临时变量&lt;code&gt;t&lt;/code&gt;存储，并将&lt;code&gt;v[x]&lt;/code&gt;赋值为&lt;code&gt;t&lt;/code&gt;即可。&lt;/p&gt;</description>
    </item>
    <item>
      <title>一元二次方程解法（未完工）</title>
      <link>https://qjwh.github.io/posts/oi/aln/quadraticequation/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/quadraticequation/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;
&lt;p&gt;在数学、编程界里，可能会经常遇到方程，而且有时候还会遇到一种特殊方程——一元二次方程。&lt;/p&gt;
&lt;p&gt;除此之外，还有含参一元二次方程，这里也会一起讲。&lt;em&gt;（待补充）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其实还有如二元一次方程、一元三次方程等的特殊方程，但在这里不讲。&lt;/p&gt;
&lt;h1 id=&#34;text-stylecolorrgb0150136-一元二次方程&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 一元二次方程&lt;/h1&gt;
&lt;p&gt;有人看到“一元二次方程”就不知道是啥意思，这里先说一下定义&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-定义&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 定义&lt;/h2&gt;
&lt;p&gt;首先，方程相信大家都见过，所以这里不写对方程的定义解释。（废话&lt;/p&gt;
&lt;p&gt;而 $x$ 元 $y$ 次方程就是这么定义的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个方程&lt;strong&gt;经过化简&lt;/strong&gt;后，共有 $x$ 个未知数，且&lt;strong&gt;未知数上&lt;/strong&gt;的最大指数为 $y$ 的方程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$3(x+1)=6x$：一元一次方程，也是最常见的方程。&lt;/li&gt;
&lt;li&gt;$3(x+1)^2=2(x+1)$：一元一次方程，因为两边可以同时除以 $x+1$ 以让指数减少 $1$。&lt;/li&gt;
&lt;li&gt;$x^2-4x+1=0$：一元二次方程，也是下面要讲的方程类型。&lt;/li&gt;
&lt;li&gt;$x^3+2x^2-1=16x$：一元三次方程，也是一种不常见的方程类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;讲完定义，接下来说怎么解&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-解法&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解法&lt;/h2&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-推导&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 推导&lt;/h3&gt;
&lt;p&gt;我们&lt;strong&gt;把方程一般化&lt;/strong&gt;，变成：&lt;/p&gt;
&lt;p&gt;$ax^2+bx+c=0$&lt;/p&gt;
&lt;p&gt;其中 $a$、$b$、$c$ 均为常量。&lt;/p&gt;
&lt;p&gt;然后，我们不断对方程做一些推导。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;移项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$ax^2+bx=-c$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同时除以 $a$ 常量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$x^2+\dfrac{b}{a}x=-\dfrac{c}{a}$&lt;/p&gt;
&lt;p&gt;这个式子很多人看了就不知道怎么继续推导了。&lt;/p&gt;
&lt;p&gt;但还是可以继续转化的。&lt;/p&gt;
&lt;p&gt;我们考虑&lt;strong&gt;配方&lt;/strong&gt;，即把式子的左/右项同时加/减/乘/除一个相同的数，然后让这个等式的左/右项变成一个数的平方的形式。&lt;/p&gt;
&lt;p&gt;这一步比较考验数感，一个结论就是，我们&lt;strong&gt;同时加上 $\left( \dfrac{b}{2a} \right)^2$ 常量&lt;/strong&gt; 即可。&lt;/p&gt;
&lt;p&gt;$x^2+\dfrac{b}{a}x+\left( \dfrac{b}{2a} \right)^2=-\dfrac{c}{a}+\left( \dfrac{b}{2a} \right)^2$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;化简&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$\left( x+\dfrac{b}{2a} \right)^2=\dfrac{-c}{a}+\dfrac{b^2}{4a^2}$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二次化简&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$\left( x+\dfrac{b}{2a} \right)^2=\dfrac{b^2-4ac}{4a^2}$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同时开根号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$x+\dfrac{b}{2a}=\sqrt{\dfrac{b^2-4ac}{4a^2}}$&lt;/p&gt;</description>
    </item>
    <item>
      <title>整除分块</title>
      <link>https://qjwh.github.io/posts/oi/aln/divisionblock/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/divisionblock/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;
&lt;p&gt;感谢&lt;a href=&#34;https://blog.csdn.net/qq_58207591/article/details/123883428&#34;&gt;这篇文章&lt;/a&gt;的作者&lt;/p&gt;
&lt;p&gt;整除分块主要解决求解 $\sum\limits_{i=1}^n \lfloor \frac{n}{i} \rfloor$ 的值。&lt;/p&gt;
&lt;p&gt;一看这个公式，可能毫无头绪，但画张图你就有点思路了：（$n=11$）&lt;/p&gt;
&lt;img src=&#34;https://cdn.luogu.com.cn/upload/image_hosting/5by1ehmz.png&#34; width=&#34;65%&#34;&gt;
&lt;p&gt;（灰色线：$y=\frac{11}{x}$，绿色点：$y=\lfloor \frac{11}{x} \rfloor$，橙色线：仅为辅助）&lt;/p&gt;
&lt;p&gt;这张图其实就是在提示我们：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\lfloor \frac{n}{i} \rfloor$ 的值随着 $i$ 的增长而非单调递减&lt;/li&gt;
&lt;li&gt;$\lfloor \frac{n}{i} \rfloor$ 的值往往会在一段区间内相等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，我们就有一个思路了，就是求出所有值（下面的“值”都代指的是 $\lfloor \frac{n}{i} \rfloor$）相等的极大区间集，然后就可以快速统计了。&lt;/p&gt;
&lt;p&gt;有人问，这不就是个常数级别的优化吗，怎么能叫“快速”呢？其实区间个数总是 $O(\sqrt{n})$ 级别，最多约 $2 \times \sqrt{n}$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：&lt;/p&gt;
&lt;p&gt;我们把 $i$ 分成两部分去考虑，一部分是 $i \leq \sqrt{n}$，另一部分是 $i&amp;gt;\sqrt{n}$。&lt;/p&gt;
&lt;p&gt;在第一部分内，$i$ 也就只有 $\sqrt{n}$ 种取值，$\lfloor \frac{n}{i} \rfloor$ 最多只有约 $\sqrt{n}$ 种取值。&lt;/p&gt;
&lt;p&gt;在第二部分内，$\lfloor \frac{n}{i} \rfloor$ 在 $i$ 最小时（$i=\sqrt{n}+1$）会达到最大值，约 $\sqrt{n}$；而上面说“$\lfloor \frac{n}{i} \rfloor$ 的值随着 $i$ 的增长而非单调递减”，所以易得 $\lfloor \frac{n}{i} \rfloor$ 最多也只有约 $\sqrt{n}$ 种取值。&lt;/p&gt;
&lt;p&gt;$\lfloor \frac{n}{i} \rfloor$ 的总取值种数最多只有第一、二部分的取值个数和，即 $2 \times \sqrt{n}$，证毕。&lt;/p&gt;</description>
    </item>
    <item>
      <title>整体二分</title>
      <link>https://qjwh.github.io/posts/oi/aln/exbinarysearch/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/exbinarysearch/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;
&lt;p&gt;整体二分类似于线段树上二分，在讲这个算法前，先引入几个问题。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-解决题型&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解决题型&lt;/h2&gt;
&lt;p&gt;整体二分一般解决的是如下的问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个【集合/序列/矩阵/树】，要求【静态/动态】维护所有【元素/区间/子矩阵/链/子树】中的第 $k$【可能每次给定】大元素，【可能强制在线】。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;下面是一堆例题。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-例题1-动态查询集合第k大可离线&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 例题1 动态查询集合第k大（可离线）&lt;/h2&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-题意&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题意&lt;/h3&gt;
&lt;p&gt;让你维护一个初始为空的多重集合 $s$，并支持 $q$ 次操作，操作都是下面三种之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加一个数 $x$ 到集合 $s$ 中。&lt;/li&gt;
&lt;li&gt;在集合 $s$ 中删除一个数 $x$（保证元素存在）。&lt;/li&gt;
&lt;li&gt;查询集合第 $k$ 大（保证第 $k$ 大存在）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-数据范围&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 数据范围&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;$1 \leq q \leq 2 \times 10^5$&lt;/li&gt;
&lt;li&gt;$0 \leq x \leq 10^9$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-题解&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 题解&lt;/h3&gt;
&lt;p&gt;维护一个权值线段树（权值线段树其实就是一个维护值域的线段树），维护一段值域里有多少个数，每次询问在线段树上二分即可。&lt;/p&gt;
&lt;p&gt;具体地，对于线段树上某个节点对应的区间 $[l,r]$，这个节点上的值为集合中，值在 $[l,r]$ 的数的个数有多少。&lt;/p&gt;
&lt;p&gt;在询问时，我们要记录当前节点编号 $x$，$x$ 维护区间 $[l,r]$，以及要查询值在 $[l,r]$ 内的所有数的第 $k$ 大。&lt;/p&gt;
&lt;p&gt;当递归到某个状态后，我们看这个节点的左子树 $\text{lc}$ 内有多少个值，如果大于等于 $k$，则递归到左子树；否则递归到右子树，且 $k$ 减去(左子树内数的个数)。&lt;/p&gt;
&lt;p&gt;由于值域较大，权值线段树可能会爆，所以要先把所有询问离线下来，做个离散化，然后就可以把 $x$ 控制到 $q$ 级别，就不会爆了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>中国剩余定理</title>
      <link>https://qjwh.github.io/posts/oi/aln/crt/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/crt/</guid>
      <description>&lt;p&gt;中国剩余定理，Chinese Remainder Theorem，又称CRT，我们接下来就讲一下这个算法的原理。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;要说原理，就得从古代说起。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;（你到底是在讲编程课还是在讲历史课）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;（真的是在将编程课）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;在古代，有一个问题，叫做“物不知数问题”，原文是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有物不知其数&lt;/li&gt;
&lt;li&gt;三三数之剩二&lt;/li&gt;
&lt;li&gt;五五数之剩三&lt;/li&gt;
&lt;li&gt;七七数之剩二&lt;/li&gt;
&lt;li&gt;问物几何？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个问题翻译过来就是问以下方程的所有正整数解：&lt;/p&gt;
&lt;p&gt;$
\begin{cases}
x \equiv 2 \pmod{3} \
x \equiv 3 \pmod{5} \
x \equiv 2 \pmod{7}
\end{cases}
$&lt;/p&gt;
&lt;p&gt;这个问题在后来有一个解了，解出来这个问题的人，编了一首诗，叫做“孙子歌诀”，原文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三人同行七十稀&lt;/li&gt;
&lt;li&gt;五树梅花廿一支&lt;/li&gt;
&lt;li&gt;七子团圆正半月&lt;/li&gt;
&lt;li&gt;除百零五便得知&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个解翻译过来就是说，若设 $r_3$ 为方程中 $x$ 模 $3$ 的余数，$r_5$、$r_7$ 同理，那么所有解 $x$ 一定满足：&lt;/p&gt;
&lt;p&gt;$x \equiv r_3 \times 70+r_5 \times 21+r_7 \times 15 \pmod{105}$&lt;/p&gt;
&lt;p&gt;其中 $105$ 的实际来源是上面三个方程的模数的 $\text{lcm}$，即 $\text{lcm}(3,5,7)=3 \times 5 \times 7=105$。&lt;/p&gt;
&lt;p&gt;关于 $70$、$21$、$15$ 的来源下面再说，我们先证明一下这个解是正确的。&lt;/p&gt;
&lt;p&gt;由于 $105$ 是三个模数的 $\text{lcm}$，所以说如果 $x$ 是满足条件的，$x-105$、$x+105$ 都是满足条件的（此处暂时忽略“正整数解”的限制），显然。&lt;/p&gt;</description>
    </item>
    <item>
      <title>组合数学（待补充）</title>
      <link>https://qjwh.github.io/posts/oi/aln/c/</link>
      <pubDate>Sun, 09 Feb 2025 15:28:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/c/</guid>
      <description>&lt;text style=&#34;font-family:Lato,楷体&#34;&gt;
&lt;p&gt;有人问，组合数学不是就一些简单的公式吗？不是的，其实组合数学是数学中的一个非常庞大的分支，接下来就举&lt;strong&gt;一些&lt;/strong&gt;例子。&lt;em&gt;（更新中）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本文主要讲各种数据范围下，求组合数的方式；以及球盒模型各种情况下的公式；最后是一些球盒模型的扩展情况。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://qjwh.github.io/posts/oi/aln/c/#%e7%90%83%e7%9b%92%e6%a8%a1%e5%9e%8b%e4%b8%bb%e8%a6%81%e6%83%85%e5%86%b5%e6%80%bb%e7%bb%93&#34;&gt;转到：球盒模型公式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://qjwh.github.io/posts/oi/aln/c/#%e7%90%83%e7%9b%92%e6%a8%a1%e5%9e%8b%e6%89%a9%e5%b1%95%e4%b8%bb%e8%a6%81%e6%83%85%e5%86%b5%e6%80%bb%e7%bb%93&#34;&gt;转到：球盒模型扩展公式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（下面部分标题里的LaTeX公式更新后炸了，就凑合着看吧）&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-求组合数&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 求组合数&lt;/h2&gt;
&lt;p&gt;以下所有范围都可以当成是以下题目的某个Subtask：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给你 $p$，代表模数。&lt;/p&gt;
&lt;p&gt;之后会给你一个 $q$，代表询问次数。&lt;/p&gt;
&lt;p&gt;每次询问给定 $n$ 和 $m$，问 $C_n^m \bmod p$ 的值。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;下面不给定 $q$ 的范围，因为不重要。&lt;/p&gt;
&lt;p&gt;以下全部默认 $n \geq m$。&lt;/p&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-范围1nm-leq-2000p-leq-1097&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 范围1：$n,m \leq 2000,p \leq 10^9+7$&lt;/h3&gt;
&lt;p&gt;先递推预处理，然后直接回答询问即可。&lt;/p&gt;
&lt;p&gt;递推式：$C_n^m=C_{n-1}^m+C_{n-1}^{m-1}$。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预处理复杂度：$O(n^2)$&lt;/li&gt;
&lt;li&gt;查询复杂度：$O(1)$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-范围2nm-leq-106p-leq-1097ptext-is-prime&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 范围2：$n,m \leq 10^6,p \leq 10^9+7,p\text{ is prime}$&lt;/h3&gt;
&lt;h4 id=&#34;text-stylecolorrgb0150136-1&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 1&lt;/h4&gt;
&lt;p&gt;先预处理阶乘，然后直接回答询问即可。&lt;/p&gt;
&lt;p&gt;回答询问式：$C_n^m=\dfrac{n!}{m!(n-m)!}$。&lt;/p&gt;
&lt;p&gt;为了节省时间复杂度，此处还可以预处理一下阶乘的逆元。&lt;/p&gt;
&lt;h4 id=&#34;text-stylecolorrgb0150136-2&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 2&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;预处理复杂度：$O(n)$&lt;/li&gt;
&lt;li&gt;查询复杂度：$O(1)$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-范围3nm-leq-106p-leq-1097&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 范围3：$n,m \leq 10^6,p \leq 10^9+7$&lt;/h3&gt;
&lt;h4 id=&#34;text-stylecolorrgb0150136-1-1&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 1&lt;/h4&gt;
&lt;p&gt;可以发现，范围2与范围3唯一的不同就是，范围3把质数的条件去掉了。&lt;/p&gt;
&lt;p&gt;而把质数的条件后，就没法求逆元了，因为逆元可能不存在。&lt;/p&gt;
&lt;p&gt;所以我们考虑换做法。&lt;/p&gt;
&lt;h4 id=&#34;text-stylecolorrgb0150136-2-1&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 2&lt;/h4&gt;
&lt;p&gt;我们考虑把模数做个质因数分解，变成 ${p_1}^{a_1} \times {p_2}^{a_2} \times {p_3}^{a_3} \times \dots \times {p_k}^{a_k}$。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Hello, world!</title>
      <link>https://qjwh.github.io/posts/test/</link>
      <pubDate>Sat, 08 Feb 2025 11:00:00 +0800</pubDate>
      <guid>https://qjwh.github.io/posts/test/</guid>
      <description>A blog post</description>
    </item>
    <item>
      <title></title>
      <link>https://qjwh.github.io/posts/oi/aln/modui/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://qjwh.github.io/posts/oi/aln/modui/</guid>
      <description>&lt;text style=&#34;font-family:Noto Sans SC&#34;&gt;
&lt;h1 id=&#34;text-stylecolorrgb0150136-普通莫队算法&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 普通莫队算法&lt;/h1&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-概览&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 概览&lt;/h2&gt;
&lt;p&gt;莫队其实是分块的变化版，没有完全分块。&lt;/p&gt;
&lt;p&gt;但莫队的题目一般比分块的题目比较好看一些，其中的“好看”指的是很好看出这是个莫队/分块的题。&lt;/p&gt;
&lt;p&gt;接下来说一下莫队能解决的题型。&lt;/p&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-解决题型&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解决题型&lt;/h2&gt;
&lt;p&gt;莫队一般解决以下问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一些信息，和 $q$ 次询问，每次询问可以抽象为一个区间。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;而且这个问题还要满足一些条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以离线&lt;/li&gt;
&lt;li&gt;不能有修改（当然带修莫队支持修改，不过普通莫队就不行了）&lt;/li&gt;
&lt;li&gt;从 $[l,r]$ 的答案可以很快转移到 $[l-1,r]$、$[l+1,r]$、$[l,r-1]$、$[l,r+1]$ 的答案&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;text-stylecolorrgb0150136-解决方法&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 解决方法&lt;/h2&gt;
&lt;p&gt;这种题型有个解决方法。&lt;/p&gt;
&lt;p&gt;还是先从暴力说起。&lt;/p&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-暴力做法&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 暴力做法&lt;/h3&gt;
&lt;p&gt;看见这个问题的最后一个条件没？这个条件就启发我们从第一个问题的答案，暴力调整左、右端点，去得到第二个问题的答案，以此类推。&lt;/p&gt;
&lt;p&gt;这种暴力做法的复杂度一般为 $O($ 任意相邻两个问题的左、右端点差之和 $)$。&lt;/p&gt;
&lt;p&gt;而这个算法可以用一种数据卡掉：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左、右端点的值的最大值 $n$ 调到最大，把询问次数 $q$ 也调到最大。&lt;/li&gt;
&lt;li&gt;然后的 $q$ 次询问里，交替询问 $1 \sim n$ 和 $n \sim n$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;于是，复杂度被卡到 $O(qn)$。&lt;/p&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-一次优化&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 一次优化&lt;/h3&gt;
&lt;p&gt;这个做法的复杂度是无法接受的，所以我们考虑优化。&lt;/p&gt;
&lt;p&gt;我们不如把所有询问离线，然后考虑交换询问处理的顺序以减少复杂度。&lt;/p&gt;
&lt;p&gt;一种方式就是把左、右端点分别作为第一、二关键字，然后做排序。&lt;/p&gt;
&lt;p&gt;但这样就会被排序后所有询问的右端点一大一小的数据卡到 $O(qn)$ 的复杂度。&lt;/p&gt;
&lt;h3 id=&#34;text-stylecolorrgb0150136-二次优化&#34;&gt;&lt;text style=&#34;color:rgb(0,150,136)&#34;&gt; 二次优化&lt;/h3&gt;
&lt;p&gt;这样排序还是不好，还是会被卡掉，于是我们考虑变换比较函数。&lt;/p&gt;
&lt;p&gt;直接双关键字比较不好，那我们就分块后进行双关键字比较。&lt;/p&gt;
&lt;p&gt;具体地，遇到两个询问，先按左端点所属块编号从小到大排序，如果相同，则按右端点（不是所属块编号，是原本的下标）从小到大排序。&lt;/p&gt;
&lt;p&gt;这样的话，复杂度就是 $O(n \sqrt n+q \sqrt n)$ 的复杂度了。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
