<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>生成随机数（未完工） | CXBlog</title>
<meta name="keywords" content="信息学竞赛, 算法学习笔记">
<meta name="description" content="参考

引用头文件（常用）

#include &lt;stdlib.h&gt;  //生成随机数、设定随机数种子
#include &lt;ctime&gt;  //生成随机数种子（1）
#include &lt;time.h&gt;  //生成随机数种子（2）
#include &lt;unistd.h&gt;  //等待（sleep(...)或usleep(...)），该头文件现在不常用

随机种子

srand(time(0) ^ clock());

注：随机种子为time(0) ^ clock()，这个随机种子可以再毫秒级别内生成（大概率）不同的随机种子。

取 $[l,r]$ 内的随机数

#define random(l, r) (rand() % ((LL)(r) - (LL)(l) &#43; 1) &#43; (LL)(l))

注：rand函数只能生成 $[1,32767]$ 内的随机数（见宏RAND_MAX），大概只能生成位数 $\leq 5$ 的随机数；测试程序：
LL ma = 0;
for(LL i = 1;i &lt;= 200;i&#43;&#43;){
    srand(time(0) ^ clock());
    LL t = rand();
    cout &lt;&lt; t &lt;&lt;endl;
    ma = max(ma, t);
    usleep(10000);
}
cout &lt;&lt; ma &lt;&lt;endl;
所以此处引用一个新方法：mt19937（2022/12/24：现在开始使用mt19937_64了，它可以生成 $[1,2^{64})$ 内的随机数，大一倍）。
其实它的语法和rand的语法差不多 （才怪），是这样的：


引用头文件（常用）

#include &lt;random&gt;  //生成随机数、设定随机数种子
#include &lt;ctime&gt;  //生成随机数种子（1）
#include &lt;time.h&gt;  //生成随机数种子（2）
#include &lt;unistd.h&gt;  //等待（sleep(...)或usleep(...)），该头文件现在不常用

随机种子

mt19937 _rand(time(0) ^ clock());
注：这个随机种子也可以再毫秒级别内生成（大概率）不同的随机种子

取 $[l,r]$ 内的随机数 （就差一个字符_而已）

#define random(l, r) (_rand() % ((LL)(r) - (LL)(l) &#43; 1) &#43; (LL)(l))
据测试，这个函数可以生成在unsigned int范围内的随机数（即可以生成 $[1,2^{32})$ 内的随机数），测试程序：">
<meta name="author" content="">
<link rel="canonical" href="https://qjwh.github.io/posts/oi/aln/genrandomnumber/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3b2e5c86d6776f1230a6cc3dbc6bde31467e6a5f6513337e196964b4e3693a57.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://qjwh.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://qjwh.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://qjwh.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://qjwh.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://qjwh.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://qjwh.github.io/posts/oi/aln/genrandomnumber/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script src="https://unpkg.com/feather-icons"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      
      
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false},
      ],
      
      throwOnError : false
    });
  });
</script>

<style>
    @font-face { 
        font-family: 'Ubuntu';
        src: url('/UbuntuB.ttf');
    }
    body {
        
        font-family: 'Ubuntu';
    }
</style><meta property="og:url" content="https://qjwh.github.io/posts/oi/aln/genrandomnumber/">
  <meta property="og:site_name" content="CXBlog">
  <meta property="og:title" content="生成随机数（未完工）">
  <meta property="og:description" content="参考
引用头文件（常用） #include &lt;stdlib.h&gt; //生成随机数、设定随机数种子 #include &lt;ctime&gt; //生成随机数种子（1） #include &lt;time.h&gt; //生成随机数种子（2） #include &lt;unistd.h&gt; //等待（sleep(...)或usleep(...)），该头文件现在不常用 随机种子 srand(time(0) ^ clock()); 注：随机种子为time(0) ^ clock()，这个随机种子可以再毫秒级别内生成（大概率）不同的随机种子。
取 $[l,r]$ 内的随机数 #define random(l, r) (rand() % ((LL)(r) - (LL)(l) &#43; 1) &#43; (LL)(l)) 注：rand函数只能生成 $[1,32767]$ 内的随机数（见宏RAND_MAX），大概只能生成位数 $\leq 5$ 的随机数；测试程序：
LL ma = 0; for(LL i = 1;i &lt;= 200;i&#43;&#43;){ srand(time(0) ^ clock()); LL t = rand(); cout &lt;&lt; t &lt;&lt;endl; ma = max(ma, t); usleep(10000); } cout &lt;&lt; ma &lt;&lt;endl; 所以此处引用一个新方法：mt19937（2022/12/24：现在开始使用mt19937_64了，它可以生成 $[1,2^{64})$ 内的随机数，大一倍）。
其实它的语法和rand的语法差不多 （才怪），是这样的：
引用头文件（常用） #include &lt;random&gt; //生成随机数、设定随机数种子 #include &lt;ctime&gt; //生成随机数种子（1） #include &lt;time.h&gt; //生成随机数种子（2） #include &lt;unistd.h&gt; //等待（sleep(...)或usleep(...)），该头文件现在不常用 随机种子 mt19937 _rand(time(0) ^ clock()); 注：这个随机种子也可以再毫秒级别内生成（大概率）不同的随机种子
取 $[l,r]$ 内的随机数 （就差一个字符_而已） #define random(l, r) (_rand() % ((LL)(r) - (LL)(l) &#43; 1) &#43; (LL)(l)) 据测试，这个函数可以生成在unsigned int范围内的随机数（即可以生成 $[1,2^{32})$ 内的随机数），测试程序：">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-02-09T15:28:00+08:00">
    <meta property="article:modified_time" content="2025-02-09T15:28:00+08:00">
    <meta property="article:tag" content="信息学竞赛">
    <meta property="article:tag" content="算法学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="生成随机数（未完工）">
<meta name="twitter:description" content="参考

引用头文件（常用）

#include &lt;stdlib.h&gt;  //生成随机数、设定随机数种子
#include &lt;ctime&gt;  //生成随机数种子（1）
#include &lt;time.h&gt;  //生成随机数种子（2）
#include &lt;unistd.h&gt;  //等待（sleep(...)或usleep(...)），该头文件现在不常用

随机种子

srand(time(0) ^ clock());

注：随机种子为time(0) ^ clock()，这个随机种子可以再毫秒级别内生成（大概率）不同的随机种子。

取 $[l,r]$ 内的随机数

#define random(l, r) (rand() % ((LL)(r) - (LL)(l) &#43; 1) &#43; (LL)(l))

注：rand函数只能生成 $[1,32767]$ 内的随机数（见宏RAND_MAX），大概只能生成位数 $\leq 5$ 的随机数；测试程序：
LL ma = 0;
for(LL i = 1;i &lt;= 200;i&#43;&#43;){
    srand(time(0) ^ clock());
    LL t = rand();
    cout &lt;&lt; t &lt;&lt;endl;
    ma = max(ma, t);
    usleep(10000);
}
cout &lt;&lt; ma &lt;&lt;endl;
所以此处引用一个新方法：mt19937（2022/12/24：现在开始使用mt19937_64了，它可以生成 $[1,2^{64})$ 内的随机数，大一倍）。
其实它的语法和rand的语法差不多 （才怪），是这样的：


引用头文件（常用）

#include &lt;random&gt;  //生成随机数、设定随机数种子
#include &lt;ctime&gt;  //生成随机数种子（1）
#include &lt;time.h&gt;  //生成随机数种子（2）
#include &lt;unistd.h&gt;  //等待（sleep(...)或usleep(...)），该头文件现在不常用

随机种子

mt19937 _rand(time(0) ^ clock());
注：这个随机种子也可以再毫秒级别内生成（大概率）不同的随机种子

取 $[l,r]$ 内的随机数 （就差一个字符_而已）

#define random(l, r) (_rand() % ((LL)(r) - (LL)(l) &#43; 1) &#43; (LL)(l))
据测试，这个函数可以生成在unsigned int范围内的随机数（即可以生成 $[1,2^{32})$ 内的随机数），测试程序：">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://qjwh.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "生成随机数（未完工）",
      "item": "https://qjwh.github.io/posts/oi/aln/genrandomnumber/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "生成随机数（未完工）",
  "name": "生成随机数（未完工）",
  "description": "参考\n引用头文件（常用） #include \u0026lt;stdlib.h\u0026gt; //生成随机数、设定随机数种子 #include \u0026lt;ctime\u0026gt; //生成随机数种子（1） #include \u0026lt;time.h\u0026gt; //生成随机数种子（2） #include \u0026lt;unistd.h\u0026gt; //等待（sleep(...)或usleep(...)），该头文件现在不常用 随机种子 srand(time(0) ^ clock()); 注：随机种子为time(0) ^ clock()，这个随机种子可以再毫秒级别内生成（大概率）不同的随机种子。\n取 $[l,r]$ 内的随机数 #define random(l, r) (rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l)) 注：rand函数只能生成 $[1,32767]$ 内的随机数（见宏RAND_MAX），大概只能生成位数 $\\leq 5$ 的随机数；测试程序：\nLL ma = 0; for(LL i = 1;i \u0026lt;= 200;i++){ srand(time(0) ^ clock()); LL t = rand(); cout \u0026lt;\u0026lt; t \u0026lt;\u0026lt;endl; ma = max(ma, t); usleep(10000); } cout \u0026lt;\u0026lt; ma \u0026lt;\u0026lt;endl; 所以此处引用一个新方法：mt19937（2022/12/24：现在开始使用mt19937_64了，它可以生成 $[1,2^{64})$ 内的随机数，大一倍）。\n其实它的语法和rand的语法差不多 （才怪），是这样的：\n引用头文件（常用） #include \u0026lt;random\u0026gt; //生成随机数、设定随机数种子 #include \u0026lt;ctime\u0026gt; //生成随机数种子（1） #include \u0026lt;time.h\u0026gt; //生成随机数种子（2） #include \u0026lt;unistd.h\u0026gt; //等待（sleep(...)或usleep(...)），该头文件现在不常用 随机种子 mt19937 _rand(time(0) ^ clock()); 注：这个随机种子也可以再毫秒级别内生成（大概率）不同的随机种子\n取 $[l,r]$ 内的随机数 （就差一个字符_而已） #define random(l, r) (_rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l)) 据测试，这个函数可以生成在unsigned int范围内的随机数（即可以生成 $[1,2^{32})$ 内的随机数），测试程序：\n",
  "keywords": [
    "信息学竞赛", "算法学习笔记"
  ],
  "articleBody": "参考\n引用头文件（常用） #include //生成随机数、设定随机数种子 #include //生成随机数种子（1） #include //生成随机数种子（2） #include //等待（sleep(...)或usleep(...)），该头文件现在不常用 随机种子 srand(time(0) ^ clock()); 注：随机种子为time(0) ^ clock()，这个随机种子可以再毫秒级别内生成（大概率）不同的随机种子。\n取 $[l,r]$ 内的随机数 #define random(l, r) (rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l)) 注：rand函数只能生成 $[1,32767]$ 内的随机数（见宏RAND_MAX），大概只能生成位数 $\\leq 5$ 的随机数；测试程序：\nLL ma = 0; for(LL i = 1;i \u003c= 200;i++){ srand(time(0) ^ clock()); LL t = rand(); cout \u003c\u003c t \u003c\u003cendl; ma = max(ma, t); usleep(10000); } cout \u003c\u003c ma \u003c\u003cendl; 所以此处引用一个新方法：mt19937（2022/12/24：现在开始使用mt19937_64了，它可以生成 $[1,2^{64})$ 内的随机数，大一倍）。\n其实它的语法和rand的语法差不多 （才怪），是这样的：\n引用头文件（常用） #include //生成随机数、设定随机数种子 #include //生成随机数种子（1） #include //生成随机数种子（2） #include //等待（sleep(...)或usleep(...)），该头文件现在不常用 随机种子 mt19937 _rand(time(0) ^ clock()); 注：这个随机种子也可以再毫秒级别内生成（大概率）不同的随机种子\n取 $[l,r]$ 内的随机数 （就差一个字符_而已） #define random(l, r) (_rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l)) 据测试，这个函数可以生成在unsigned int范围内的随机数（即可以生成 $[1,2^{32})$ 内的随机数），测试程序：\nLL ma = 0; for(LL i = 1;i \u003c= 200;i++){ mt19937 _rand(time(0) ^ clock()); LL t = _rand(); cout \u003c\u003c t \u003c\u003cendl; ma = max(ma, t); usleep(10000); } cout \u003c\u003c ma \u003c\u003cendl; 那就有人问了，很多人会把mt19937（这是一个类，即class）类型的_rand定义到外面，此时clock()=0，不就相当于随机种子是time(0)吗？那怎么样更好地取随机种子呢？其实C++里实现了这个类的。\n这个类名叫random_device，用法如下：\nrandom_device rand_seed; mt19937 _rand(rand_seed()); 这样随机种子就可以更好地生成了。\nrandom_shuffle介绍 （待补）\nshuffle介绍 （待补）\n上面是一些语法，下面是一些模板和应用。\n（下述文章需完善）\n取一个长度在 $[milen,malen]$ 内的随机小写字母字符串 string get_rand_string_lower(LL milen, LL malen){ string ret; LL len = random(milen, malen); for(LL i = 1;i \u003c= len;i++) ret += 'a' + random(0, 25); return ret; } 取一个长度在 $[milen,malen]$ 内的随机大写字母字符串 string get_rand_string_upper(LL milen, LL malen){ string ret; LL len = random(milen, malen); for(LL i = 1;i \u003c= len;i++) ret += 'A' + random(0, 25); return ret; } 取一个长度在 $[milen,malen]$ 内的随机大小写字母+数字+下划线字符串 string get_rand_string_alpha_number_underline(LL milen, LL malen){ string ret; LL len = random(milen, malen); for(LL i = 1;i \u003c= len;i++){ LL val = random(1, 63); if(val \u003c= 26) ret += 'A' + val - 1; else if(val \u003c= 52) ret += 'a' + val - 27; else if(val \u003c= 62) ret += '0' + val - 53; else ret += '_'; } return ret; } 取一个长度在 $[milen,malen]$ 内的随机字符字符串 string get_rand_string_char(LL milen, LL malen){ string ret; LL len = random(milen, malen); for(LL i = 1;i \u003c= len;i++) ret += random(32, 126); return ret; } 每 $0.01$ 秒（非严格）输出一个随机“密码”（包含大小写字母、数字、下划线） while(true){ mt19937 _rand(time(0) ^ clock()); cout \u003c\u003c get_rand_string_alpha_number_underline(5, 10) \u003c\u003cendl; usleep(10000); } 输出严格单调递增序列（值域在 $[l,r]$ 内，一共要生成 $1 \\leq x \\leq r - l + 1$ 个数） //PriNT Strictly Monotonically Increasing Sequence void pnt_smis(LL l, LL r, LL x){ LL last = l - 1, cur; for(LL i = 1;i \u003c= x;i++){ cur = random(last + 1, r - (x - i)); printf(\"%lld \", cur); last = cur; } puts(\"\"); } 输出非严格单调递增序列（值域在 $[l,r]$ 内，一共要生成 $x$ 个数） //PriNT Non Strictly Monotonic Increasing Sequence void pnt_nsmis(LL l, LL r, LL x){ LL last = l, cur; for(LL i = 1;i \u003c= x;i++){ cur = random(last, r); printf(\"%lld \", cur); last = cur; } puts(\"\"); } 输出“随机树”（点数为 $n$） PII e[EDGES]; void pnt_random_tree(LL n){ printf(\"%lld\\n\", n); for(LL i = 2;i \u003c= n;i++) e[i - 1] = {random(1, i - 1), i}; random_shuffle(e + 1, e + (n - 1) + 1); for(LL i = 1;i \u003c n;i++){ LL t = random(0, 1); if(t) swap(e[i].first, e[i].second); } for(LL i = 1;i \u003c n;i++) printf(\"%lld %lld\\n\", e[i].first, e[i].second); } 输出随机DAG（点数为 $n$）\n方法1（未经过测试，而且此处只用于纪念，可以直接忽略）： LL n; struct Node{ LL from, to, next; }; Node a[M]; LL ind; LL pre[N]; void add(LL u, LL v){ ind++; a[ind] = {u, v, pre[u]}; pre[u] = ind; } bool flag = true, ret_flag = false; bool vis[N]; void dfs(LL x){ if(ret_flag) return; vis[x] = true; for(LL i = pre[x];i;i = a[i].next){ LL to = a[i].to; if(vis[to]){ flag = false, ret_flag = true; return; } dfs(to); if(ret_flag) return; } } bool check(){ flag = true, ret_flag = false; for(LL i = 1;i \u003c= n;i++){ if(!vis[i]) dfs(i); if(!flag) return false; } return true; } void pnt_random_DAG(){ while(true){ ind = 0; memset(pre, 0, sizeof(pre)); memset(vis, false, sizeof(vis)); n = random(1, 10); printf(\"%lld\\n\", n); for(LL i = 1;i \u003c= n;i++){ LL s = random(1, 5); printf(\"%lld \", s); while(s--){ LL to = random(1, n); printf(\"%lld \", to); add(i, to); } puts(\"\"); } if(check()) break; else system(\"cls\"); } } 方法2 （推荐）： void pnt_random_DAG(){ LL n = random(1, 1e5); printf(\"%lld %lld\\n\", n, random(1, 10)); for(LL i = 1;i \u003c= n;i++){ LL s = random(1, 5); printf(\"%lld \", s); while(s--){ LL to = random(i + 1, n); printf(\"%lld \", to); } puts(\"\"); } } ",
  "wordCount" : "682",
  "inLanguage": "zh",
  "datePublished": "2025-02-09T15:28:00+08:00",
  "dateModified": "2025-02-09T15:28:00+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://qjwh.github.io/posts/oi/aln/genrandomnumber/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "CXBlog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://qjwh.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://qjwh.github.io/" accesskey="h" title="CXBlog (Alt + H)">CXBlog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://qjwh.github.io/posts/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://qjwh.github.io/archives/" title="列表">
                    <span>列表</span>
                </a>
            </li>
            <li>
                <a href="https://qjwh.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://qjwh.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      生成随机数（未完工）
    </h1>
    <div class="post-meta"><span title='2025-02-09 15:28:00 +0800 CST'>2025年2月9日</span>&nbsp;·&nbsp;4 分钟&nbsp;·&nbsp;682 字

</div>
  </header> 

  <div class="post-content"><p><a href="https://blog.csdn.net/LU_ZHAO/article/details/104305240">参考</a></p>
<ul>
<li>引用头文件（常用）</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">  </span><span class="c1">//生成随机数、设定随机数种子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">  </span><span class="c1">//生成随机数种子（1）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">  </span><span class="c1">//生成随机数种子（2）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">  </span><span class="c1">//等待（sleep(...)或usleep(...)），该头文件现在不常用
</span></span></span></code></pre></div><ul>
<li>随机种子</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="n">clock</span><span class="p">());</span>
</span></span></code></pre></div><blockquote>
<p>注：随机种子为<code>time(0) ^ clock()</code>，这个随机种子可以再毫秒级别内生成（大概率）不同的随机种子。</p></blockquote>
<ul>
<li>取 $[l,r]$ 内的随机数</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define random(l, r) (rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l))
</span></span></span></code></pre></div><blockquote>
<p>注：<code>rand</code>函数只能生成 $[1,32767]$ 内的随机数（见宏<code>RAND_MAX</code>），大概只能生成位数 $\leq 5$ 的随机数；测试程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">LL</span> <span class="n">ma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="n">LL</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">200</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="n">clock</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">LL</span> <span class="n">t</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ma</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">usleep</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ma</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></div><p>所以此处引用一个新方法：<code>mt19937</code>（2022/12/24：现在开始使用<code>mt19937_64</code>了，它可以生成 $[1,2^{64})$ 内的随机数，大一倍）。</p>
<p>其实它的语法和<code>rand</code>的语法差不多 <del>（才怪）</del>，是这样的：</p>
<blockquote>
<ul>
<li>引用头文件（常用）</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">  </span><span class="c1">//生成随机数、设定随机数种子
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp">  </span><span class="c1">//生成随机数种子（1）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp">  </span><span class="c1">//生成随机数种子（2）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">  </span><span class="c1">//等待（sleep(...)或usleep(...)），该头文件现在不常用
</span></span></span></code></pre></div><ul>
<li>随机种子</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">mt19937</span> <span class="nf">_rand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="n">clock</span><span class="p">());</span>
</span></span></code></pre></div><p>注：这个随机种子也可以再毫秒级别内生成（大概率）不同的随机种子</p>
<ul>
<li>取 $[l,r]$ 内的随机数 <del>（就差一个字符<code>_</code>而已）</del></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#define random(l, r) (_rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l))
</span></span></span></code></pre></div><p>据测试，这个函数可以生成在<code>unsigned int</code>范围内的随机数（即可以生成 $[1,2^{32})$ 内的随机数），测试程序：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">LL</span> <span class="n">ma</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="n">LL</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">200</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">mt19937</span> <span class="nf">_rand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="n">clock</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    <span class="n">LL</span> <span class="n">t</span> <span class="o">=</span> <span class="n">_rand</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">ma</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">usleep</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ma</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span></code></pre></div></blockquote>
<p>那就有人问了，很多人会把<code>mt19937</code>（这是一个类，即<code>class</code>）类型的<code>_rand</code>定义到外面，此时<code>clock()=0</code>，不就相当于随机种子是<code>time(0)</code>吗？那怎么样更好地取随机种子呢？其实C++里实现了这个类的。</p>
<p>这个类名叫<code>random_device</code>，用法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">random_device</span> <span class="n">rand_seed</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">mt19937</span> <span class="nf">_rand</span><span class="p">(</span><span class="n">rand_seed</span><span class="p">());</span>
</span></span></code></pre></div><p>这样随机种子就可以更好地生成了。</p></blockquote>
<p><code>random_shuffle</code>介绍 <em>（待补）</em></p>
<p><code>shuffle</code>介绍 <em>（待补）</em></p>
<hr>
<p>上面是一些语法，下面是一些模板和应用。</p>
<p><em>（下述文章需完善）</em></p>
<ul>
<li>取一个长度在 $[milen,malen]$ 内的随机小写字母字符串</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">get_rand_string_lower</span><span class="p">(</span><span class="n">LL</span> <span class="n">milen</span><span class="p">,</span> <span class="n">LL</span> <span class="n">malen</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LL</span> <span class="n">len</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="n">milen</span><span class="p">,</span> <span class="n">malen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">LL</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">ret</span> <span class="o">+=</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="n">random</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>取一个长度在 $[milen,malen]$ 内的随机大写字母字符串</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">get_rand_string_upper</span><span class="p">(</span><span class="n">LL</span> <span class="n">milen</span><span class="p">,</span> <span class="n">LL</span> <span class="n">malen</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LL</span> <span class="n">len</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="n">milen</span><span class="p">,</span> <span class="n">malen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">LL</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">ret</span> <span class="o">+=</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="n">random</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>取一个长度在 $[milen,malen]$ 内的随机大小写字母+数字+下划线字符串</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">get_rand_string_alpha_number_underline</span><span class="p">(</span><span class="n">LL</span> <span class="n">milen</span><span class="p">,</span> <span class="n">LL</span> <span class="n">malen</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LL</span> <span class="n">len</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="n">milen</span><span class="p">,</span> <span class="n">malen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">LL</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">LL</span> <span class="n">val</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">63</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">26</span><span class="p">)</span> <span class="n">ret</span> <span class="o">+=</span> <span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="n">val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">52</span><span class="p">)</span> <span class="n">ret</span> <span class="o">+=</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="n">val</span> <span class="o">-</span> <span class="mi">27</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">val</span> <span class="o">&lt;=</span> <span class="mi">62</span><span class="p">)</span> <span class="n">ret</span> <span class="o">+=</span> <span class="sc">&#39;0&#39;</span> <span class="o">+</span> <span class="n">val</span> <span class="o">-</span> <span class="mi">53</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="n">ret</span> <span class="o">+=</span> <span class="sc">&#39;_&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>取一个长度在 $[milen,malen]$ 内的随机字符字符串</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">get_rand_string_char</span><span class="p">(</span><span class="n">LL</span> <span class="n">milen</span><span class="p">,</span> <span class="n">LL</span> <span class="n">malen</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">LL</span> <span class="n">len</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="n">milen</span><span class="p">,</span> <span class="n">malen</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">LL</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">ret</span> <span class="o">+=</span> <span class="n">random</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">126</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>每 $0.01$ 秒（非严格）输出一个随机“密码”（包含大小写字母、数字、下划线）</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">mt19937</span> <span class="nf">_rand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">^</span> <span class="n">clock</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">get_rand_string_alpha_number_underline</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">usleep</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>输出严格单调递增序列（值域在 $[l,r]$ 内，一共要生成 $1 \leq x \leq r - l + 1$ 个数）</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">     <span class="c1">//PriNT Strictly Monotonically Increasing Sequence
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">pnt_smis</span><span class="p">(</span><span class="n">LL</span> <span class="n">l</span><span class="p">,</span> <span class="n">LL</span> <span class="n">r</span><span class="p">,</span> <span class="n">LL</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">LL</span> <span class="n">last</span> <span class="o">=</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">LL</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">cur</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="n">last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">i</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%lld &#34;</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">last</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">puts</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>输出非严格单调递增序列（值域在 $[l,r]$ 内，一共要生成 $x$ 个数）</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">     <span class="c1">//PriNT Non Strictly Monotonic Increasing Sequence
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">pnt_nsmis</span><span class="p">(</span><span class="n">LL</span> <span class="n">l</span><span class="p">,</span> <span class="n">LL</span> <span class="n">r</span><span class="p">,</span> <span class="n">LL</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">LL</span> <span class="n">last</span> <span class="o">=</span> <span class="n">l</span><span class="p">,</span> <span class="n">cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">LL</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">cur</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="n">last</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%lld &#34;</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">last</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">puts</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>输出“随机树”（点数为 $n$）</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">PII</span> <span class="n">e</span><span class="p">[</span><span class="n">EDGES</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">pnt_random_tree</span><span class="p">(</span><span class="n">LL</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%lld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">LL</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">random</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">i</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">random_shuffle</span><span class="p">(</span><span class="n">e</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">e</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">LL</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">LL</span> <span class="n">t</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="n">swap</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">LL</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%lld %lld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>
<p>输出随机DAG（点数为 $n$）</p>
<ul>
<li>方法1（未经过测试，而且<del>此处只用于纪念</del>，可以直接忽略）：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">LL</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Node</span><span class="p">{</span> <span class="n">LL</span> <span class="n">from</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="n">Node</span> <span class="n">a</span><span class="p">[</span><span class="n">M</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">LL</span> <span class="n">ind</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">LL</span> <span class="n">pre</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">LL</span> <span class="n">u</span><span class="p">,</span> <span class="n">LL</span> <span class="n">v</span><span class="p">){</span> <span class="n">ind</span><span class="o">++</span><span class="p">;</span> <span class="n">a</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">pre</span><span class="p">[</span><span class="n">u</span><span class="p">]};</span> <span class="n">pre</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">ind</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="n">ret_flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="n">vis</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">LL</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">ret_flag</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">vis</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">LL</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pre</span><span class="p">[</span><span class="n">x</span><span class="p">];</span><span class="n">i</span><span class="p">;</span><span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">LL</span> <span class="n">to</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">to</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">vis</span><span class="p">[</span><span class="n">to</span><span class="p">]){</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">ret_flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">dfs</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">ret_flag</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">check</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span> <span class="n">ret_flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">LL</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">vis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">pnt_random_DAG</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">memset</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">pre</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">memset</span><span class="p">(</span><span class="n">vis</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">vis</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">n</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%lld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="n">LL</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">LL</span> <span class="n">s</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%lld &#34;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="n">LL</span> <span class="n">to</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%lld &#34;</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="n">puts</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">())</span> <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="n">system</span><span class="p">(</span><span class="s">&#34;cls&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ul>
<li>方法2 <strong>（推荐）</strong>：</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">pnt_random_DAG</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">LL</span> <span class="n">n</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">1e5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%lld %lld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">random</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="n">LL</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">LL</span> <span class="n">s</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%lld &#34;</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">LL</span> <span class="n">to</span> <span class="o">=</span> <span class="n">random</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">printf</span><span class="p">(</span><span class="s">&#34;%lld &#34;</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">puts</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://qjwh.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/">信息学竞赛</a></li>
      <li><a href="https://qjwh.github.io/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">算法学习笔记</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://qjwh.github.io/">CXBlog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
