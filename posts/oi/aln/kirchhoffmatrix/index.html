<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>基尔霍夫矩阵 | CXBlog</title>
<meta name="keywords" content="信息学竞赛, 算法学习笔记">
<meta name="description" content="基尔霍夫矩阵是用来求解生成树计数、求（权值）和相关题目的利器。

 0. 求完全图的生成树数量（Prufer序列）
要说基尔霍夫矩阵，就要从一道题目说起：

给你 $n$，问 $n$ 个节点组成的无向无根树有多少种。
这道题可以用Prufer序列去做。
这里简单说一下Prufer序列的求法：

对于一张无向无根树，重复执行以下操作直到只剩 $2$ 个或更少的点，最后得到的那个序列 $a$ 就是这棵树的Prufer序列：

我们找到此时度为 $1$ 的节点，若有多个，找编号最小的，设找到的节点编号为 $x$。
在 $a$ 的末尾添加：与 $x$ 有连边的那个唯一节点。
删除 $x$。

Prufer序列别看求法非常简单，也没啥容易发现的性质，其实用处很大。
Prufer序列满足一个性质，就是，所有无向无根树，都可以唯一地对应一个Prufer序列；所有Prufer序列都可以唯一地对应一棵树。
所以，这道题就有解了，答案其实就是长为 $n-2$ 的Prufer序列有多少种。
由于Prufer序列的每个元素的值都是从 $1$ 到 $n$ 的，所以答案就是 $n^{n-2}$，显然。

 1.1. 求任意无向图的生成树数量（基尔霍夫矩阵）
但如果把题目变化一下，就不能用Prufer序列去求了：

给你一张 $n$ 个节点 $m$ 条边的无向图，问这张图的生成树有多少个。
这题要用基尔霍夫矩阵。
具体地，我们定义 $D$ 矩阵，求法：
$
D_{i,j}=
\begin{cases}
0 &amp; i \not= j \
\text{deg}(i) &amp; i=j
\end{cases}
$
其中，$\text{deg}(i)$ 代表这张图上 $i$ 的度是多少。">
<meta name="author" content="">
<link rel="canonical" href="https://qjwh.github.io/posts/oi/aln/kirchhoffmatrix/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3b2e5c86d6776f1230a6cc3dbc6bde31467e6a5f6513337e196964b4e3693a57.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://qjwh.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://qjwh.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://qjwh.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://qjwh.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://qjwh.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://qjwh.github.io/posts/oi/aln/kirchhoffmatrix/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script src="https://unpkg.com/feather-icons"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      
      
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false},
      ],
      
      throwOnError : false
    });
  });
</script>

<style>
    @font-face { 
        font-family: 'Ubuntu';
        src: url('/UbuntuB.ttf');
    }
    body {
        
        font-family: 'Ubuntu';
    }
</style><meta property="og:url" content="https://qjwh.github.io/posts/oi/aln/kirchhoffmatrix/">
  <meta property="og:site_name" content="CXBlog">
  <meta property="og:title" content="基尔霍夫矩阵">
  <meta property="og:description" content="基尔霍夫矩阵是用来求解生成树计数、求（权值）和相关题目的利器。
0. 求完全图的生成树数量（Prufer序列） 要说基尔霍夫矩阵，就要从一道题目说起：
给你 $n$，问 $n$ 个节点组成的无向无根树有多少种。
这道题可以用Prufer序列去做。
这里简单说一下Prufer序列的求法：
对于一张无向无根树，重复执行以下操作直到只剩 $2$ 个或更少的点，最后得到的那个序列 $a$ 就是这棵树的Prufer序列：
我们找到此时度为 $1$ 的节点，若有多个，找编号最小的，设找到的节点编号为 $x$。 在 $a$ 的末尾添加：与 $x$ 有连边的那个唯一节点。 删除 $x$。 Prufer序列别看求法非常简单，也没啥容易发现的性质，其实用处很大。
Prufer序列满足一个性质，就是，所有无向无根树，都可以唯一地对应一个Prufer序列；所有Prufer序列都可以唯一地对应一棵树。
所以，这道题就有解了，答案其实就是长为 $n-2$ 的Prufer序列有多少种。
由于Prufer序列的每个元素的值都是从 $1$ 到 $n$ 的，所以答案就是 $n^{n-2}$，显然。
1.1. 求任意无向图的生成树数量（基尔霍夫矩阵） 但如果把题目变化一下，就不能用Prufer序列去求了：
给你一张 $n$ 个节点 $m$ 条边的无向图，问这张图的生成树有多少个。
这题要用基尔霍夫矩阵。
具体地，我们定义 $D$ 矩阵，求法：
$ D_{i,j}= \begin{cases} 0 &amp; i \not= j \ \text{deg}(i) &amp; i=j \end{cases} $
其中，$\text{deg}(i)$ 代表这张图上 $i$ 的度是多少。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-02-09T15:28:00+08:00">
    <meta property="article:modified_time" content="2025-02-09T15:28:00+08:00">
    <meta property="article:tag" content="信息学竞赛">
    <meta property="article:tag" content="算法学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基尔霍夫矩阵">
<meta name="twitter:description" content="基尔霍夫矩阵是用来求解生成树计数、求（权值）和相关题目的利器。

 0. 求完全图的生成树数量（Prufer序列）
要说基尔霍夫矩阵，就要从一道题目说起：

给你 $n$，问 $n$ 个节点组成的无向无根树有多少种。
这道题可以用Prufer序列去做。
这里简单说一下Prufer序列的求法：

对于一张无向无根树，重复执行以下操作直到只剩 $2$ 个或更少的点，最后得到的那个序列 $a$ 就是这棵树的Prufer序列：

我们找到此时度为 $1$ 的节点，若有多个，找编号最小的，设找到的节点编号为 $x$。
在 $a$ 的末尾添加：与 $x$ 有连边的那个唯一节点。
删除 $x$。

Prufer序列别看求法非常简单，也没啥容易发现的性质，其实用处很大。
Prufer序列满足一个性质，就是，所有无向无根树，都可以唯一地对应一个Prufer序列；所有Prufer序列都可以唯一地对应一棵树。
所以，这道题就有解了，答案其实就是长为 $n-2$ 的Prufer序列有多少种。
由于Prufer序列的每个元素的值都是从 $1$ 到 $n$ 的，所以答案就是 $n^{n-2}$，显然。

 1.1. 求任意无向图的生成树数量（基尔霍夫矩阵）
但如果把题目变化一下，就不能用Prufer序列去求了：

给你一张 $n$ 个节点 $m$ 条边的无向图，问这张图的生成树有多少个。
这题要用基尔霍夫矩阵。
具体地，我们定义 $D$ 矩阵，求法：
$
D_{i,j}=
\begin{cases}
0 &amp; i \not= j \
\text{deg}(i) &amp; i=j
\end{cases}
$
其中，$\text{deg}(i)$ 代表这张图上 $i$ 的度是多少。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://qjwh.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "基尔霍夫矩阵",
      "item": "https://qjwh.github.io/posts/oi/aln/kirchhoffmatrix/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "基尔霍夫矩阵",
  "name": "基尔霍夫矩阵",
  "description": "基尔霍夫矩阵是用来求解生成树计数、求（权值）和相关题目的利器。\n0. 求完全图的生成树数量（Prufer序列） 要说基尔霍夫矩阵，就要从一道题目说起：\n给你 $n$，问 $n$ 个节点组成的无向无根树有多少种。\n这道题可以用Prufer序列去做。\n这里简单说一下Prufer序列的求法：\n对于一张无向无根树，重复执行以下操作直到只剩 $2$ 个或更少的点，最后得到的那个序列 $a$ 就是这棵树的Prufer序列：\n我们找到此时度为 $1$ 的节点，若有多个，找编号最小的，设找到的节点编号为 $x$。 在 $a$ 的末尾添加：与 $x$ 有连边的那个唯一节点。 删除 $x$。 Prufer序列别看求法非常简单，也没啥容易发现的性质，其实用处很大。\nPrufer序列满足一个性质，就是，所有无向无根树，都可以唯一地对应一个Prufer序列；所有Prufer序列都可以唯一地对应一棵树。\n所以，这道题就有解了，答案其实就是长为 $n-2$ 的Prufer序列有多少种。\n由于Prufer序列的每个元素的值都是从 $1$ 到 $n$ 的，所以答案就是 $n^{n-2}$，显然。\n1.1. 求任意无向图的生成树数量（基尔霍夫矩阵） 但如果把题目变化一下，就不能用Prufer序列去求了：\n给你一张 $n$ 个节点 $m$ 条边的无向图，问这张图的生成树有多少个。\n这题要用基尔霍夫矩阵。\n具体地，我们定义 $D$ 矩阵，求法：\n$ D_{i,j}= \\begin{cases} 0 \u0026amp; i \\not= j \\ \\text{deg}(i) \u0026amp; i=j \\end{cases} $\n其中，$\\text{deg}(i)$ 代表这张图上 $i$ 的度是多少。\n",
  "keywords": [
    "信息学竞赛", "算法学习笔记"
  ],
  "articleBody": "基尔霍夫矩阵是用来求解生成树计数、求（权值）和相关题目的利器。\n0. 求完全图的生成树数量（Prufer序列） 要说基尔霍夫矩阵，就要从一道题目说起：\n给你 $n$，问 $n$ 个节点组成的无向无根树有多少种。\n这道题可以用Prufer序列去做。\n这里简单说一下Prufer序列的求法：\n对于一张无向无根树，重复执行以下操作直到只剩 $2$ 个或更少的点，最后得到的那个序列 $a$ 就是这棵树的Prufer序列：\n我们找到此时度为 $1$ 的节点，若有多个，找编号最小的，设找到的节点编号为 $x$。 在 $a$ 的末尾添加：与 $x$ 有连边的那个唯一节点。 删除 $x$。 Prufer序列别看求法非常简单，也没啥容易发现的性质，其实用处很大。\nPrufer序列满足一个性质，就是，所有无向无根树，都可以唯一地对应一个Prufer序列；所有Prufer序列都可以唯一地对应一棵树。\n所以，这道题就有解了，答案其实就是长为 $n-2$ 的Prufer序列有多少种。\n由于Prufer序列的每个元素的值都是从 $1$ 到 $n$ 的，所以答案就是 $n^{n-2}$，显然。\n1.1. 求任意无向图的生成树数量（基尔霍夫矩阵） 但如果把题目变化一下，就不能用Prufer序列去求了：\n给你一张 $n$ 个节点 $m$ 条边的无向图，问这张图的生成树有多少个。\n这题要用基尔霍夫矩阵。\n具体地，我们定义 $D$ 矩阵，求法：\n$ D_{i,j}= \\begin{cases} 0 \u0026 i \\not= j \\ \\text{deg}(i) \u0026 i=j \\end{cases} $\n其中，$\\text{deg}(i)$ 代表这张图上 $i$ 的度是多少。\n我们再定义 $A$ 矩阵，求法：\n$ A_{i,j}= \\begin{cases} \\text{ecnt}(i,j) \u0026 i \\not= j \\ 0 \u0026 i=j \\end{cases} $\n其中，$\\text{ecnt}(i,j)$ 代表这张图上点 $i$ 和点 $j$ 之间的边数。\n然后，我们再定义基尔霍夫矩阵 $K=D-A$，即：\n$ K_{i,j}= \\begin{cases} -\\text{ecnt}(i,j) \u0026 i \\not= j \\ \\text{deg}(i) \u0026 i=j \\end{cases} $\n最后，我们同时删掉 $K$ 中的一行和一列（一般是删掉最后一行和最后一列，但删掉哪一行、哪一列答案都不变），此时 $K$ 的行列式即为本题答案。\n（以下所有 $D$、$A$、$K$ 的求法都是一样的，答案求法也是一样的，所以只说 $\\text{deg}$ 函数和 $\\text{ecnt}$ 函数的求法）\n*注：\n如果是有向图生成树相关题目，且题目指定了根，那么删除的那一行和那一列的编号，必须是根节点的编号。\n如，题目要求 $1$ 节点为根，那么删除的必须要是第一行和第一列，否则会WA。\n此外，以下所有题里，在求 $\\text{deg}$ 函数和 $\\text{ecnt}$ 函数时，都要忽略自环。\n并且，如果说下面构造的方阵没有行列式，那么就说明没有生成树，要输出 $0$。\n1.2. 求任意无向带权图的生成树权值之和（基尔霍夫矩阵） 这题还有变种：\n给你一张 $n$ 个节点 $m$ 条边的无向带权图，问这张图所有生成树的权值之和。\n一棵生成树的权值定义为这棵生成树内所有边权之和。\n$\\text{deg}(i)$ 代表这张图上 $i$ 的所有出边的边权之和，$\\text{ecnt}(i,j)$ 代表这张图上点 $i$ 和点 $j$ 之间所有边的边权和。\n2.1.1. 求任意有向图的生成外向树数量（基尔霍夫矩阵） 但还没完，还有题目：\n给你一张 $n$ 个节点 $m$ 条边的有向图，问这张图的生成树有多少个。\n此处，生成树要求是外向树。\n所谓外向树，就是一棵有向树，满足每条边都是从父亲指向儿子的。\n$\\text{deg}(i)$ 代表这张图上 $i$ 的入度，$\\text{ecnt}(i,j)$ 代表这张图上从点 $i$ 连向点 $j$ 的边的数量。\n2.1.2. 求任意有向带权图的生成外向树权值之和（基尔霍夫矩阵） 但还没完，还有题目：\n给你一张 $n$ 个节点 $m$ 条边的有向带权图，问这张图的生成树的权值之和。\n此处，生成树要求是外向树。\n$\\text{deg}(i)$ 代表这张图内连向 $i$ 的边权之和，$\\text{ecnt}(i,j)$ 代表这张图上从点 $i$ 连向点 $j$ 的边权之和。\n2.2.1. 求任意有向图的生成内向树数量（基尔霍夫矩阵） 但还没完，还有题目：\n给你一张 $n$ 个节点 $m$ 条边的有向图，问这张图的生成树有多少个。\n此处，生成树要求是内向树。\n所谓内向树，就是一棵有向树，满足每条边都是从儿子指向父亲的。\n$\\text{deg}(i)$ 代表这张图上 $i$ 的出度，$\\text{ecnt}(i,j)$ 代表这张图上从点 $i$ 连向点 $j$ 的边的数量。\n2.2.2. 求任意有向带权图的生成内向树权值之和（基尔霍夫矩阵） 但还没完，还有题目：\n给你一张 $n$ 个节点 $m$ 条边的有向带权图，问这张图的生成树的权值之和。\n此处，生成树要求是内向树。\n$\\text{deg}(i)$ 代表这张图内 $i$ 的出边边权之和，$\\text{ecnt}(i,j)$ 代表这张图上从点 $i$ 连向点 $j$ 的边权之和。\n3. 求完全二分图的生成树个数（基尔霍夫矩阵拓展） 但还没完，还有题目：\n给你两个数 $n$、$m$，问左边 $n$ 个点，右边 $m$ 个点的完全二分图的生成树个数。\n这个问题可以被转化为问题1.1，所以我们就可以得到基尔霍夫矩阵：\n$ \\begin{bmatrix} m \u0026 0 \u0026 \\cdots \u0026 0 \u0026 -1 \u0026 -1 \u0026 \\cdots \u0026 -1 \\ 0 \u0026 m \u0026 \\cdots \u0026 0 \u0026 -1 \u0026 -1 \u0026 \\cdots \u0026 -1 \\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\ 0 \u0026 0 \u0026 \\cdots \u0026 m \u0026 -1 \u0026 -1 \u0026 \\cdots \u0026 -1 \\ -1 \u0026 -1 \u0026 \\cdots \u0026 -1 \u0026 n \u0026 0 \u0026 \\cdots \u0026 0 \\ -1 \u0026 -1 \u0026 \\cdots \u0026 -1 \u0026 0 \u0026 n \u0026 \\cdots \u0026 0 \\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\ -1 \u0026 -1 \u0026 \\cdots \u0026 -1 \u0026 0 \u0026 0 \u0026 \\cdots \u0026 n \\ \\end{bmatrix} $\n标一些参数：\n（图1）\n然后，可以发现，在上面的划分方案中，左上部分和右下部分其实都是方阵，所以我们只要让左下部分全部变为 $0$ 就可以用行列式性质转化问题了。\n进而，既然求这个矩阵的行列式，我们就先把最后一行和最后一列去掉，即把图1的参数内的两个 $m$ 改成 $m-1$。\n我们既然要把左下部分变成 $0$，我们就要变化矩阵。\n我们首先把矩阵前 $n$ 行全部除以 $m$，得到：\n$ \\large \\begin{bmatrix} 1 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 \\frac{-1}{m} \u0026 \\frac{-1}{m} \u0026 \\cdots \u0026 \\frac{-1}{m} \\ 0 \u0026 1 \u0026 \\cdots \u0026 0 \u0026 \\frac{-1}{m} \u0026 \\frac{-1}{m} \u0026 \\cdots \u0026 \\frac{-1}{m} \\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\ 0 \u0026 0 \u0026 \\cdots \u0026 1 \u0026 \\frac{-1}{m} \u0026 \\frac{-1}{m} \u0026 \\cdots \u0026 \\frac{-1}{m} \\ -1 \u0026 -1 \u0026 \\cdots \u0026 -1 \u0026 n \u0026 0 \u0026 \\cdots \u0026 0 \\ -1 \u0026 -1 \u0026 \\cdots \u0026 -1 \u0026 0 \u0026 n \u0026 \\cdots \u0026 0 \\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\ -1 \u0026 -1 \u0026 \\cdots \u0026 -1 \u0026 0 \u0026 0 \u0026 \\cdots \u0026 n \\ \\end{bmatrix} $\n其次，算出前 $n$ 行矩阵之和：\n$ \\large \\begin{bmatrix} 1 \u0026 1 \u0026 \\cdots \u0026 1 \u0026 \\frac{-n}{m} \u0026 \\frac{-n}{m} \u0026 \\cdots \u0026 \\frac{-n}{m} \\end{bmatrix} $\n然后，对于后 $m-1$ 行，每一行都加上前 $n$ 行之和：\n$ \\large \\begin{bmatrix} 1 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 \\frac{-1}{m} \u0026 \\frac{-1}{m} \u0026 \\cdots \u0026 \\frac{-1}{m} \\ 0 \u0026 1 \u0026 \\cdots \u0026 0 \u0026 \\frac{-1}{m} \u0026 \\frac{-1}{m} \u0026 \\cdots \u0026 \\frac{-1}{m} \\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\ 0 \u0026 0 \u0026 \\cdots \u0026 1 \u0026 \\frac{-1}{m} \u0026 \\frac{-1}{m} \u0026 \\cdots \u0026 \\frac{-1}{m} \\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 n-\\frac{n}{m} \u0026 -\\frac{n}{m} \u0026 \\cdots \u0026 -\\frac{n}{m} \\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 -\\frac{n}{m} \u0026 n-\\frac{n}{m} \u0026 \\cdots \u0026 -\\frac{n}{m} \\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 -\\frac{n}{m} \u0026 -\\frac{n}{m} \u0026 \\cdots \u0026 n-\\frac{n}{m} \\ \\end{bmatrix} $\n最后，把前 $n$ 行重新都乘上 $m$：\n$ \\large \\begin{bmatrix} m \u0026 0 \u0026 \\cdots \u0026 0 \u0026 -1 \u0026 -1 \u0026 \\cdots \u0026 -1 \\ 0 \u0026 m \u0026 \\cdots \u0026 0 \u0026 -1 \u0026 -1 \u0026 \\cdots \u0026 -1 \\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\ 0 \u0026 0 \u0026 \\cdots \u0026 m \u0026 -1 \u0026 -1 \u0026 \\cdots \u0026 -1 \\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 n-\\frac{n}{m} \u0026 -\\frac{n}{m} \u0026 \\cdots \u0026 -\\frac{n}{m} \\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 -\\frac{n}{m} \u0026 n-\\frac{n}{m} \u0026 \\cdots \u0026 -\\frac{n}{m} \\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\ 0 \u0026 0 \u0026 \\cdots \u0026 0 \u0026 -\\frac{n}{m} \u0026 -\\frac{n}{m} \u0026 \\cdots \u0026 n-\\frac{n}{m} \\ \\end{bmatrix} $\n此时左下角都是 $0$ 了。\n于是乎，问题就转化为了以下两个矩阵的行列式之积：\n$ D_1= \\large \\begin{bmatrix} m \u0026 0 \u0026 \\cdots \u0026 0 \\ 0 \u0026 m \u0026 \\cdots \u0026 0 \\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\ 0 \u0026 0 \u0026 \\cdots \u0026 m \\end{bmatrix} $\n$ D_2= \\large \\begin{bmatrix} n-\\frac{n}{m} \u0026 -\\frac{n}{m} \u0026 \\cdots \u0026 -\\frac{n}{m} \\\\ -\\frac{n}{m} \u0026 n-\\frac{n}{m} \u0026 \\cdots \u0026 -\\frac{n}{m} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ -\\frac{n}{m} \u0026 -\\frac{n}{m} \u0026 \\cdots \u0026 n-\\frac{n}{m} \\end{bmatrix} $\n（注意，$D_2$ 是个 $(m-1) \\times (m-1)$ 的矩阵，而不是 $m \\times m$ 的）\n$D_1$ 由于本身就是上三角矩阵，根据行列式性质，$\\det D_1=m^n$。\n但 $D_2$ 并不是，所以还要转化。\n（以下都针对 $D_2$ 矩阵进行转化）\n我们首先求出这 $m-1$ 行的和：\n$ \\begin{bmatrix} n-(m-1) \\times \\frac{n}{m} \u0026 n-(m-1) \\times \\frac{n}{m} \u0026 \\cdots \u0026 n-(m-1) \\times \\frac{n}{m} \\end{bmatrix} $\n其次把上述矩阵直接替换到第一行：\n$ \\begin{bmatrix} n-(m-1) \\times \\frac{n}{m} \u0026 n-(m-1) \\times \\frac{n}{m} \u0026 \\cdots \u0026 n-(m-1) \\times \\frac{n}{m} \\\\ -\\frac{n}{m} \u0026 n-\\frac{n}{m} \u0026 \\cdots \u0026 -\\frac{n}{m} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ -\\frac{n}{m} \u0026 -\\frac{n}{m} \u0026 \\cdots \u0026 n-\\frac{n}{m} \\end{bmatrix} $\n发现第一行都是一样的，所以我们就把第一行统一除以 $n-(m-1) \\times \\frac{n}{m}$，行列式也除以了 $n-(m-1) \\times \\frac{n}{m}$，所以 $D_2$ 的行列式其实是下述矩阵的行列式乘上 $n-(m-1) \\times \\frac{n}{m}$：\n$ T= \\begin{bmatrix} 1 \u0026 1 \u0026 \\cdots \u0026 1 \\\\ -\\frac{n}{m} \u0026 n-\\frac{n}{m} \u0026 \\cdots \u0026 -\\frac{n}{m} \\\\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\ -\\frac{n}{m} \u0026 -\\frac{n}{m} \u0026 \\cdots \u0026 n-\\frac{n}{m} \\end{bmatrix} $\n（以下暂时换为针对 $T$ 矩阵进行转化）\n我们把第一行全部乘上 $\\frac{m}{n}$，然后加到下面每一行：（即把下面每一行内的 $-\\frac{n}{m}$ 都删掉）\n$ \\begin{bmatrix} 1 \u0026 1 \u0026 \\cdots \u0026 1 \\ 0 \u0026 n \u0026 \\cdots \u0026 0 \\ \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\ 0 \u0026 0 \u0026 \\cdots \u0026 n \\end{bmatrix} $\n此时就是个上三角矩阵了，这个矩阵的行列式 $\\det T=n^{m-2}$，显然。\n但 $\\det D_2=(n-(m-1) \\times \\frac{n}{m}) \\times (\\det T)$，所以我们转化一下式子：\n（以下省略 $\\det D_2=$）\n带入 $\\det T$：\n$(n-(m-1) \\times \\frac{n}{m}) \\times n^{m-2}$\n拆括号：\n$n \\times n^{m-2}-(m-1) \\times \\frac{n}{m} \\times n^{m-2}$\n简化式子：\n$n^{m-1}-(m-1) \\times \\frac{n}{m} \\times n^{m-2}$\n拆开分数：\n$n^{m-1}-(m-1) \\times \\frac{1}{m} \\times n \\times n^{m-2}$\n即：\n$n^{m-1}-(m-1) \\times \\frac{1}{m} \\times n^{m-1}$\n拆括号：\n$n^{m-1}-(m \\times \\frac{1}{m}-\\frac{1}{m}) \\times n^{m-1}$\n即：\n$n^{m-1}-(1-\\frac{1}{m}) \\times n^{m-1}$\n拆括号：\n$n^{m-1}-(n^{m-1}-\\frac{1}{m} \\times n^{m-1})$\n拆括号：\n$n^{m-1}-n^{m-1}+\\frac{1}{m} \\times n^{m-1}$\n即：\n$\\frac{1}{m} \\times n^{m-1}$\n但还没完，答案是 $(\\det D_1) \\times (\\det D_2)$，所以需要推导一下：\n带入：\n$(m^n) \\times (\\frac{1}{m} \\times n^{m-1})$\n拆括号：\n$m^n \\times \\frac{1}{m} \\times n^{m-1}$\n即：\n$m^{n-1} \\times n^{m-1}$\n所以其实这题的代码很短，只用算 $m^{n-1} \\times n^{m-1}$ 的值即可。\n*注：这道题原题是M2733，另一种用Prufer序列证明这个答案的方法见本题写的题解，在题解文件夹内。\n",
  "wordCount" : "1159",
  "inLanguage": "en",
  "datePublished": "2025-02-09T15:28:00+08:00",
  "dateModified": "2025-02-09T15:28:00+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://qjwh.github.io/posts/oi/aln/kirchhoffmatrix/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "CXBlog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://qjwh.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://qjwh.github.io/" accesskey="h" title="CXBlog (Alt + H)">CXBlog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://qjwh.github.io/posts/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://qjwh.github.io/archives/" title="列表">
                    <span>列表</span>
                </a>
            </li>
            <li>
                <a href="https://qjwh.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://qjwh.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      基尔霍夫矩阵
    </h1>
    <div class="post-meta"><span title='2025-02-09 15:28:00 +0800 CST'>February 9, 2025</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#text-stylecolorrgb0150136-0-%e6%b1%82%e5%ae%8c%e5%85%a8%e5%9b%be%e7%9a%84%e7%94%9f%e6%88%90%e6%a0%91%e6%95%b0%e9%87%8fprufer%e5%ba%8f%e5%88%97" aria-label=" 0. 求完全图的生成树数量（Prufer序列）"> 0. 求完全图的生成树数量（Prufer序列）</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-11-%e6%b1%82%e4%bb%bb%e6%84%8f%e6%97%a0%e5%90%91%e5%9b%be%e7%9a%84%e7%94%9f%e6%88%90%e6%a0%91%e6%95%b0%e9%87%8f%e5%9f%ba%e5%b0%94%e9%9c%8d%e5%a4%ab%e7%9f%a9%e9%98%b5" aria-label=" 1.1. 求任意无向图的生成树数量（基尔霍夫矩阵）"> 1.1. 求任意无向图的生成树数量（基尔霍夫矩阵）</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-12-%e6%b1%82%e4%bb%bb%e6%84%8f%e6%97%a0%e5%90%91%e5%b8%a6%e6%9d%83%e5%9b%be%e7%9a%84%e7%94%9f%e6%88%90%e6%a0%91%e6%9d%83%e5%80%bc%e4%b9%8b%e5%92%8c%e5%9f%ba%e5%b0%94%e9%9c%8d%e5%a4%ab%e7%9f%a9%e9%98%b5" aria-label=" 1.2. 求任意无向带权图的生成树权值之和（基尔霍夫矩阵）"> 1.2. 求任意无向带权图的生成树权值之和（基尔霍夫矩阵）</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-211-%e6%b1%82%e4%bb%bb%e6%84%8f%e6%9c%89%e5%90%91%e5%9b%be%e7%9a%84%e7%94%9f%e6%88%90%e5%a4%96%e5%90%91%e6%a0%91%e6%95%b0%e9%87%8f%e5%9f%ba%e5%b0%94%e9%9c%8d%e5%a4%ab%e7%9f%a9%e9%98%b5" aria-label=" 2.1.1. 求任意有向图的生成外向树数量（基尔霍夫矩阵）"> 2.1.1. 求任意有向图的生成外向树数量（基尔霍夫矩阵）</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-212-%e6%b1%82%e4%bb%bb%e6%84%8f%e6%9c%89%e5%90%91%e5%b8%a6%e6%9d%83%e5%9b%be%e7%9a%84%e7%94%9f%e6%88%90%e5%a4%96%e5%90%91%e6%a0%91%e6%9d%83%e5%80%bc%e4%b9%8b%e5%92%8c%e5%9f%ba%e5%b0%94%e9%9c%8d%e5%a4%ab%e7%9f%a9%e9%98%b5" aria-label=" 2.1.2. 求任意有向带权图的生成外向树权值之和（基尔霍夫矩阵）"> 2.1.2. 求任意有向带权图的生成外向树权值之和（基尔霍夫矩阵）</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-221-%e6%b1%82%e4%bb%bb%e6%84%8f%e6%9c%89%e5%90%91%e5%9b%be%e7%9a%84%e7%94%9f%e6%88%90%e5%86%85%e5%90%91%e6%a0%91%e6%95%b0%e9%87%8f%e5%9f%ba%e5%b0%94%e9%9c%8d%e5%a4%ab%e7%9f%a9%e9%98%b5" aria-label=" 2.2.1. 求任意有向图的生成内向树数量（基尔霍夫矩阵）"> 2.2.1. 求任意有向图的生成内向树数量（基尔霍夫矩阵）</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-222-%e6%b1%82%e4%bb%bb%e6%84%8f%e6%9c%89%e5%90%91%e5%b8%a6%e6%9d%83%e5%9b%be%e7%9a%84%e7%94%9f%e6%88%90%e5%86%85%e5%90%91%e6%a0%91%e6%9d%83%e5%80%bc%e4%b9%8b%e5%92%8c%e5%9f%ba%e5%b0%94%e9%9c%8d%e5%a4%ab%e7%9f%a9%e9%98%b5" aria-label=" 2.2.2. 求任意有向带权图的生成内向树权值之和（基尔霍夫矩阵）"> 2.2.2. 求任意有向带权图的生成内向树权值之和（基尔霍夫矩阵）</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-3-%e6%b1%82%e5%ae%8c%e5%85%a8%e4%ba%8c%e5%88%86%e5%9b%be%e7%9a%84%e7%94%9f%e6%88%90%e6%a0%91%e4%b8%aa%e6%95%b0%e5%9f%ba%e5%b0%94%e9%9c%8d%e5%a4%ab%e7%9f%a9%e9%98%b5%e6%8b%93%e5%b1%95" aria-label=" 3. 求完全二分图的生成树个数（基尔霍夫矩阵拓展）"> 3. 求完全二分图的生成树个数（基尔霍夫矩阵拓展）</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>基尔霍夫矩阵是用来求解生成树计数、求（权值）和相关题目的利器。</p>
<hr>
<h3 id="text-stylecolorrgb0150136-0-求完全图的生成树数量prufer序列"><text style="color:rgb(0,150,136)"> 0. 求完全图的生成树数量（Prufer序列）<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-0-求完全图的生成树数量prufer序列">#</a></h3>
<p>要说基尔霍夫矩阵，就要从一道题目说起：</p>
<blockquote>
<p>给你 $n$，问 $n$ 个节点组成的无向无根树有多少种。</p></blockquote>
<p>这道题可以用Prufer序列去做。</p>
<p>这里简单说一下Prufer序列的求法：</p>
<blockquote>
<p>对于一张无向无根树，重复执行以下操作直到只剩 $2$ 个或更少的点，最后得到的那个序列 $a$ 就是这棵树的Prufer序列：</p>
<ul>
<li>我们找到此时度为 $1$ 的节点，若有多个，找编号最小的，设找到的节点编号为 $x$。</li>
<li>在 $a$ 的末尾添加：与 $x$ 有连边的那个唯一节点。</li>
<li>删除 $x$。</li>
</ul></blockquote>
<p>Prufer序列别看求法非常简单，也没啥容易发现的性质，其实用处很大。</p>
<p>Prufer序列满足一个性质，就是，所有无向无根树，都可以唯一地对应一个Prufer序列；所有Prufer序列都可以唯一地对应一棵树。</p>
<p>所以，这道题就有解了，答案其实就是长为 $n-2$ 的Prufer序列有多少种。</p>
<p>由于Prufer序列的每个元素的值都是从 $1$ 到 $n$ 的，所以答案就是 $n^{n-2}$，显然。</p>
<hr>
<h3 id="text-stylecolorrgb0150136-11-求任意无向图的生成树数量基尔霍夫矩阵"><text style="color:rgb(0,150,136)"> 1.1. 求任意无向图的生成树数量（基尔霍夫矩阵）<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-11-求任意无向图的生成树数量基尔霍夫矩阵">#</a></h3>
<p>但如果把题目变化一下，就不能用Prufer序列去求了：</p>
<blockquote>
<p>给你一张 $n$ 个节点 $m$ 条边的无向图，问这张图的生成树有多少个。</p></blockquote>
<p>这题要用基尔霍夫矩阵。</p>
<p>具体地，我们定义 $D$ 矩阵，求法：</p>
<p>$
D_{i,j}=
\begin{cases}
0 &amp; i \not= j \
\text{deg}(i) &amp; i=j
\end{cases}
$</p>
<p>其中，$\text{deg}(i)$ 代表这张图上 $i$ 的度是多少。</p>
<p>我们再定义 $A$ 矩阵，求法：</p>
<p>$
A_{i,j}=
\begin{cases}
\text{ecnt}(i,j) &amp; i \not= j \
0 &amp; i=j
\end{cases}
$</p>
<p>其中，$\text{ecnt}(i,j)$ 代表这张图上点 $i$ 和点 $j$ 之间的边数。</p>
<p>然后，我们再定义基尔霍夫矩阵 $K=D-A$，即：</p>
<p>$
K_{i,j}=
\begin{cases}
-\text{ecnt}(i,j) &amp; i \not= j \
\text{deg}(i) &amp; i=j
\end{cases}
$</p>
<p>最后，我们同时删掉 $K$ 中的一行和一列（一般是删掉最后一行和最后一列，但删掉哪一行、哪一列答案都不变），此时 $K$ 的行列式即为本题答案。</p>
<p>（以下所有 $D$、$A$、$K$ 的求法都是一样的，答案求法也是一样的，所以只说 $\text{deg}$ 函数和 $\text{ecnt}$ 函数的求法）</p>
<blockquote>
<text style="color:orangered">
<p>*注：</p>
<p>如果是有向图生成树相关题目，且题目指定了根，那么<strong>删除的那一行和那一列的编号，必须是根节点的编号</strong>。</p>
<p>如，题目要求 $1$ 节点为根，那么删除的必须要是第一行和第一列，否则会WA。</p>
<hr>
<p>此外，以下所有题里，在求 $\text{deg}$ 函数和 $\text{ecnt}$ 函数时，都要<strong>忽略自环</strong>。</p>
<hr>
<p>并且，<strong>如果说下面构造的方阵没有行列式，那么就说明没有生成树</strong>，要输出 $0$。</p>
</text></blockquote>
<hr>
<h3 id="text-stylecolorrgb0150136-12-求任意无向带权图的生成树权值之和基尔霍夫矩阵"><text style="color:rgb(0,150,136)"> 1.2. 求任意无向带权图的生成树权值之和（基尔霍夫矩阵）<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-12-求任意无向带权图的生成树权值之和基尔霍夫矩阵">#</a></h3>
<p>这题还有变种：</p>
<blockquote>
<p>给你一张 $n$ 个节点 $m$ 条边的无向带权图，问这张图所有生成树的权值之和。</p>
<p>一棵生成树的权值定义为这棵生成树内所有边权之和。</p></blockquote>
<p>$\text{deg}(i)$ 代表这张图上 $i$ 的所有出边的边权之和，$\text{ecnt}(i,j)$ 代表这张图上点 $i$ 和点 $j$ 之间所有边的边权和。</p>
<hr>
<h3 id="text-stylecolorrgb0150136-211-求任意有向图的生成外向树数量基尔霍夫矩阵"><text style="color:rgb(0,150,136)"> 2.1.1. 求任意有向图的生成外向树数量（基尔霍夫矩阵）<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-211-求任意有向图的生成外向树数量基尔霍夫矩阵">#</a></h3>
<p>但还没完，还有题目：</p>
<blockquote>
<p>给你一张 $n$ 个节点 $m$ 条边的有向图，问这张图的生成树有多少个。</p>
<p>此处，生成树要求是外向树。</p>
<p>所谓外向树，就是一棵有向树，满足每条边都是从父亲指向儿子的。</p></blockquote>
<p>$\text{deg}(i)$ 代表这张图上 $i$ 的入度，$\text{ecnt}(i,j)$ 代表这张图上从点 $i$ 连向点 $j$ 的边的数量。</p>
<hr>
<h3 id="text-stylecolorrgb0150136-212-求任意有向带权图的生成外向树权值之和基尔霍夫矩阵"><text style="color:rgb(0,150,136)"> 2.1.2. 求任意有向带权图的生成外向树权值之和（基尔霍夫矩阵）<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-212-求任意有向带权图的生成外向树权值之和基尔霍夫矩阵">#</a></h3>
<p>但还没完，还有题目：</p>
<blockquote>
<p>给你一张 $n$ 个节点 $m$ 条边的有向带权图，问这张图的生成树的权值之和。</p>
<p>此处，生成树要求是外向树。</p></blockquote>
<p>$\text{deg}(i)$ 代表这张图内连向 $i$ 的边权之和，$\text{ecnt}(i,j)$ 代表这张图上从点 $i$ 连向点 $j$ 的边权之和。</p>
<hr>
<h3 id="text-stylecolorrgb0150136-221-求任意有向图的生成内向树数量基尔霍夫矩阵"><text style="color:rgb(0,150,136)"> 2.2.1. 求任意有向图的生成内向树数量（基尔霍夫矩阵）<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-221-求任意有向图的生成内向树数量基尔霍夫矩阵">#</a></h3>
<p>但还没完，还有题目：</p>
<blockquote>
<p>给你一张 $n$ 个节点 $m$ 条边的有向图，问这张图的生成树有多少个。</p>
<p>此处，生成树要求是内向树。</p>
<p>所谓内向树，就是一棵有向树，满足每条边都是从儿子指向父亲的。</p></blockquote>
<p>$\text{deg}(i)$ 代表这张图上 $i$ 的出度，$\text{ecnt}(i,j)$ 代表这张图上从点 $i$ 连向点 $j$ 的边的数量。</p>
<hr>
<h3 id="text-stylecolorrgb0150136-222-求任意有向带权图的生成内向树权值之和基尔霍夫矩阵"><text style="color:rgb(0,150,136)"> 2.2.2. 求任意有向带权图的生成内向树权值之和（基尔霍夫矩阵）<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-222-求任意有向带权图的生成内向树权值之和基尔霍夫矩阵">#</a></h3>
<p>但还没完，还有题目：</p>
<blockquote>
<p>给你一张 $n$ 个节点 $m$ 条边的有向带权图，问这张图的生成树的权值之和。</p>
<p>此处，生成树要求是内向树。</p></blockquote>
<p>$\text{deg}(i)$ 代表这张图内 $i$ 的出边边权之和，$\text{ecnt}(i,j)$ 代表这张图上从点 $i$ 连向点 $j$ 的边权之和。</p>
<hr>
<h3 id="text-stylecolorrgb0150136-3-求完全二分图的生成树个数基尔霍夫矩阵拓展"><text style="color:rgb(0,150,136)"> 3. 求完全二分图的生成树个数（基尔霍夫矩阵拓展）<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-3-求完全二分图的生成树个数基尔霍夫矩阵拓展">#</a></h3>
<p>但还没完，还有题目：</p>
<blockquote>
<p>给你两个数 $n$、$m$，问左边 $n$ 个点，右边 $m$ 个点的完全二分图的生成树个数。</p></blockquote>
<p>这个问题可以被转化为问题1.1，所以我们就可以得到基尔霍夫矩阵：</p>
<p>$
\begin{bmatrix}
m &amp; 0 &amp; \cdots &amp; 0 &amp; -1 &amp; -1 &amp; \cdots &amp; -1 \
0 &amp; m &amp; \cdots &amp; 0 &amp; -1 &amp; -1 &amp; \cdots &amp; -1 \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \
0 &amp; 0 &amp; \cdots &amp; m &amp; -1 &amp; -1 &amp; \cdots &amp; -1 \
-1 &amp; -1 &amp; \cdots &amp; -1 &amp; n &amp; 0 &amp; \cdots &amp; 0 \
-1 &amp; -1 &amp; \cdots &amp; -1 &amp; 0 &amp; n &amp; \cdots &amp; 0 \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \
-1 &amp; -1 &amp; \cdots &amp; -1 &amp; 0 &amp; 0 &amp; \cdots &amp; n \
\end{bmatrix}
$</p>
<p>标一些参数：</p>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/p3q3rf8y.png" width="50%">
<p>（图1）</p>
<p>然后，可以发现，在上面的划分方案中，左上部分和右下部分其实都是方阵，所以我们只要让左下部分全部变为 $0$ 就可以用行列式性质转化问题了。</p>
<p>进而，既然求这个矩阵的行列式，我们就先把最后一行和最后一列去掉，即把图1的参数内的两个 $m$ 改成 $m-1$。</p>
<p>我们既然要把左下部分变成 $0$，我们就要变化矩阵。</p>
<p>我们首先把矩阵前 $n$ 行全部除以 $m$，得到：</p>
<p>$
\large
\begin{bmatrix}
1 &amp; 0 &amp; \cdots &amp; 0 &amp; \frac{-1}{m} &amp; \frac{-1}{m} &amp; \cdots &amp; \frac{-1}{m} \
0 &amp; 1 &amp; \cdots &amp; 0 &amp; \frac{-1}{m} &amp; \frac{-1}{m} &amp; \cdots &amp; \frac{-1}{m} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \
0 &amp; 0 &amp; \cdots &amp; 1 &amp; \frac{-1}{m} &amp; \frac{-1}{m} &amp; \cdots &amp; \frac{-1}{m} \
-1 &amp; -1 &amp; \cdots &amp; -1 &amp; n &amp; 0 &amp; \cdots &amp; 0 \
-1 &amp; -1 &amp; \cdots &amp; -1 &amp; 0 &amp; n &amp; \cdots &amp; 0 \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \
-1 &amp; -1 &amp; \cdots &amp; -1 &amp; 0 &amp; 0 &amp; \cdots &amp; n \
\end{bmatrix}
$</p>
<p>其次，算出前 $n$ 行矩阵之和：</p>
<p>$
\large
\begin{bmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 &amp; \frac{-n}{m} &amp; \frac{-n}{m} &amp; \cdots &amp; \frac{-n}{m}
\end{bmatrix}
$</p>
<p>然后，对于后 $m-1$ 行，每一行都加上前 $n$ 行之和：</p>
<p>$
\large
\begin{bmatrix}
1 &amp; 0 &amp; \cdots &amp; 0 &amp; \frac{-1}{m} &amp; \frac{-1}{m} &amp; \cdots &amp; \frac{-1}{m} \
0 &amp; 1 &amp; \cdots &amp; 0 &amp; \frac{-1}{m} &amp; \frac{-1}{m} &amp; \cdots &amp; \frac{-1}{m} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \
0 &amp; 0 &amp; \cdots &amp; 1 &amp; \frac{-1}{m} &amp; \frac{-1}{m} &amp; \cdots &amp; \frac{-1}{m} \
0 &amp; 0 &amp; \cdots &amp; 0 &amp; n-\frac{n}{m} &amp; -\frac{n}{m} &amp; \cdots &amp; -\frac{n}{m} \
0 &amp; 0 &amp; \cdots &amp; 0 &amp; -\frac{n}{m} &amp; n-\frac{n}{m} &amp; \cdots &amp; -\frac{n}{m} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \
0 &amp; 0 &amp; \cdots &amp; 0 &amp; -\frac{n}{m} &amp; -\frac{n}{m} &amp; \cdots &amp; n-\frac{n}{m} \
\end{bmatrix}
$</p>
<p>最后，把前 $n$ 行重新都乘上 $m$：</p>
<p>$
\large
\begin{bmatrix}
m &amp; 0 &amp; \cdots &amp; 0 &amp; -1 &amp; -1 &amp; \cdots &amp; -1 \
0 &amp; m &amp; \cdots &amp; 0 &amp; -1 &amp; -1 &amp; \cdots &amp; -1 \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \
0 &amp; 0 &amp; \cdots &amp; m &amp; -1 &amp; -1 &amp; \cdots &amp; -1 \
0 &amp; 0 &amp; \cdots &amp; 0 &amp; n-\frac{n}{m} &amp; -\frac{n}{m} &amp; \cdots &amp; -\frac{n}{m} \
0 &amp; 0 &amp; \cdots &amp; 0 &amp; -\frac{n}{m} &amp; n-\frac{n}{m} &amp; \cdots &amp; -\frac{n}{m} \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \
0 &amp; 0 &amp; \cdots &amp; 0 &amp; -\frac{n}{m} &amp; -\frac{n}{m} &amp; \cdots &amp; n-\frac{n}{m} \
\end{bmatrix}
$</p>
<p>此时左下角都是 $0$ 了。</p>
<p>于是乎，问题就转化为了以下两个矩阵的行列式之积：</p>
<p>$
D_1=
\large
\begin{bmatrix}
m &amp; 0 &amp; \cdots &amp; 0 \
0 &amp; m &amp; \cdots &amp; 0 \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
0 &amp; 0 &amp; \cdots &amp; m
\end{bmatrix}
$</p>
<p>$
D_2=
\large
\begin{bmatrix}
n-\frac{n}{m} &amp; -\frac{n}{m} &amp; \cdots &amp; -\frac{n}{m} \\
-\frac{n}{m} &amp; n-\frac{n}{m} &amp; \cdots &amp; -\frac{n}{m} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
-\frac{n}{m} &amp; -\frac{n}{m} &amp; \cdots &amp; n-\frac{n}{m}
\end{bmatrix}
$</p>
<p>（注意，$D_2$ 是个 $(m-1) \times (m-1)$ 的矩阵，而不是 $m \times m$ 的）</p>
<p>$D_1$ 由于本身就是上三角矩阵，根据行列式性质，$\det D_1=m^n$。</p>
<p>但 $D_2$ 并不是，所以还要转化。</p>
<p>（以下都针对 $D_2$ 矩阵进行转化）</p>
<p>我们首先求出这 $m-1$ 行的和：</p>
<p>$
\begin{bmatrix}
n-(m-1) \times \frac{n}{m} &amp; n-(m-1) \times \frac{n}{m} &amp; \cdots &amp; n-(m-1) \times \frac{n}{m}
\end{bmatrix}
$</p>
<p>其次把上述矩阵直接替换到第一行：</p>
<p>$
\begin{bmatrix}
n-(m-1) \times \frac{n}{m} &amp; n-(m-1) \times \frac{n}{m} &amp; \cdots &amp; n-(m-1) \times \frac{n}{m} \\
-\frac{n}{m} &amp; n-\frac{n}{m} &amp; \cdots &amp; -\frac{n}{m} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
-\frac{n}{m} &amp; -\frac{n}{m} &amp; \cdots &amp; n-\frac{n}{m}
\end{bmatrix}
$</p>
<p>发现第一行都是一样的，所以我们就把第一行统一除以 $n-(m-1) \times \frac{n}{m}$，行列式也除以了 $n-(m-1) \times \frac{n}{m}$，所以 $D_2$ 的行列式其实是下述矩阵的行列式<strong>乘上</strong> $n-(m-1) \times \frac{n}{m}$：</p>
<p>$
T=
\begin{bmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \\
-\frac{n}{m} &amp; n-\frac{n}{m} &amp; \cdots &amp; -\frac{n}{m} \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
-\frac{n}{m} &amp; -\frac{n}{m} &amp; \cdots &amp; n-\frac{n}{m}
\end{bmatrix}
$</p>
<p>（以下暂时换为针对 $T$ 矩阵进行转化）</p>
<p>我们把第一行全部乘上 $\frac{m}{n}$，然后加到下面每一行：（即把下面每一行内的 $-\frac{n}{m}$ 都删掉）</p>
<p>$
\begin{bmatrix}
1 &amp; 1 &amp; \cdots &amp; 1 \
0 &amp; n &amp; \cdots &amp; 0 \
\vdots &amp; \vdots &amp; \ddots &amp; \vdots \
0 &amp; 0 &amp; \cdots &amp; n
\end{bmatrix}
$</p>
<p>此时就是个上三角矩阵了，这个矩阵的行列式 $\det T=n^{m-2}$，显然。</p>
<p>但 $\det D_2=(n-(m-1) \times \frac{n}{m}) \times (\det T)$，所以我们转化一下式子：</p>
<blockquote>
<p>（以下省略 $\det D_2=$）</p>
<p>带入 $\det T$：</p>
<p>$(n-(m-1) \times \frac{n}{m}) \times n^{m-2}$</p>
<p>拆括号：</p>
<p>$n \times n^{m-2}-(m-1) \times \frac{n}{m} \times n^{m-2}$</p>
<p>简化式子：</p>
<p>$n^{m-1}-(m-1) \times \frac{n}{m} \times n^{m-2}$</p>
<p>拆开分数：</p>
<p>$n^{m-1}-(m-1) \times \frac{1}{m} \times n \times n^{m-2}$</p>
<p>即：</p>
<p>$n^{m-1}-(m-1) \times \frac{1}{m} \times n^{m-1}$</p>
<p>拆括号：</p>
<p>$n^{m-1}-(m \times \frac{1}{m}-\frac{1}{m}) \times n^{m-1}$</p>
<p>即：</p>
<p>$n^{m-1}-(1-\frac{1}{m}) \times n^{m-1}$</p>
<p>拆括号：</p>
<p>$n^{m-1}-(n^{m-1}-\frac{1}{m} \times n^{m-1})$</p>
<p>拆括号：</p>
<p>$n^{m-1}-n^{m-1}+\frac{1}{m} \times n^{m-1}$</p>
<p>即：</p>
<p>$\frac{1}{m} \times n^{m-1}$</p></blockquote>
<p>但还没完，答案是 $(\det D_1) \times (\det D_2)$，所以需要推导一下：</p>
<blockquote>
<p>带入：</p>
<p>$(m^n) \times (\frac{1}{m} \times n^{m-1})$</p>
<p>拆括号：</p>
<p>$m^n \times \frac{1}{m} \times n^{m-1}$</p>
<p>即：</p>
<p>$m^{n-1} \times n^{m-1}$</p></blockquote>
<p>所以其实这题的代码很短，只用算 $m^{n-1} \times n^{m-1}$ 的值即可。</p>
<blockquote>
<p>*注：这道题原题是M2733，另一种用Prufer序列证明这个答案的方法见本题写的题解，在题解文件夹内。</p></blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://qjwh.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/">信息学竞赛</a></li>
      <li><a href="https://qjwh.github.io/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">算法学习笔记</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://qjwh.github.io/">CXBlog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
