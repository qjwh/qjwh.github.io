<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>网络流 | CXBlog</title>
<meta name="keywords" content="信息学竞赛, 算法学习笔记">
<meta name="description" content="
 前言
首先，网络流不是一个算法，而是一个整合包（玩MC玩的），说白了就是网络流是多个算法的统称：

最大流

EK
Dinic


最小割
费用流
&hellip;

而且，有些不常用的，可能就不会提，粘个OI Wiki的链接就不详细写了。
接下来就按照这个目录挨个讲一下每个算法。
 最大流

如果有哪里没有说清楚，可以看这里，里面还有我没有说到的最大流类型。
看到最大流这个名字很多人都很陌生，这里就先从定义说起。
 定义
还是拆词法，“网络流”就可以大致理解为“网络”上的“流”，接下来就挨个说一下这两个的定义。
 网络
先说网络的定义。（当然不是Internet）
我们在理解的时候可以认为是管道，但实际上它是一张特殊的有向图。
建设管道的必然知道，管道内流过的水，准确来说是单位时间内流过的水，必然是有上限限制的，否则管道就炸了。
这里也一样，对于每条边 $x \to y$，都有一个函数 $c(x,y)$ 表示这条边的限制，又称容量。
如果在图上没有这条边，则统一规定 $c(x,y)=0$。
最后，还是跟最短路一样，它有一个起点和一个终点，又称源点 $S$ 和汇点 $T$（$S \not= T$）。
 流函数
再说流函数。
流函数就是说，在真实操作中，一个单位时间内一条边 $x \to y$ 流过的水量 $f(x,y)$。
这里默认保证每个单位时间内都得流过这么多。
其实很好理解。
 流函数性质
顺便说一下流函数要满足的性质。
首先，源点可以无限输出水，汇点可以无限输入水。
接下来就是一堆性质：

对于每个 $x,y$，显然 $f(x,y) \leq c(x,y)$（容量限制）。
对于每个 $x,y$，$f(x,y)=-f(y,x)$（斜对称）。
对于每个 $x$，满足不是源点也不是汇点，$\sum\limits_{u \to x} f(u,x)=\sum\limits_{x \to v} f(x,v)$（流量守恒）。

这里说一下最后一点性质。">
<meta name="author" content="">
<link rel="canonical" href="https://qjwh.github.io/posts/aln/flow/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3b2e5c86d6776f1230a6cc3dbc6bde31467e6a5f6513337e196964b4e3693a57.css" integrity="sha256-Oy5chtZ3bxIwpsw9vGveMUZ&#43;al9lEzN&#43;GWlktONpOlc=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://qjwh.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://qjwh.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://qjwh.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://qjwh.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://qjwh.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://qjwh.github.io/posts/aln/flow/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script src="https://unpkg.com/feather-icons"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {
      
      
      delimiters: [
        {left: '$$', right: '$$', display: true},
        {left: '$', right: '$', display: false},
      ],
      
      throwOnError : false
    });
  });
</script>

<style>
    @font-face { 
        font-family: 'Ubuntu';
        src: url('/UbuntuB.ttf');
    }
    body {
        
        font-family: 'Ubuntu';
    }
</style><meta property="og:url" content="https://qjwh.github.io/posts/aln/flow/">
  <meta property="og:site_name" content="CXBlog">
  <meta property="og:title" content="网络流">
  <meta property="og:description" content="前言 首先，网络流不是一个算法，而是一个整合包（玩MC玩的），说白了就是网络流是多个算法的统称：
最大流 EK Dinic 最小割 费用流 … 而且，有些不常用的，可能就不会提，粘个OI Wiki的链接就不详细写了。
接下来就按照这个目录挨个讲一下每个算法。
最大流 如果有哪里没有说清楚，可以看这里，里面还有我没有说到的最大流类型。
看到最大流这个名字很多人都很陌生，这里就先从定义说起。
定义 还是拆词法，“网络流”就可以大致理解为“网络”上的“流”，接下来就挨个说一下这两个的定义。
网络 先说网络的定义。（当然不是Internet）
我们在理解的时候可以认为是管道，但实际上它是一张特殊的有向图。
建设管道的必然知道，管道内流过的水，准确来说是单位时间内流过的水，必然是有上限限制的，否则管道就炸了。
这里也一样，对于每条边 $x \to y$，都有一个函数 $c(x,y)$ 表示这条边的限制，又称容量。
如果在图上没有这条边，则统一规定 $c(x,y)=0$。
最后，还是跟最短路一样，它有一个起点和一个终点，又称源点 $S$ 和汇点 $T$（$S \not= T$）。
流函数 再说流函数。
流函数就是说，在真实操作中，一个单位时间内一条边 $x \to y$ 流过的水量 $f(x,y)$。
这里默认保证每个单位时间内都得流过这么多。
其实很好理解。
流函数性质 顺便说一下流函数要满足的性质。
首先，源点可以无限输出水，汇点可以无限输入水。
接下来就是一堆性质：
对于每个 $x,y$，显然 $f(x,y) \leq c(x,y)$（容量限制）。 对于每个 $x,y$，$f(x,y)=-f(y,x)$（斜对称）。 对于每个 $x$，满足不是源点也不是汇点，$\sum\limits_{u \to x} f(u,x)=\sum\limits_{x \to v} f(x,v)$（流量守恒）。 这里说一下最后一点性质。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-02-09T15:28:00+08:00">
    <meta property="article:modified_time" content="2025-02-09T15:28:00+08:00">
    <meta property="article:tag" content="信息学竞赛">
    <meta property="article:tag" content="算法学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="网络流">
<meta name="twitter:description" content="
 前言
首先，网络流不是一个算法，而是一个整合包（玩MC玩的），说白了就是网络流是多个算法的统称：

最大流

EK
Dinic


最小割
费用流
&hellip;

而且，有些不常用的，可能就不会提，粘个OI Wiki的链接就不详细写了。
接下来就按照这个目录挨个讲一下每个算法。
 最大流

如果有哪里没有说清楚，可以看这里，里面还有我没有说到的最大流类型。
看到最大流这个名字很多人都很陌生，这里就先从定义说起。
 定义
还是拆词法，“网络流”就可以大致理解为“网络”上的“流”，接下来就挨个说一下这两个的定义。
 网络
先说网络的定义。（当然不是Internet）
我们在理解的时候可以认为是管道，但实际上它是一张特殊的有向图。
建设管道的必然知道，管道内流过的水，准确来说是单位时间内流过的水，必然是有上限限制的，否则管道就炸了。
这里也一样，对于每条边 $x \to y$，都有一个函数 $c(x,y)$ 表示这条边的限制，又称容量。
如果在图上没有这条边，则统一规定 $c(x,y)=0$。
最后，还是跟最短路一样，它有一个起点和一个终点，又称源点 $S$ 和汇点 $T$（$S \not= T$）。
 流函数
再说流函数。
流函数就是说，在真实操作中，一个单位时间内一条边 $x \to y$ 流过的水量 $f(x,y)$。
这里默认保证每个单位时间内都得流过这么多。
其实很好理解。
 流函数性质
顺便说一下流函数要满足的性质。
首先，源点可以无限输出水，汇点可以无限输入水。
接下来就是一堆性质：

对于每个 $x,y$，显然 $f(x,y) \leq c(x,y)$（容量限制）。
对于每个 $x,y$，$f(x,y)=-f(y,x)$（斜对称）。
对于每个 $x$，满足不是源点也不是汇点，$\sum\limits_{u \to x} f(u,x)=\sum\limits_{x \to v} f(x,v)$（流量守恒）。

这里说一下最后一点性质。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://qjwh.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "网络流",
      "item": "https://qjwh.github.io/posts/aln/flow/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "网络流",
  "name": "网络流",
  "description": "\r前言 首先，网络流不是一个算法，而是一个整合包（玩MC玩的），说白了就是网络流是多个算法的统称：\n最大流 EK Dinic 最小割 费用流 \u0026hellip; 而且，有些不常用的，可能就不会提，粘个OI Wiki的链接就不详细写了。\n接下来就按照这个目录挨个讲一下每个算法。\n最大流 如果有哪里没有说清楚，可以看这里，里面还有我没有说到的最大流类型。\n看到最大流这个名字很多人都很陌生，这里就先从定义说起。\n定义 还是拆词法，“网络流”就可以大致理解为“网络”上的“流”，接下来就挨个说一下这两个的定义。\n网络 先说网络的定义。（当然不是Internet）\n我们在理解的时候可以认为是管道，但实际上它是一张特殊的有向图。\n建设管道的必然知道，管道内流过的水，准确来说是单位时间内流过的水，必然是有上限限制的，否则管道就炸了。\n这里也一样，对于每条边 $x \\to y$，都有一个函数 $c(x,y)$ 表示这条边的限制，又称容量。\n如果在图上没有这条边，则统一规定 $c(x,y)=0$。\n最后，还是跟最短路一样，它有一个起点和一个终点，又称源点 $S$ 和汇点 $T$（$S \\not= T$）。\n流函数 再说流函数。\n流函数就是说，在真实操作中，一个单位时间内一条边 $x \\to y$ 流过的水量 $f(x,y)$。\n这里默认保证每个单位时间内都得流过这么多。\n其实很好理解。\n流函数性质 顺便说一下流函数要满足的性质。\n首先，源点可以无限输出水，汇点可以无限输入水。\n接下来就是一堆性质：\n对于每个 $x,y$，显然 $f(x,y) \\leq c(x,y)$（容量限制）。 对于每个 $x,y$，$f(x,y)=-f(y,x)$（斜对称）。 对于每个 $x$，满足不是源点也不是汇点，$\\sum\\limits_{u \\to x} f(u,x)=\\sum\\limits_{x \\to v} f(x,v)$（流量守恒）。 这里说一下最后一点性质。\n",
  "keywords": [
    "信息学竞赛", "算法学习笔记"
  ],
  "articleBody": "\r前言 首先，网络流不是一个算法，而是一个整合包（玩MC玩的），说白了就是网络流是多个算法的统称：\n最大流 EK Dinic 最小割 费用流 … 而且，有些不常用的，可能就不会提，粘个OI Wiki的链接就不详细写了。\n接下来就按照这个目录挨个讲一下每个算法。\n最大流 如果有哪里没有说清楚，可以看这里，里面还有我没有说到的最大流类型。\n看到最大流这个名字很多人都很陌生，这里就先从定义说起。\n定义 还是拆词法，“网络流”就可以大致理解为“网络”上的“流”，接下来就挨个说一下这两个的定义。\n网络 先说网络的定义。（当然不是Internet）\n我们在理解的时候可以认为是管道，但实际上它是一张特殊的有向图。\n建设管道的必然知道，管道内流过的水，准确来说是单位时间内流过的水，必然是有上限限制的，否则管道就炸了。\n这里也一样，对于每条边 $x \\to y$，都有一个函数 $c(x,y)$ 表示这条边的限制，又称容量。\n如果在图上没有这条边，则统一规定 $c(x,y)=0$。\n最后，还是跟最短路一样，它有一个起点和一个终点，又称源点 $S$ 和汇点 $T$（$S \\not= T$）。\n流函数 再说流函数。\n流函数就是说，在真实操作中，一个单位时间内一条边 $x \\to y$ 流过的水量 $f(x,y)$。\n这里默认保证每个单位时间内都得流过这么多。\n其实很好理解。\n流函数性质 顺便说一下流函数要满足的性质。\n首先，源点可以无限输出水，汇点可以无限输入水。\n接下来就是一堆性质：\n对于每个 $x,y$，显然 $f(x,y) \\leq c(x,y)$（容量限制）。 对于每个 $x,y$，$f(x,y)=-f(y,x)$（斜对称）。 对于每个 $x$，满足不是源点也不是汇点，$\\sum\\limits_{u \\to x} f(u,x)=\\sum\\limits_{x \\to v} f(x,v)$（流量守恒）。 这里说一下最后一点性质。\n首先，$u \\to x$ 即代表对于每个 $u$ 满足 $u$ 到 $x$ 有边，$x \\to v$ 同理。\n其次，这个翻译过来就是说，对于不是源点不是汇点的任何点，它们都不会凭空产生水，也不会让水凭空消失。\n而源点和汇点呢？源点就没有入，凭空产生水；汇点就没有出，让水凭空消失。\n容易理解\n流量 说到流，那必定要提流量。（当然不是你们家的网络流量）\n其实流量就是上面说的“流过的水量”，说白了就是 $f(x,y)$。\n这里说一下一个细节，$f$ 是流函数，$f(x,y)$ 是该边的流量。\n同时，还有一个反面定义，就是 $c(x,y)-f(x,y)$ 为该边的剩余容量。\n（注意上面两个加粗题的表达）\n但这只是一条边的流量，如果扩展到一张图，根据流量守恒，直接看源点输出了多少水，就是整张图的流量。\n也即汇点输入的水量。\n最大流 最后再说最大流的定义。\n这里说一下，最大流其实是一个函数，就是流函数。\n而与它仅差一个字的最大流量，才是一个数值，即最大流对应方案的流量。\n（不过似乎没有很多人会在乎这两个定义的差别，底下的所谓“求最大流”的算法，应该是“求最大流量”）\n说完这个后，顾名思义就能猜到定义了。\n就是合法的流函数有很多，使得整张图的流量最大的流函数，就是最大流。\nEK（Edmonds Karp） 说完定义，接下来就从最基础的EK算法说起。\n这个算法复杂度很高（至少相对Dinic而言），但它确实是所有网络流算法的基础。\n因为Dinic就是从EK上优化的，最小割、费用流都是以Dinic为基础的。\n接下来先讲实现，再讲原理。\n不过一般没人写EK。\n实现 而且，其实EK和二分图（匈牙利算法）很像，都是求增广路。\n说白了，就是当前解不优，找一个更优的。\n其本质就是反悔贪心。\n而此处的增广其实是这么实现的：\n先建图，带权，同时建一个反向的、边权为 $0$ 的边。 即对于原图中的一条边 $(u \\to v, w)$，建两条边： $(u \\to v,w)$ $(v \\to u,0)$ 注意一下，不要对这里的反向边有“种族歧视”，就把反向边当做是普通的边，人人平等（ 然后，不断做这件事： 从源点开始BFS，中途记录一下当前所有经过的边的边权最小值。 如果BFS到了汇点，答案加上最小值 $val$。 同时对于每条经过的边： 让这条边的边权减去 $val$。 让它反向边边权加上 $val$。 直到从源点开始，无论如何都得经过一条边权为 $0$ 的边才能到汇点为止。 因为如果经过一条边权为 $0$ 的边，此时就不用往下搜了。 最后，直接输出答案，即所有最小值之和即可。 接下来说原理。\n原理 首先，说一下加反向边的大致意思。\n其实就是说，你在反向边上流过 $v$ 的水，就相当于让这条边少流 $v$ 的水。\n其次，说一下BFS这部分的原理。\n还是举具体的例子。\n在这张图里，我们模拟一下，首先一定找的是 $1 \\to 2 \\to 3 \\to 4$ 这条路径。\n随后把反向边更新。\n（注：在边上面，黑色的是原本边的边权；在边下面，红色的是反向边的边权）\n接下来增广的是 $1 \\to 5 \\to 3 \\to 2 \\to 6 \\to 4$ 这条路径。\n此时已经无法继续增广。\n所以最终答案为 $2+2=4$。\n而怎么理解呢？其实只是这个返回的机制很独特而已。\n我先BFS到 $1 \\to 5 \\to 3$，然后把最开始的路径 $3 \\to 4$ 部分拼走了。\n此时最开始的路径中的 $1 \\to 2$ 开始重新寻路，就把增广路径中的 $2 \\to 6 \\to 4$ 拼走了。\n所以最后是两条路径：\n$1 \\to 5 \\to 3 \\to 4$ $1 \\to 2 \\to 6 \\to 4$ 答案为 $4$。\n复杂度 $O(nm^2)$\n其中 $n$ 为点数，$m$ 为边数。\n证明之后补\n网上的证明\nDinic 接下来就是重头戏了，就是Dinic算法。\n这个算法相比而言，复杂度就小了很多。\n并且，在求二分图最大匹配方面，比匈牙利算法跑得更快。\n这次跟上面反过来，先说原理再说实现。\n原理 首先，我们考虑一下EK算法为何复杂度如此之大。\n其实就是因为，它每次都得进行BFS，每次都从源点开始搜到汇点。\n但做了这么多功，不还是只能搜一条增广路吗。\n这就导致花的时间很多，但得到的收益很少。\n所以我们就对症下药。\n也就是我们可以一次搜多条最短路。\n不过准确来说，我们是不一定每次都从源点开始，就像遍历一棵树一样，每次都从当前点开始搜。\n这样的话复杂度就能剩很多。\n实现 原理很好解释清楚，但实现其实细节很多。\n这会虽然也用BFS，但实际上上面已经透露了，Dinic的核心在于DFS，所以BFS只求最短路。\n具体来说，我们是这样实现的：\n只要图还连通，就从源点开始做一遍BFS，求出现在源点到每个点 $i$ 的距离 $dis_i$。 此时就不断做DFS，并进行增广，直到不能增广为止。 一次DFS的返回值是多次增广的结果之和。 将答案加上返回值。 说一下，连通的意思是存在一条路径从源点到汇点且不经过边权为 $0$ 的边；同理，边权为 $0$ 的边是不可经过的。\n接下来就是重头戏了，就是DFS的具体实现。\n首先，上面EK算法里，由于用BFS实现，所以每次增广都是走的当前的最短路。\n显然这也是最优的。\n那在这里，我们也得保证一定要最短。\n咋做呢？我们不是BFS出了距离 $dis_i$ 吗？我们干脆在DFS的时候只遍历最短路图即可。\n即对于一个点 $x$，只遍历满足 $dis_{to}=dis_x+1$ 的出点 $to$。\n还是跟之前差不多（至少有点雷同的思想），直接放实现：\nDFS传入两个参数，一个是当前点 $x$，一个是流到点 $x$ 的水量 $lim$。 遍历 $x$ 的每个满足条件的出点 $to$，设这条边的边权为 $len$。 DFS下去，并且给出点 $to$ 以 $\\min(lim,len)$ 的水。 【优化】如果说发现DFS的返回值（设为 $val$）为 $0$，则说明该子树无法增广，直接将该出点标记不可访问。 这一步有一个很好的实现方式，就是把 $dis_{to}$ 设为 $0$，此时一定不会被遍历到。 更新 $x \\to to$ 及其反向边的边权。 由于 $val$ 的水已经从 $x$ 流出，所以 $lim$ 减去 $val$。 【优化】如果 $lim$ 为 $0$ 了，则水已经不可能再流出了，直接退出循环。 这里注意一个点，就是虽然给 $to$ 提供了 $\\min(lim,len)$ 的水，但其实真正流出去的只有 $val$ 单位的水，所以所有更新都应该用 $val$，完全与 $\\min(lim,len)$ 无关。 【优化】这个优化被称为“当前弧优化”： 我们考虑一下，显然一个点可能被DFS多遍。 而每次我们都遍历一遍所有出点吗？显然不是。 那么我们每次就记录一下遍历到哪个出点了。 下次就直接从这个出点开始遍历。 此处就有两种实现方式了： 使用vector建图，记录当前遍历到的下标。 使用链式前向星建图，不断更新表头。 但要注意一下，第2种方法在更改表头之后，要记得还原回来，否则会出错。 据说还有MPM算法、ISAP之类的，这里就不说了。\n复杂度 $O(n^2m)$\n其中 $n$ 为点数，$m$ 为边数。\n证明之后补\n网上的证明\n但这个只是上界，在一般的网络内，是往往达不到的。\n比如说，在 $n \\leq 10^4,m \\leq 10^5$ 的题目内，用Dinic只跑了 $300~\\text{ms}$。\n二分图 参考：这里\n这里顺便说一下如何用Dinic去求二分图最大匹配。\n既然是图论算法，难点必然在于建图。\n而这里怎么建呢？直接上结论：\n从源点往每个二分图的左侧点连容量为 $1$ 的边。 从每个二分图的右侧点往源点连容量为 $1$ 的边。 二分图的左右侧点之间仿照二分图连法连容量为 $1$ 的边。 然后跑最大流即可。\n由于图的特殊性，此时复杂度最多为 $O(m\\sqrt{n})$，与匈牙利算法的 $O(nm)$ 差了一个根号。\n最小割 如果有哪里没有说清楚，可以看这里。\n说完最大流，再说一个与它息息相关的最小割。\n还是先从定义说起。\n定义 对于一个网络（就是一张有向图）$G=(V,E)$ 来说，如果存在一个边集 $E’$ 满足 $E’ \\subseteq E$。\n且从 $G$ 中删去 $E’$ 的边后，该网络的源点和汇点不再连通。\n那么 $E’$ 边集被称为割，其中的任意一条边满足 $e \\in E’$ 都被称为割边。\n而使得所有割边的容量之和最小的割，被称为是最小割。\n求值 接下来说求值。\n其实可以八个字搞定：\n最小割等于最大流 理论上这个不严谨，我们把它严谨化一下：\n对于任意一个网络，该网络的最大容量，等于该网络的最小割中所有割边的容量之和 所以其实直接求最大流即可。\n证明 之后补\n网上的\n费用流 时隔多年，终于可以补一下费用流的坑了。\n定义 首先我们需要先明白费用流是什么。\n其实就是在网络流的流量限制之外，还多了一个每流过一单位的流量需要花费的代价。\n一般分为两种：\n最小费用最大流，就是说保证最大流的情况下把费用最小化。 最小费用流，就是不用保证最大流，把费用最小化即可。 实现 直接讲实现。\n其实费用流的实现比最大流简单多了。\n最小费用最大流 直接：\n不断按单位代价作为边长跑SPFA。 只要SPFA还能走出来（不经过 $len=0$ 的边），就继续。 然后把SPFA最短路路径上所有边流过“边权的最小值”的流量。 更新答案。 所以最后的复杂度就是 $O($ 增广次数 $\\times$ SPFA复杂度 $)$。\n这个东西一看就很玄学，结果就是这样的。\n增广次数可能会被卡到流量级别（特殊构造数据情况下），SPFA则是 $O(nm)$ 最多。\n所以说一半费用流如果确定要用，且这样建图一定最优，必然是给放过的。\n不过注意一下，有时候一点不同的建图方式就是大相径庭的运行效率。\n最小费用流 稍微改一下。\n既然我们需要通过不断SPFA来增广。\n那么只要SPFA出来的最短路 $\u003e0$，那么最后的费用一定不是最小了。\n于是直接：\n不断按单位代价作为边长跑SPFA。 只要SPFA还能走出来（不经过 $len=0$ 的边），就继续。 如果最短路 $\u003e0$，退出循环。 把SPFA最短路路径上所有边流过“边权的最小值”的流量。 更新答案。 复杂度同上。\n网上的讲解\n",
  "wordCount" : "448",
  "inLanguage": "en",
  "datePublished": "2025-02-09T15:28:00+08:00",
  "dateModified": "2025-02-09T15:28:00+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://qjwh.github.io/posts/aln/flow/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "CXBlog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://qjwh.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://qjwh.github.io/" accesskey="h" title="CXBlog (Alt + H)">CXBlog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://qjwh.github.io/posts/" title="文章">
                    <span>文章</span>
                </a>
            </li>
            <li>
                <a href="https://qjwh.github.io/archives/" title="列表">
                    <span>列表</span>
                </a>
            </li>
            <li>
                <a href="https://qjwh.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://qjwh.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      网络流
    </h1>
    <div class="post-meta"><span title='2025-02-09 15:28:00 +0800 CST'>February 9, 2025</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e5%89%8d%e8%a8%80" aria-label=" 前言"> 前言</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e6%9c%80%e5%a4%a7%e6%b5%81" aria-label=" 最大流"> 最大流</a><ul>
                        
                <li>
                    <a href="#text-stylecolorrgb0150136-%e5%ae%9a%e4%b9%89" aria-label=" 定义"> 定义</a><ul>
                        
                <li>
                    <a href="#text-stylecolorrgb0150136-%e7%bd%91%e7%bb%9c" aria-label=" 网络"> 网络</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e6%b5%81%e5%87%bd%e6%95%b0" aria-label=" 流函数"> 流函数</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e6%b5%81%e5%87%bd%e6%95%b0%e6%80%a7%e8%b4%a8" aria-label=" 流函数性质"> 流函数性质</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e6%b5%81%e9%87%8f" aria-label=" 流量"> 流量</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e6%9c%80%e5%a4%a7%e6%b5%81-1" aria-label=" 最大流"> 最大流</a></li></ul>
                </li>
                <li>
                    <a href="#text-stylecolorrgb0150136-ekedmonds-karp" aria-label=" EK（Edmonds Karp）"> EK（Edmonds Karp）</a><ul>
                        
                <li>
                    <a href="#text-stylecolorrgb0150136-%e5%ae%9e%e7%8e%b0" aria-label=" 实现"> 实现</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e5%8e%9f%e7%90%86" aria-label=" 原理"> 原理</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e5%a4%8d%e6%9d%82%e5%ba%a6" aria-label=" 复杂度"> 复杂度</a></li></ul>
                </li>
                <li>
                    <a href="#text-stylecolorrgb0150136-dinic" aria-label=" Dinic"> Dinic</a><ul>
                        
                <li>
                    <a href="#text-stylecolorrgb0150136-%e5%8e%9f%e7%90%86-1" aria-label=" 原理"> 原理</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e5%ae%9e%e7%8e%b0-1" aria-label=" 实现"> 实现</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e5%a4%8d%e6%9d%82%e5%ba%a6-1" aria-label=" 复杂度"> 复杂度</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e4%ba%8c%e5%88%86%e5%9b%be" aria-label=" 二分图"> 二分图</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e6%9c%80%e5%b0%8f%e5%89%b2" aria-label=" 最小割"> 最小割</a><ul>
                        
                <li>
                    <a href="#text-stylecolorrgb0150136-%e5%ae%9a%e4%b9%89-1" aria-label=" 定义"> 定义</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e6%b1%82%e5%80%bc" aria-label=" 求值"> 求值</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e8%af%81%e6%98%8e" aria-label=" 证明"> 证明</a></li></ul>
                </li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e8%b4%b9%e7%94%a8%e6%b5%81" aria-label=" 费用流"> 费用流</a><ul>
                        
                <li>
                    <a href="#text-stylecolorrgb0150136-%e5%ae%9a%e4%b9%89-2" aria-label=" 定义"> 定义</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e5%ae%9e%e7%8e%b0-2" aria-label=" 实现"> 实现</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e6%9c%80%e5%b0%8f%e8%b4%b9%e7%94%a8%e6%9c%80%e5%a4%a7%e6%b5%81" aria-label=" 最小费用最大流"> 最小费用最大流</a></li>
                <li>
                    <a href="#text-stylecolorrgb0150136-%e6%9c%80%e5%b0%8f%e8%b4%b9%e7%94%a8%e6%b5%81" aria-label=" 最小费用流"> 最小费用流</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><text style="font-family:Noto Sans SC">
<h2 id="text-stylecolorrgb0150136-前言"><text style="color:rgb(0,150,136)"> 前言<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-前言">#</a></h2>
<p>首先，网络流不是一个算法，而是一个整合包（玩MC玩的），说白了就是网络流是多个算法的统称：</p>
<ul>
<li>最大流
<ul>
<li>EK</li>
<li>Dinic</li>
</ul>
</li>
<li>最小割</li>
<li>费用流</li>
<li>&hellip;</li>
</ul>
<p>而且，有些不常用的，可能就不会提，粘个OI Wiki的链接就不详细写了。</p>
<p>接下来就按照这个目录挨个讲一下每个算法。</p>
<h2 id="text-stylecolorrgb0150136-最大流"><text style="color:rgb(0,150,136)"> 最大流<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-最大流">#</a></h2>
<blockquote>
<p>如果有哪里没有说清楚，可以看<a href="https://oi-wiki.org/graph/flow/max-flow/">这里</a>，里面还有我没有说到的最大流类型。</p></blockquote>
<p>看到最大流这个名字很多人都很陌生，这里就先从定义说起。</p>
<h3 id="text-stylecolorrgb0150136-定义"><text style="color:rgb(0,150,136)"> 定义<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-定义">#</a></h3>
<p>还是拆词法，“网络流”就可以大致理解为“网络”上的“流”，接下来就挨个说一下这两个的定义。</p>
<h4 id="text-stylecolorrgb0150136-网络"><text style="color:rgb(0,150,136)"> 网络<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-网络">#</a></h4>
<p>先说网络的定义。<del>（当然不是Internet）</del></p>
<p>我们在理解的时候可以认为是管道，但实际上它是一张特殊的<strong>有向</strong>图。</p>
<p>建设管道的必然知道，管道内流过的水，准确来说是单位时间内流过的水，必然是有上限限制的，否则管道就炸了。</p>
<p>这里也一样，对于每条边 $x \to y$，都有一个函数 $c(x,y)$ 表示这条边的限制，又称<strong>容量</strong>。</p>
<p>如果在图上没有这条边，则统一规定 $c(x,y)=0$。</p>
<p>最后，还是跟最短路一样，它有一个起点和一个终点，又称<strong>源点</strong> $S$ 和<strong>汇点</strong> $T$（$S \not= T$）。</p>
<h4 id="text-stylecolorrgb0150136-流函数"><text style="color:rgb(0,150,136)"> 流函数<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-流函数">#</a></h4>
<p>再说流函数。</p>
<p>流函数就是说，在真实操作中，一个单位时间内一条边 $x \to y$ 流过的水量 $f(x,y)$。</p>
<p>这里默认保证每个单位时间内都得流过这么多。</p>
<p>其实很好理解。</p>
<h4 id="text-stylecolorrgb0150136-流函数性质"><text style="color:rgb(0,150,136)"> 流函数性质<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-流函数性质">#</a></h4>
<p>顺便说一下流函数要满足的性质。</p>
<p>首先，源点可以无限输出水，汇点可以无限输入水。</p>
<p>接下来就是一堆性质：</p>
<ul>
<li>对于每个 $x,y$，显然 $f(x,y) \leq c(x,y)$（<strong>容量限制</strong>）。</li>
<li>对于每个 $x,y$，$f(x,y)=-f(y,x)$（<strong>斜对称</strong>）。</li>
<li>对于每个 $x$，满足不是源点也不是汇点，$\sum\limits_{u \to x} f(u,x)=\sum\limits_{x \to v} f(x,v)$（<strong>流量守恒</strong>）。</li>
</ul>
<p>这里说一下最后一点性质。</p>
<p>首先，$u \to x$ 即代表对于每个 $u$ 满足 $u$ 到 $x$ 有边，$x \to v$ 同理。</p>
<p>其次，这个翻译过来就是说，对于不是源点不是汇点的任何点，它们都不会凭空产生水，也不会让水凭空消失。</p>
<p>而源点和汇点呢？源点就没有入，凭空产生水；汇点就没有出，让水凭空消失。</p>
<p>容易理解</p>
<h4 id="text-stylecolorrgb0150136-流量"><text style="color:rgb(0,150,136)"> 流量<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-流量">#</a></h4>
<p>说到流，那必定要提流量。<del>（当然不是你们家的网络流量）</del></p>
<p>其实流量就是上面说的“流过的水量”，说白了就是 $f(x,y)$。</p>
<p>这里说一下一个细节，$f$ 是流函数，$f(x,y)$ 是该边的<strong>流量</strong>。</p>
<p>同时，还有一个反面定义，就是 $c(x,y)-f(x,y)$ 为该边的<strong>剩余容量</strong>。</p>
<p>（注意上面两个加粗题的表达）</p>
<p>但这只是一条边的流量，如果扩展到一张图，根据流量守恒，直接看源点输出了多少水，就是整张图的流量。</p>
<p>也即汇点输入的水量。</p>
<h4 id="text-stylecolorrgb0150136-最大流-1"><text style="color:rgb(0,150,136)"> 最大流<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-最大流-1">#</a></h4>
<p>最后再说最大流的定义。</p>
<p>这里说一下，<strong>最大流</strong>其实是一个<strong>函数</strong>，就是流函数。</p>
<p>而与它仅差一个字的<strong>最大流量</strong>，才是一个<strong>数值</strong>，即最大流对应方案的流量。</p>
<p>（不过似乎没有很多人会在乎这两个定义的差别，底下的所谓“求最大流”的算法，应该是“求最大流量”）</p>
<p>说完这个后，顾名思义就能猜到定义了。</p>
<p>就是合法的流函数有很多，使得整张图的流量最大的流函数，就是最大流。</p>
<h3 id="text-stylecolorrgb0150136-ekedmonds-karp"><text style="color:rgb(0,150,136)"> EK（Edmonds Karp）<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-ekedmonds-karp">#</a></h3>
<p>说完定义，接下来就从最基础的EK算法说起。</p>
<p>这个算法复杂度很高（至少相对Dinic而言），但它确实是所有网络流算法的基础。</p>
<p>因为Dinic就是从EK上优化的，最小割、费用流都是以Dinic为基础的。</p>
<p>接下来先讲实现，再讲原理。</p>
<p>不过一般没人写EK。</p>
<h4 id="text-stylecolorrgb0150136-实现"><text style="color:rgb(0,150,136)"> 实现<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-实现">#</a></h4>
<p>而且，其实EK和二分图（匈牙利算法）很像，都是求增广路。</p>
<p>说白了，就是当前解不优，找一个更优的。</p>
<p>其本质就是反悔贪心。</p>
<p>而此处的增广其实是这么实现的：</p>
<ul>
<li>先建图，带权，同时建一个反向的、边权为 $0$ 的边。
<ul>
<li>即对于原图中的一条边 $(u \to v, w)$，建两条边：
<ul>
<li>$(u \to v,w)$</li>
<li>$(v \to u,0)$</li>
</ul>
</li>
<li>注意一下，不要对这里的反向边有“种族歧视”，就把反向边当做是普通的边，人人平等（</li>
</ul>
</li>
<li>然后，不断做这件事：
<ul>
<li>从源点开始BFS，中途记录一下当前所有经过的边的边权最小值。</li>
<li>如果BFS到了汇点，答案加上最小值 $val$。</li>
<li>同时对于每条经过的边：
<ul>
<li>让这条边的边权减去 $val$。</li>
<li>让它反向边边权加上 $val$。</li>
</ul>
</li>
</ul>
</li>
<li>直到从源点开始，无论如何都得经过一条边权为 $0$ 的边才能到汇点为止。</li>
<li>因为如果经过一条边权为 $0$ 的边，此时就不用往下搜了。</li>
<li>最后，直接输出答案，即所有最小值之和即可。</li>
</ul>
<p>接下来说原理。</p>
<h4 id="text-stylecolorrgb0150136-原理"><text style="color:rgb(0,150,136)"> 原理<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-原理">#</a></h4>
<p>首先，说一下加反向边的大致意思。</p>
<p>其实就是说，你在反向边上流过 $v$ 的水，就相当于让这条边少流 $v$ 的水。</p>
<p>其次，说一下BFS这部分的原理。</p>
<p>还是举具体的例子。</p>
<p><img loading="lazy" src="https://cdn.luogu.com.cn/upload/image_hosting/kszy71xx.png"></p>
<p>在这张图里，我们模拟一下，首先一定找的是 $1 \to 2 \to 3 \to 4$ 这条路径。</p>
<p>随后把反向边更新。</p>
<p><img loading="lazy" src="https://cdn.luogu.com.cn/upload/image_hosting/gs0ky94c.png"></p>
<p>（注：在边上面，黑色的是原本边的边权；在边下面，红色的是反向边的边权）</p>
<p>接下来增广的是 $1 \to 5 \to 3 \to 2 \to 6 \to 4$ 这条路径。</p>
<p>此时已经无法继续增广。</p>
<p>所以最终答案为 $2+2=4$。</p>
<p>而怎么理解呢？其实只是这个返回的机制很独特而已。</p>
<p>我先BFS到 $1 \to 5 \to 3$，然后把最开始的路径 $3 \to 4$ 部分拼走了。</p>
<p>此时最开始的路径中的 $1 \to 2$ 开始重新寻路，就把增广路径中的 $2 \to 6 \to 4$ 拼走了。</p>
<p>所以最后是两条路径：</p>
<ul>
<li>$1 \to 5 \to 3 \to 4$</li>
<li>$1 \to 2 \to 6 \to 4$</li>
</ul>
<p>答案为 $4$。</p>
<h4 id="text-stylecolorrgb0150136-复杂度"><text style="color:rgb(0,150,136)"> 复杂度<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-复杂度">#</a></h4>
<p>$O(nm^2)$</p>
<p>其中 $n$ 为点数，$m$ 为边数。</p>
<p><em>证明之后补</em></p>
<p><a href="https://oi-wiki.org/graph/flow/max-flow/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90_1">网上的证明</a></p>
<h3 id="text-stylecolorrgb0150136-dinic"><text style="color:rgb(0,150,136)"> Dinic<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-dinic">#</a></h3>
<p>接下来就是重头戏了，就是Dinic算法。</p>
<p>这个算法相比而言，复杂度就小了很多。</p>
<p>并且，在求二分图最大匹配方面，比匈牙利算法跑得更快。</p>
<p>这次跟上面反过来，先说原理再说实现。</p>
<h4 id="text-stylecolorrgb0150136-原理-1"><text style="color:rgb(0,150,136)"> 原理<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-原理-1">#</a></h4>
<p>首先，我们考虑一下EK算法为何复杂度如此之大。</p>
<p>其实就是因为，它每次都得进行BFS，每次都从源点开始搜到汇点。</p>
<p>但做了这么多功，不还是只能搜一条增广路吗。</p>
<p>这就导致花的时间很多，但得到的收益很少。</p>
<p>所以我们就对症下药。</p>
<p>也就是我们可以一次搜多条最短路。</p>
<p>不过准确来说，我们是不一定每次都从源点开始，就像遍历一棵树一样，每次都从当前点开始搜。</p>
<p>这样的话复杂度就能剩很多。</p>
<h4 id="text-stylecolorrgb0150136-实现-1"><text style="color:rgb(0,150,136)"> 实现<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-实现-1">#</a></h4>
<p>原理很好解释清楚，但实现其实细节很多。</p>
<p>这会虽然也用BFS，但实际上上面已经透露了，Dinic的核心在于DFS，所以BFS只求最短路。</p>
<p>具体来说，我们是这样实现的：</p>
<ul>
<li>只要图还连通，就从源点开始做一遍BFS，求出现在源点到每个点 $i$ 的距离 $dis_i$。
<ul>
<li>此时就不断做DFS，并进行增广，直到不能增广为止。
<ul>
<li>一次DFS的返回值是多次增广的结果之和。</li>
</ul>
</li>
<li>将答案加上返回值。</li>
</ul>
</li>
</ul>
<p>说一下，连通的意思是存在一条路径从源点到汇点且不经过边权为 $0$ 的边；同理，边权为 $0$ 的边是不可经过的。</p>
<p>接下来就是重头戏了，就是DFS的具体实现。</p>
<p>首先，上面EK算法里，由于用BFS实现，所以每次增广都是走的当前的最短路。</p>
<p>显然这也是最优的。</p>
<p>那在这里，我们也得保证一定要最短。</p>
<p>咋做呢？我们不是BFS出了距离 $dis_i$ 吗？我们干脆在DFS的时候只遍历最短路图即可。</p>
<p>即对于一个点 $x$，只遍历满足 $dis_{to}=dis_x+1$ 的出点 $to$。</p>
<p>还是跟之前差不多（至少有点雷同的思想），直接放实现：</p>
<ul>
<li><u> DFS传入两个参数，一个是当前点 $x$，一个是流到点 $x$ 的水量 $lim$。
<ul>
<li>遍历 $x$ 的每个满足条件的出点 $to$，设这条边的边权为 $len$。
<ul>
<li>DFS下去，并且给出点 $to$ 以 $\min(lim,len)$ 的水。</u></li>
<li><text style="color:rgb(0,180,0)"> <strong>【优化】如果说发现DFS的返回值（设为 $val$）为 $0$，则说明该子树无法增广，直接将该出点标记不可访问。</strong>
<ul>
<li><em>这一步有一个很好的实现方式，就是把 $dis_{to}$ 设为 $0$，此时一定不会被遍历到。</em></li>
</ul>
</li>
<li><u> 更新 $x \to to$ 及其反向边的边权。</li>
<li>由于 $val$ 的水已经从 $x$ 流出，所以 $lim$ 减去 $val$。</u></li>
<li><text style="color:rgb(0,180,0)"> <strong>【优化】如果 $lim$ 为 $0$ 了，则水已经不可能再流出了，直接退出循环。</strong></li>
<li><text style="color:rgb(200,0,0)"> <strong>这里注意一个点，就是虽然给 $to$ 提供了 $\min(lim,len)$ 的水，但其实真正流出去的只有 $val$ 单位的水，所以所有更新都应该用 $val$，完全与 $\min(lim,len)$ 无关。</strong></li>
</ul>
</li>
<li><text style="color:rgb(0,180,0)"> <strong>【优化】这个优化被称为“当前弧优化”：</strong>
<ul>
<li><em>我们考虑一下，显然一个点可能被DFS多遍。</em></li>
<li><em>而每次我们都遍历一遍所有出点吗？显然不是。</em></li>
<li><em>那么我们每次就记录一下遍历到哪个出点了。</em></li>
<li><em>下次就直接从这个出点开始遍历。</em></li>
<li><em>此处就有两种实现方式了：</em>
<ol>
<li><em>使用<code>vector</code>建图，记录当前遍历到的下标。</em></li>
<li><em>使用链式前向星建图，不断更新表头。</em></li>
</ol>
</li>
<li><em>但要注意一下，第2种方法在更改表头之后，要记得还原回来，否则会出错。</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>据说还有<a href="https://oi-wiki.org/graph/flow/max-flow/#mpm-%E7%AE%97%E6%B3%95">MPM算法</a>、<a href="https://oi-wiki.org/graph/flow/max-flow/#isap">ISAP</a>之类的，这里就不说了。</p>
<h4 id="text-stylecolorrgb0150136-复杂度-1"><text style="color:rgb(0,150,136)"> 复杂度<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-复杂度-1">#</a></h4>
<p>$O(n^2m)$</p>
<p>其中 $n$ 为点数，$m$ 为边数。</p>
<p><em>证明之后补</em></p>
<p><a href="https://oi-wiki.org/graph/flow/max-flow/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90_2">网上的证明</a></p>
<p>但这个只是上界，在一般的网络内，是往往达不到的。</p>
<p>比如说，在 $n \leq 10^4,m \leq 10^5$ 的题目内，用Dinic只跑了 $300~\text{ms}$。</p>
<h4 id="text-stylecolorrgb0150136-二分图"><text style="color:rgb(0,150,136)"> 二分图<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-二分图">#</a></h4>
<blockquote>
<p>参考：<a href="https://oi-wiki.org/graph/graph-matching/bigraph-match/#%E8%BD%AC%E4%B8%BA%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81%E6%A8%A1%E5%9E%8B">这里</a></p></blockquote>
<p>这里顺便说一下如何用Dinic去求二分图最大匹配。</p>
<p>既然是图论算法，难点必然在于建图。</p>
<p>而这里怎么建呢？直接上结论：</p>
<ul>
<li>从源点往每个二分图的左侧点连容量为 $1$ 的边。</li>
<li>从每个二分图的右侧点往源点连容量为 $1$ 的边。</li>
<li>二分图的左右侧点之间仿照二分图连法连容量为 $1$ 的边。</li>
</ul>
<p>然后跑最大流即可。</p>
<p>由于图的特殊性，此时复杂度最多为 $O(m\sqrt{n})$，与匈牙利算法的 $O(nm)$ 差了一个根号。</p>
<h2 id="text-stylecolorrgb0150136-最小割"><text style="color:rgb(0,150,136)"> 最小割<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-最小割">#</a></h2>
<blockquote>
<p>如果有哪里没有说清楚，可以看<a href="https://oi-wiki.org/graph/flow/min-cut/">这里</a>。</p></blockquote>
<p>说完最大流，再说一个与它息息相关的最小割。</p>
<p>还是先从定义说起。</p>
<h3 id="text-stylecolorrgb0150136-定义-1"><text style="color:rgb(0,150,136)"> 定义<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-定义-1">#</a></h3>
<p>对于一个网络（就是一张有向图）$G=(V,E)$ 来说，如果存在一个边集 $E&rsquo;$ 满足 $E&rsquo; \subseteq E$。</p>
<p>且从 $G$ 中删去 $E&rsquo;$ 的边后，该网络的源点和汇点不再连通。</p>
<p>那么 $E&rsquo;$ 边集被称为<strong>割</strong>，其中的任意一条边满足 $e \in E&rsquo;$ 都被称为<strong>割边</strong>。</p>
<p>而使得所有割边的容量之和最小的割，被称为是<strong>最小割</strong>。</p>
<h3 id="text-stylecolorrgb0150136-求值"><text style="color:rgb(0,150,136)"> 求值<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-求值">#</a></h3>
<p>接下来说求值。</p>
<p>其实可以八个字搞定：</p>
<ul>
<li>最小割等于最大流</li>
</ul>
<p>理论上这个不严谨，我们把它严谨化一下：</p>
<ul>
<li>对于任意一个网络，该网络的最大容量，等于该网络的最小割中所有割边的容量之和</li>
</ul>
<p>所以其实直接求最大流即可。</p>
<h3 id="text-stylecolorrgb0150136-证明"><text style="color:rgb(0,150,136)"> 证明<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-证明">#</a></h3>
<p><em>之后补</em></p>
<p><a href="https://oi-wiki.org/graph/flow/max-flow/#%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E5%AE%9A%E7%90%86">网上的</a></p>
<h2 id="text-stylecolorrgb0150136-费用流"><text style="color:rgb(0,150,136)"> 费用流<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-费用流">#</a></h2>
<p>时隔多年，终于可以补一下费用流的坑了。</p>
<h3 id="text-stylecolorrgb0150136-定义-2"><text style="color:rgb(0,150,136)"> 定义<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-定义-2">#</a></h3>
<p>首先我们需要先明白费用流是什么。</p>
<p>其实就是在网络流的流量限制之外，还多了一个每流过一单位的流量需要花费的代价。</p>
<p>一般分为两种：</p>
<ul>
<li>最小费用最大流，就是说保证最大流的情况下把费用最小化。</li>
<li>最小费用流，就是不用保证最大流，把费用最小化即可。</li>
</ul>
<h3 id="text-stylecolorrgb0150136-实现-2"><text style="color:rgb(0,150,136)"> 实现<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-实现-2">#</a></h3>
<p>直接讲实现。</p>
<p>其实费用流的实现比最大流简单多了。</p>
<h3 id="text-stylecolorrgb0150136-最小费用最大流"><text style="color:rgb(0,150,136)"> 最小费用最大流<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-最小费用最大流">#</a></h3>
<p>直接：</p>
<ul>
<li>不断按单位代价作为边长跑SPFA。
<ul>
<li>只要SPFA还能走出来（不经过 $len=0$ 的边），就继续。</li>
<li>然后把SPFA最短路路径上所有边流过“边权的最小值”的流量。</li>
<li>更新答案。</li>
</ul>
</li>
</ul>
<p>所以最后的复杂度就是 $O($ 增广次数 $\times$ SPFA复杂度 $)$。</p>
<p>这个东西一看就很玄学，结果就是这样的。</p>
<p>增广次数可能会被卡到流量级别（特殊构造数据情况下），SPFA则是 $O(nm)$ 最多。</p>
<p>所以说一半费用流如果确定要用，且这样建图一定最优，必然是给放过的。</p>
<p>不过注意一下，有时候一点不同的建图方式就是大相径庭的运行效率。</p>
<h3 id="text-stylecolorrgb0150136-最小费用流"><text style="color:rgb(0,150,136)"> 最小费用流<a hidden class="anchor" aria-hidden="true" href="#text-stylecolorrgb0150136-最小费用流">#</a></h3>
<p>稍微改一下。</p>
<p>既然我们需要通过不断SPFA来增广。</p>
<p>那么只要SPFA出来的最短路 $&gt;0$，那么最后的费用一定不是最小了。</p>
<p>于是直接：</p>
<ul>
<li>不断按单位代价作为边长跑SPFA。
<ul>
<li>只要SPFA还能走出来（不经过 $len=0$ 的边），就继续。</li>
<li>如果最短路 $&gt;0$，退出循环。</li>
<li>把SPFA最短路路径上所有边流过“边权的最小值”的流量。</li>
<li>更新答案。</li>
</ul>
</li>
</ul>
<p>复杂度同上。</p>
<p><a href="https://oi-wiki.org/graph/flow/min-cost/">网上的讲解</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://qjwh.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B/">信息学竞赛</a></li>
      <li><a href="https://qjwh.github.io/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">算法学习笔记</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://qjwh.github.io/">CXBlog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
