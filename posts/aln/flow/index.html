<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        :root {
            --accent-color: #FF4D4D;
            --font-size: 17.5px;
        }
    </style>

    
    
    
    
    
    

    
    <title>网络流</title>
    <meta name="description" content="前言 首先，网络流不是一个算法，而是一个整合包（玩MC玩的），说白了就是网络流是多个算法的统称：
最大流 EK Dinic 最小割 费用流 &hellip; 而且，有些不常用的，可能就不会提，粘个OI Wiki的链接就不详细写了。
接下来就按照这个目录挨个讲一下每个算法。
最大流 如果有哪里没有说清楚，可以看这里，里 …">
    <meta name="keywords" content='信息学竞赛, 算法学习笔记'>

    <meta property="og:url" content="https://qjwh.github.io/posts/aln/flow/">
    <meta property="og:type" content="website">
    <meta property="og:title" content="网络流">
    <meta property="og:description" content="前言 首先，网络流不是一个算法，而是一个整合包（玩MC玩的），说白了就是网络流是多个算法的统称：
最大流 EK Dinic 最小割 费用流 &hellip; 而且，有些不常用的，可能就不会提，粘个OI Wiki的链接就不详细写了。
接下来就按照这个目录挨个讲一下每个算法。
最大流 如果有哪里没有说清楚，可以看这里，里 …">
    <meta property="og:image" content="https://qjwh.github.io/">
    <meta property="og:image:secure_url" content="https://qjwh.github.io/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="网络流">
    <meta name="twitter:description" content="前言 首先，网络流不是一个算法，而是一个整合包（玩MC玩的），说白了就是网络流是多个算法的统称：
最大流 EK Dinic 最小割 费用流 &hellip; 而且，有些不常用的，可能就不会提，粘个OI Wiki的链接就不详细写了。
接下来就按照这个目录挨个讲一下每个算法。
最大流 如果有哪里没有说清楚，可以看这里，里 …">
    <meta property="twitter:domain" content="https://qjwh.github.io/posts/aln/flow/">
    <meta property="twitter:url" content="https://qjwh.github.io/posts/aln/flow/">
    <meta name="twitter:image" content="https://qjwh.github.io/">

    
    <link rel="canonical" href="https://qjwh.github.io/posts/aln/flow/">

    
    <link rel="stylesheet" type="text/css" href="/css/normalize.min.css" media="print">

    
    <link rel="stylesheet" type="text/css" href="/css/main.min.css">

    
    <link id="dark-theme" rel="stylesheet" href="/css/dark.min.css">

    
    <script src="/js/bundle.min.ad84dd09e60165f836ea08a26f86608c070e127d21ac6ab168c87da076554d87.js" integrity="sha256-rYTdCeYBZfg26giib4ZgjAcOEn0hrGqxaMh9oHZVTYc="></script>

    
    
        <script src="https://unpkg.com/feather-icons"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          // customised options
          // ? auto-render specific keys, e.g.:
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
          ],
          // ? rendering keys, e.g.:
          throwOnError : false
        });
      });
    </script>
  
    
</head>
<body>
        <script>
            
            setThemeByUserPref();
        </script><header class="header">
    <nav class="header-nav">

        

        <div class="nav-title">
            <a class="nav-brand" href="https://qjwh.github.io/">CXBlog</a>
        </div>

        <div class="nav-links">
            
            <div class="nav-link">
                <a href="https://qjwh.github.io/" aria-label="home" >      <i data-feather="home"></i>
      <script>
        feather.replace();
      </script>
       首页
      </a>
            </div>
            
            <div class="nav-link">
                <a href="https://qjwh.github.io/posts" aria-label="posts" >      <i data-feather="book"></i>
      <script>
        feather.replace();
      </script>
       文章
      </a>
            </div>
            
            <div class="nav-link">
                <a href="https://qjwh.github.io/tags" aria-label="tags" >      <i data-feather="tag"></i>
      <script>
        feather.replace();
      </script>
       标签
      </a>
            </div>
            
            <div class="nav-link">
                <a href="https://qjwh.github.io/about" aria-label="about" >      <i data-feather="info"></i>
      <script>
        feather.replace();
      </script>
       关于
      </a>
            </div>
            

            <span class="nav-icons-divider"></span>
            <div class="nav-link dark-theme-toggle">
                <span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
                <a aria-hidden="true" role="switch">
                    <span class="theme-toggle-icon" data-feather="moon"></span>
                </a>
            </div>

            <div class="nav-link" id="hamburger-menu-toggle">
                <span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
                <a aria-checked="false" aria-labelledby="hamburger-menu-toggle" id="hamburger-menu-toggle-target" role="switch">
                    <span data-feather="menu"></span>
                </a>
            </div>

            
            <ul class="nav-hamburger-list visibility-hidden">
                
                <li class="nav-item">
                    <a href="https://qjwh.github.io/" >      <i data-feather="home"></i>
      <script>
        feather.replace();
      </script>
       首页
      </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://qjwh.github.io/posts" >      <i data-feather="book"></i>
      <script>
        feather.replace();
      </script>
       文章
      </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://qjwh.github.io/tags" >      <i data-feather="tag"></i>
      <script>
        feather.replace();
      </script>
       标签
      </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://qjwh.github.io/about" >      <i data-feather="info"></i>
      <script>
        feather.replace();
      </script>
       关于
      </a>
                </li>
                
                <li class="nav-item dark-theme-toggle">
                    <span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
                    <a role="switch">
                        <span class="theme-toggle-icon" data-feather="moon"></span>
                    </a>
                </li>
            </ul>

        </div>
    </nav>
</header>
<main id="content">
    <div class="post container">
    <div class="post-header-section">
        <h1>网络流</h1>

        

        
	
	
	
	
        

	

	

	
          <small role="doc-subtitle"></small>
	

	
          <p class="post-date">
              

              February 9, 2025

              
          </p>
	

        <ul class="post-tags">
          
           
             <li class="post-tag"><a href="https://qjwh.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B">信息学竞赛</a></li>
           
         
           
             <li class="post-tag"><a href="https://qjwh.github.io/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">算法学习笔记</a></li>
           
         
        </ul>
    </div>

    <div class="post-content">
        <text style="font-family:Noto Sans SC">
<h2 id="text-stylecolorrgb0150136-前言"><text style="color:rgb(0,150,136)"> 前言</h2>
<p>首先，网络流不是一个算法，而是一个整合包（玩MC玩的），说白了就是网络流是多个算法的统称：</p>
<ul>
<li>最大流
<ul>
<li>EK</li>
<li>Dinic</li>
</ul>
</li>
<li>最小割</li>
<li>费用流</li>
<li>&hellip;</li>
</ul>
<p>而且，有些不常用的，可能就不会提，粘个OI Wiki的链接就不详细写了。</p>
<p>接下来就按照这个目录挨个讲一下每个算法。</p>
<h2 id="text-stylecolorrgb0150136-最大流"><text style="color:rgb(0,150,136)"> 最大流</h2>
<blockquote>
<p>如果有哪里没有说清楚，可以看<a href="https://oi-wiki.org/graph/flow/max-flow/">这里</a>，里面还有我没有说到的最大流类型。</p></blockquote>
<p>看到最大流这个名字很多人都很陌生，这里就先从定义说起。</p>
<h3 id="text-stylecolorrgb0150136-定义"><text style="color:rgb(0,150,136)"> 定义</h3>
<p>还是拆词法，“网络流”就可以大致理解为“网络”上的“流”，接下来就挨个说一下这两个的定义。</p>
<h4 id="text-stylecolorrgb0150136-网络"><text style="color:rgb(0,150,136)"> 网络</h4>
<p>先说网络的定义。<del>（当然不是Internet）</del></p>
<p>我们在理解的时候可以认为是管道，但实际上它是一张特殊的<strong>有向</strong>图。</p>
<p>建设管道的必然知道，管道内流过的水，准确来说是单位时间内流过的水，必然是有上限限制的，否则管道就炸了。</p>
<p>这里也一样，对于每条边 $x \to y$，都有一个函数 $c(x,y)$ 表示这条边的限制，又称<strong>容量</strong>。</p>
<p>如果在图上没有这条边，则统一规定 $c(x,y)=0$。</p>
<p>最后，还是跟最短路一样，它有一个起点和一个终点，又称<strong>源点</strong> $S$ 和<strong>汇点</strong> $T$（$S \not= T$）。</p>
<h4 id="text-stylecolorrgb0150136-流函数"><text style="color:rgb(0,150,136)"> 流函数</h4>
<p>再说流函数。</p>
<p>流函数就是说，在真实操作中，一个单位时间内一条边 $x \to y$ 流过的水量 $f(x,y)$。</p>
<p>这里默认保证每个单位时间内都得流过这么多。</p>
<p>其实很好理解。</p>
<h4 id="text-stylecolorrgb0150136-流函数性质"><text style="color:rgb(0,150,136)"> 流函数性质</h4>
<p>顺便说一下流函数要满足的性质。</p>
<p>首先，源点可以无限输出水，汇点可以无限输入水。</p>
<p>接下来就是一堆性质：</p>
<ul>
<li>对于每个 $x,y$，显然 $f(x,y) \leq c(x,y)$（<strong>容量限制</strong>）。</li>
<li>对于每个 $x,y$，$f(x,y)=-f(y,x)$（<strong>斜对称</strong>）。</li>
<li>对于每个 $x$，满足不是源点也不是汇点，$\sum\limits_{u \to x} f(u,x)=\sum\limits_{x \to v} f(x,v)$（<strong>流量守恒</strong>）。</li>
</ul>
<p>这里说一下最后一点性质。</p>
<p>首先，$u \to x$ 即代表对于每个 $u$ 满足 $u$ 到 $x$ 有边，$x \to v$ 同理。</p>
<p>其次，这个翻译过来就是说，对于不是源点不是汇点的任何点，它们都不会凭空产生水，也不会让水凭空消失。</p>
<p>而源点和汇点呢？源点就没有入，凭空产生水；汇点就没有出，让水凭空消失。</p>
<p>容易理解</p>
<h4 id="text-stylecolorrgb0150136-流量"><text style="color:rgb(0,150,136)"> 流量</h4>
<p>说到流，那必定要提流量。<del>（当然不是你们家的网络流量）</del></p>
<p>其实流量就是上面说的“流过的水量”，说白了就是 $f(x,y)$。</p>
<p>这里说一下一个细节，$f$ 是流函数，$f(x,y)$ 是该边的<strong>流量</strong>。</p>
<p>同时，还有一个反面定义，就是 $c(x,y)-f(x,y)$ 为该边的<strong>剩余容量</strong>。</p>
<p>（注意上面两个加粗题的表达）</p>
<p>但这只是一条边的流量，如果扩展到一张图，根据流量守恒，直接看源点输出了多少水，就是整张图的流量。</p>
<p>也即汇点输入的水量。</p>
<h4 id="text-stylecolorrgb0150136-最大流-1"><text style="color:rgb(0,150,136)"> 最大流</h4>
<p>最后再说最大流的定义。</p>
<p>这里说一下，<strong>最大流</strong>其实是一个<strong>函数</strong>，就是流函数。</p>
<p>而与它仅差一个字的<strong>最大流量</strong>，才是一个<strong>数值</strong>，即最大流对应方案的流量。</p>
<p>（不过似乎没有很多人会在乎这两个定义的差别，底下的所谓“求最大流”的算法，应该是“求最大流量”）</p>
<p>说完这个后，顾名思义就能猜到定义了。</p>
<p>就是合法的流函数有很多，使得整张图的流量最大的流函数，就是最大流。</p>
<h3 id="text-stylecolorrgb0150136-ekedmonds-karp"><text style="color:rgb(0,150,136)"> EK（Edmonds Karp）</h3>
<p>说完定义，接下来就从最基础的EK算法说起。</p>
<p>这个算法复杂度很高（至少相对Dinic而言），但它确实是所有网络流算法的基础。</p>
<p>因为Dinic就是从EK上优化的，最小割、费用流都是以Dinic为基础的。</p>
<p>接下来先讲实现，再讲原理。</p>
<p>不过一般没人写EK。</p>
<h4 id="text-stylecolorrgb0150136-实现"><text style="color:rgb(0,150,136)"> 实现</h4>
<p>而且，其实EK和二分图（匈牙利算法）很像，都是求增广路。</p>
<p>说白了，就是当前解不优，找一个更优的。</p>
<p>其本质就是反悔贪心。</p>
<p>而此处的增广其实是这么实现的：</p>
<ul>
<li>先建图，带权，同时建一个反向的、边权为 $0$ 的边。
<ul>
<li>即对于原图中的一条边 $(u \to v, w)$，建两条边：
<ul>
<li>$(u \to v,w)$</li>
<li>$(v \to u,0)$</li>
</ul>
</li>
<li>注意一下，不要对这里的反向边有“种族歧视”，就把反向边当做是普通的边，人人平等（</li>
</ul>
</li>
<li>然后，不断做这件事：
<ul>
<li>从源点开始BFS，中途记录一下当前所有经过的边的边权最小值。</li>
<li>如果BFS到了汇点，答案加上最小值 $val$。</li>
<li>同时对于每条经过的边：
<ul>
<li>让这条边的边权减去 $val$。</li>
<li>让它反向边边权加上 $val$。</li>
</ul>
</li>
</ul>
</li>
<li>直到从源点开始，无论如何都得经过一条边权为 $0$ 的边才能到汇点为止。</li>
<li>因为如果经过一条边权为 $0$ 的边，此时就不用往下搜了。</li>
<li>最后，直接输出答案，即所有最小值之和即可。</li>
</ul>
<p>接下来说原理。</p>
<h4 id="text-stylecolorrgb0150136-原理"><text style="color:rgb(0,150,136)"> 原理</h4>
<p>首先，说一下加反向边的大致意思。</p>
<p>其实就是说，你在反向边上流过 $v$ 的水，就相当于让这条边少流 $v$ 的水。</p>
<p>其次，说一下BFS这部分的原理。</p>
<p>还是举具体的例子。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/kszy71xx.png" alt=""></p>
<p>在这张图里，我们模拟一下，首先一定找的是 $1 \to 2 \to 3 \to 4$ 这条路径。</p>
<p>随后把反向边更新。</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/gs0ky94c.png" alt=""></p>
<p>（注：在边上面，黑色的是原本边的边权；在边下面，红色的是反向边的边权）</p>
<p>接下来增广的是 $1 \to 5 \to 3 \to 2 \to 6 \to 4$ 这条路径。</p>
<p>此时已经无法继续增广。</p>
<p>所以最终答案为 $2+2=4$。</p>
<p>而怎么理解呢？其实只是这个返回的机制很独特而已。</p>
<p>我先BFS到 $1 \to 5 \to 3$，然后把最开始的路径 $3 \to 4$ 部分拼走了。</p>
<p>此时最开始的路径中的 $1 \to 2$ 开始重新寻路，就把增广路径中的 $2 \to 6 \to 4$ 拼走了。</p>
<p>所以最后是两条路径：</p>
<ul>
<li>$1 \to 5 \to 3 \to 4$</li>
<li>$1 \to 2 \to 6 \to 4$</li>
</ul>
<p>答案为 $4$。</p>
<h4 id="text-stylecolorrgb0150136-复杂度"><text style="color:rgb(0,150,136)"> 复杂度</h4>
<p>$O(nm^2)$</p>
<p>其中 $n$ 为点数，$m$ 为边数。</p>
<p><em>证明之后补</em></p>
<p><a href="https://oi-wiki.org/graph/flow/max-flow/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90_1">网上的证明</a></p>
<h3 id="text-stylecolorrgb0150136-dinic"><text style="color:rgb(0,150,136)"> Dinic</h3>
<p>接下来就是重头戏了，就是Dinic算法。</p>
<p>这个算法相比而言，复杂度就小了很多。</p>
<p>并且，在求二分图最大匹配方面，比匈牙利算法跑得更快。</p>
<p>这次跟上面反过来，先说原理再说实现。</p>
<h4 id="text-stylecolorrgb0150136-原理-1"><text style="color:rgb(0,150,136)"> 原理</h4>
<p>首先，我们考虑一下EK算法为何复杂度如此之大。</p>
<p>其实就是因为，它每次都得进行BFS，每次都从源点开始搜到汇点。</p>
<p>但做了这么多功，不还是只能搜一条增广路吗。</p>
<p>这就导致花的时间很多，但得到的收益很少。</p>
<p>所以我们就对症下药。</p>
<p>也就是我们可以一次搜多条最短路。</p>
<p>不过准确来说，我们是不一定每次都从源点开始，就像遍历一棵树一样，每次都从当前点开始搜。</p>
<p>这样的话复杂度就能剩很多。</p>
<h4 id="text-stylecolorrgb0150136-实现-1"><text style="color:rgb(0,150,136)"> 实现</h4>
<p>原理很好解释清楚，但实现其实细节很多。</p>
<p>这会虽然也用BFS，但实际上上面已经透露了，Dinic的核心在于DFS，所以BFS只求最短路。</p>
<p>具体来说，我们是这样实现的：</p>
<ul>
<li>只要图还连通，就从源点开始做一遍BFS，求出现在源点到每个点 $i$ 的距离 $dis_i$。
<ul>
<li>此时就不断做DFS，并进行增广，直到不能增广为止。
<ul>
<li>一次DFS的返回值是多次增广的结果之和。</li>
</ul>
</li>
<li>将答案加上返回值。</li>
</ul>
</li>
</ul>
<p>说一下，连通的意思是存在一条路径从源点到汇点且不经过边权为 $0$ 的边；同理，边权为 $0$ 的边是不可经过的。</p>
<p>接下来就是重头戏了，就是DFS的具体实现。</p>
<p>首先，上面EK算法里，由于用BFS实现，所以每次增广都是走的当前的最短路。</p>
<p>显然这也是最优的。</p>
<p>那在这里，我们也得保证一定要最短。</p>
<p>咋做呢？我们不是BFS出了距离 $dis_i$ 吗？我们干脆在DFS的时候只遍历最短路图即可。</p>
<p>即对于一个点 $x$，只遍历满足 $dis_{to}=dis_x+1$ 的出点 $to$。</p>
<p>还是跟之前差不多（至少有点雷同的思想），直接放实现：</p>
<ul>
<li><u> DFS传入两个参数，一个是当前点 $x$，一个是流到点 $x$ 的水量 $lim$。
<ul>
<li>遍历 $x$ 的每个满足条件的出点 $to$，设这条边的边权为 $len$。
<ul>
<li>DFS下去，并且给出点 $to$ 以 $\min(lim,len)$ 的水。</u></li>
<li><text style="color:rgb(0,180,0)"> <strong>【优化】如果说发现DFS的返回值（设为 $val$）为 $0$，则说明该子树无法增广，直接将该出点标记不可访问。</strong>
<ul>
<li><em>这一步有一个很好的实现方式，就是把 $dis_{to}$ 设为 $0$，此时一定不会被遍历到。</em></li>
</ul>
</li>
<li><u> 更新 $x \to to$ 及其反向边的边权。</li>
<li>由于 $val$ 的水已经从 $x$ 流出，所以 $lim$ 减去 $val$。</u></li>
<li><text style="color:rgb(0,180,0)"> <strong>【优化】如果 $lim$ 为 $0$ 了，则水已经不可能再流出了，直接退出循环。</strong></li>
<li><text style="color:rgb(200,0,0)"> <strong>这里注意一个点，就是虽然给 $to$ 提供了 $\min(lim,len)$ 的水，但其实真正流出去的只有 $val$ 单位的水，所以所有更新都应该用 $val$，完全与 $\min(lim,len)$ 无关。</strong></li>
</ul>
</li>
<li><text style="color:rgb(0,180,0)"> <strong>【优化】这个优化被称为“当前弧优化”：</strong>
<ul>
<li><em>我们考虑一下，显然一个点可能被DFS多遍。</em></li>
<li><em>而每次我们都遍历一遍所有出点吗？显然不是。</em></li>
<li><em>那么我们每次就记录一下遍历到哪个出点了。</em></li>
<li><em>下次就直接从这个出点开始遍历。</em></li>
<li><em>此处就有两种实现方式了：</em>
<ol>
<li><em>使用<code>vector</code>建图，记录当前遍历到的下标。</em></li>
<li><em>使用链式前向星建图，不断更新表头。</em></li>
</ol>
</li>
<li><em>但要注意一下，第2种方法在更改表头之后，要记得还原回来，否则会出错。</em></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>据说还有<a href="https://oi-wiki.org/graph/flow/max-flow/#mpm-%E7%AE%97%E6%B3%95">MPM算法</a>、<a href="https://oi-wiki.org/graph/flow/max-flow/#isap">ISAP</a>之类的，这里就不说了。</p>
<h4 id="text-stylecolorrgb0150136-复杂度-1"><text style="color:rgb(0,150,136)"> 复杂度</h4>
<p>$O(n^2m)$</p>
<p>其中 $n$ 为点数，$m$ 为边数。</p>
<p><em>证明之后补</em></p>
<p><a href="https://oi-wiki.org/graph/flow/max-flow/#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90_2">网上的证明</a></p>
<p>但这个只是上界，在一般的网络内，是往往达不到的。</p>
<p>比如说，在 $n \leq 10^4,m \leq 10^5$ 的题目内，用Dinic只跑了 $300~\text{ms}$。</p>
<h4 id="text-stylecolorrgb0150136-二分图"><text style="color:rgb(0,150,136)"> 二分图</h4>
<blockquote>
<p>参考：<a href="https://oi-wiki.org/graph/graph-matching/bigraph-match/#%E8%BD%AC%E4%B8%BA%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81%E6%A8%A1%E5%9E%8B">这里</a></p></blockquote>
<p>这里顺便说一下如何用Dinic去求二分图最大匹配。</p>
<p>既然是图论算法，难点必然在于建图。</p>
<p>而这里怎么建呢？直接上结论：</p>
<ul>
<li>从源点往每个二分图的左侧点连容量为 $1$ 的边。</li>
<li>从每个二分图的右侧点往源点连容量为 $1$ 的边。</li>
<li>二分图的左右侧点之间仿照二分图连法连容量为 $1$ 的边。</li>
</ul>
<p>然后跑最大流即可。</p>
<p>由于图的特殊性，此时复杂度最多为 $O(m\sqrt{n})$，与匈牙利算法的 $O(nm)$ 差了一个根号。</p>
<h2 id="text-stylecolorrgb0150136-最小割"><text style="color:rgb(0,150,136)"> 最小割</h2>
<blockquote>
<p>如果有哪里没有说清楚，可以看<a href="https://oi-wiki.org/graph/flow/min-cut/">这里</a>。</p></blockquote>
<p>说完最大流，再说一个与它息息相关的最小割。</p>
<p>还是先从定义说起。</p>
<h3 id="text-stylecolorrgb0150136-定义-1"><text style="color:rgb(0,150,136)"> 定义</h3>
<p>对于一个网络（就是一张有向图）$G=(V,E)$ 来说，如果存在一个边集 $E&rsquo;$ 满足 $E&rsquo; \subseteq E$。</p>
<p>且从 $G$ 中删去 $E&rsquo;$ 的边后，该网络的源点和汇点不再连通。</p>
<p>那么 $E&rsquo;$ 边集被称为<strong>割</strong>，其中的任意一条边满足 $e \in E&rsquo;$ 都被称为<strong>割边</strong>。</p>
<p>而使得所有割边的容量之和最小的割，被称为是<strong>最小割</strong>。</p>
<h3 id="text-stylecolorrgb0150136-求值"><text style="color:rgb(0,150,136)"> 求值</h3>
<p>接下来说求值。</p>
<p>其实可以八个字搞定：</p>
<ul>
<li>最小割等于最大流</li>
</ul>
<p>理论上这个不严谨，我们把它严谨化一下：</p>
<ul>
<li>对于任意一个网络，该网络的最大容量，等于该网络的最小割中所有割边的容量之和</li>
</ul>
<p>所以其实直接求最大流即可。</p>
<h3 id="text-stylecolorrgb0150136-证明"><text style="color:rgb(0,150,136)"> 证明</h3>
<p><em>之后补</em></p>
<p><a href="https://oi-wiki.org/graph/flow/max-flow/#%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2%E5%AE%9A%E7%90%86">网上的</a></p>
<h2 id="text-stylecolorrgb0150136-费用流"><text style="color:rgb(0,150,136)"> 费用流</h2>
<p>时隔多年，终于可以补一下费用流的坑了。</p>
<h3 id="text-stylecolorrgb0150136-定义-2"><text style="color:rgb(0,150,136)"> 定义</h3>
<p>首先我们需要先明白费用流是什么。</p>
<p>其实就是在网络流的流量限制之外，还多了一个每流过一单位的流量需要花费的代价。</p>
<p>一般分为两种：</p>
<ul>
<li>最小费用最大流，就是说保证最大流的情况下把费用最小化。</li>
<li>最小费用流，就是不用保证最大流，把费用最小化即可。</li>
</ul>
<h3 id="text-stylecolorrgb0150136-实现-2"><text style="color:rgb(0,150,136)"> 实现</h3>
<p>直接讲实现。</p>
<p>其实费用流的实现比最大流简单多了。</p>
<h3 id="text-stylecolorrgb0150136-最小费用最大流"><text style="color:rgb(0,150,136)"> 最小费用最大流</h3>
<p>直接：</p>
<ul>
<li>不断按单位代价作为边长跑SPFA。
<ul>
<li>只要SPFA还能走出来（不经过 $len=0$ 的边），就继续。</li>
<li>然后把SPFA最短路路径上所有边流过“边权的最小值”的流量。</li>
<li>更新答案。</li>
</ul>
</li>
</ul>
<p>所以最后的复杂度就是 $O($ 增广次数 $\times$ SPFA复杂度 $)$。</p>
<p>这个东西一看就很玄学，结果就是这样的。</p>
<p>增广次数可能会被卡到流量级别（特殊构造数据情况下），SPFA则是 $O(nm)$ 最多。</p>
<p>所以说一半费用流如果确定要用，且这样建图一定最优，必然是给放过的。</p>
<p>不过注意一下，有时候一点不同的建图方式就是大相径庭的运行效率。</p>
<h3 id="text-stylecolorrgb0150136-最小费用流"><text style="color:rgb(0,150,136)"> 最小费用流</h3>
<p>稍微改一下。</p>
<p>既然我们需要通过不断SPFA来增广。</p>
<p>那么只要SPFA出来的最短路 $&gt;0$，那么最后的费用一定不是最小了。</p>
<p>于是直接：</p>
<ul>
<li>不断按单位代价作为边长跑SPFA。
<ul>
<li>只要SPFA还能走出来（不经过 $len=0$ 的边），就继续。</li>
<li>如果最短路 $&gt;0$，退出循环。</li>
<li>把SPFA最短路路径上所有边流过“边权的最小值”的流量。</li>
<li>更新答案。</li>
</ul>
</li>
</ul>
<p>复杂度同上。</p>
<p><a href="https://oi-wiki.org/graph/flow/min-cost/">网上的讲解</a></p>

        
    </div>

    <div class="prev-next">
        
    </div>

    
    
    
</div>

<aside class="post-toc">
    <nav id="toc">
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#text-stylecolorrgb0150136-前言"><text style="color:rgb(0,150,136)"> 前言</a></li>
        <li><a href="#text-stylecolorrgb0150136-最大流"><text style="color:rgb(0,150,136)"> 最大流</a>
          <ul>
            <li><a href="#text-stylecolorrgb0150136-定义"><text style="color:rgb(0,150,136)"> 定义</a>
              <ul>
                <li><a href="#text-stylecolorrgb0150136-网络"><text style="color:rgb(0,150,136)"> 网络</a></li>
                <li><a href="#text-stylecolorrgb0150136-流函数"><text style="color:rgb(0,150,136)"> 流函数</a></li>
                <li><a href="#text-stylecolorrgb0150136-流函数性质"><text style="color:rgb(0,150,136)"> 流函数性质</a></li>
                <li><a href="#text-stylecolorrgb0150136-流量"><text style="color:rgb(0,150,136)"> 流量</a></li>
                <li><a href="#text-stylecolorrgb0150136-最大流-1"><text style="color:rgb(0,150,136)"> 最大流</a></li>
              </ul>
            </li>
            <li><a href="#text-stylecolorrgb0150136-ekedmonds-karp"><text style="color:rgb(0,150,136)"> EK（Edmonds Karp）</a>
              <ul>
                <li><a href="#text-stylecolorrgb0150136-实现"><text style="color:rgb(0,150,136)"> 实现</a></li>
                <li><a href="#text-stylecolorrgb0150136-原理"><text style="color:rgb(0,150,136)"> 原理</a></li>
                <li><a href="#text-stylecolorrgb0150136-复杂度"><text style="color:rgb(0,150,136)"> 复杂度</a></li>
              </ul>
            </li>
            <li><a href="#text-stylecolorrgb0150136-dinic"><text style="color:rgb(0,150,136)"> Dinic</a>
              <ul>
                <li><a href="#text-stylecolorrgb0150136-原理-1"><text style="color:rgb(0,150,136)"> 原理</a></li>
                <li><a href="#text-stylecolorrgb0150136-实现-1"><text style="color:rgb(0,150,136)"> 实现</a></li>
                <li><a href="#text-stylecolorrgb0150136-复杂度-1"><text style="color:rgb(0,150,136)"> 复杂度</a></li>
                <li><a href="#text-stylecolorrgb0150136-二分图"><text style="color:rgb(0,150,136)"> 二分图</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#text-stylecolorrgb0150136-最小割"><text style="color:rgb(0,150,136)"> 最小割</a>
          <ul>
            <li><a href="#text-stylecolorrgb0150136-定义-1"><text style="color:rgb(0,150,136)"> 定义</a></li>
            <li><a href="#text-stylecolorrgb0150136-求值"><text style="color:rgb(0,150,136)"> 求值</a></li>
            <li><a href="#text-stylecolorrgb0150136-证明"><text style="color:rgb(0,150,136)"> 证明</a></li>
          </ul>
        </li>
        <li><a href="#text-stylecolorrgb0150136-费用流"><text style="color:rgb(0,150,136)"> 费用流</a>
          <ul>
            <li><a href="#text-stylecolorrgb0150136-定义-2"><text style="color:rgb(0,150,136)"> 定义</a></li>
            <li><a href="#text-stylecolorrgb0150136-实现-2"><text style="color:rgb(0,150,136)"> 实现</a></li>
            <li><a href="#text-stylecolorrgb0150136-最小费用最大流"><text style="color:rgb(0,150,136)"> 最小费用最大流</a></li>
            <li><a href="#text-stylecolorrgb0150136-最小费用流"><text style="color:rgb(0,150,136)"> 最小费用流</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
    </nav>
</aside>



    

        </main><footer class="footer">
    
    

    

    

    

    <span>
        Made with &#10084;&#65039; using <a target="_blank" href="https://github.com/gokarna-theme/gokarna-hugo">Gokarna</a>
    </span>
</footer>
</body>
</html>
