<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        :root {
            --accent-color: #FF4D4D;
            --font-size: 17.5px;
        }
    </style>

    
    
    
    
    
    

    
    <title>平衡树</title>
    <meta name="description" content="说到平衡树，很多人的第一印象就是：
难学（知识点真多） 难懂（特别是“旋转”和证明） 难调（我的某个教练刚学平衡树的时候调了七个小时） 下面我们就来从0开始讲平衡树。
（注：网上大多数人说到“平衡树”默认指的是“Splay”而不是其他算法）
定义 其实平衡树（Balance Tree，简称BT）不算一种算法，而是一种 …">
    <meta name="keywords" content='信息学竞赛, 算法学习笔记'>

    <meta property="og:url" content="https://qjwh.github.io/posts/aln/balancedtree/">
    <meta property="og:type" content="website">
    <meta property="og:title" content="平衡树">
    <meta property="og:description" content="说到平衡树，很多人的第一印象就是：
难学（知识点真多） 难懂（特别是“旋转”和证明） 难调（我的某个教练刚学平衡树的时候调了七个小时） 下面我们就来从0开始讲平衡树。
（注：网上大多数人说到“平衡树”默认指的是“Splay”而不是其他算法）
定义 其实平衡树（Balance Tree，简称BT）不算一种算法，而是一种 …">
    <meta property="og:image" content="https://qjwh.github.io/">
    <meta property="og:image:secure_url" content="https://qjwh.github.io/">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="平衡树">
    <meta name="twitter:description" content="说到平衡树，很多人的第一印象就是：
难学（知识点真多） 难懂（特别是“旋转”和证明） 难调（我的某个教练刚学平衡树的时候调了七个小时） 下面我们就来从0开始讲平衡树。
（注：网上大多数人说到“平衡树”默认指的是“Splay”而不是其他算法）
定义 其实平衡树（Balance Tree，简称BT）不算一种算法，而是一种 …">
    <meta property="twitter:domain" content="https://qjwh.github.io/posts/aln/balancedtree/">
    <meta property="twitter:url" content="https://qjwh.github.io/posts/aln/balancedtree/">
    <meta name="twitter:image" content="https://qjwh.github.io/">

    
    <link rel="canonical" href="https://qjwh.github.io/posts/aln/balancedtree/">

    
    <link rel="stylesheet" type="text/css" href="/css/normalize.min.css" media="print">

    
    <link rel="stylesheet" type="text/css" href="/css/main.min.css">

    
    <link id="dark-theme" rel="stylesheet" href="/css/dark.min.css">

    
    <script src="/js/bundle.min.ad84dd09e60165f836ea08a26f86608c070e127d21ac6ab168c87da076554d87.js" integrity="sha256-rYTdCeYBZfg26giib4ZgjAcOEn0hrGqxaMh9oHZVTYc="></script>

    
    
        <script src="https://unpkg.com/feather-icons"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js" integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          // customised options
          // ? auto-render specific keys, e.g.:
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
          ],
          // ? rendering keys, e.g.:
          throwOnError : false
        });
      });
    </script>
    
    <style>
        @font-face { 
            font-family: 'Ubuntu';
            src: url('/UbuntuB.ttf');
        }
        body {
            // font-family: 'Ubuntu', '仿宋';
            font-family: 'Ubuntu';
        }
    </style>
  
    
</head>
<body>
        <script>
            
            setThemeByUserPref();
        </script><header class="header">
    <nav class="header-nav">

        

        <div class="nav-title">
            <a class="nav-brand" href="https://qjwh.github.io/">CXBlog</a>
        </div>

        <div class="nav-links">
            
            <div class="nav-link">
                <a href="https://qjwh.github.io/" aria-label="home" >      <i data-feather="home"></i>
      <script>
        feather.replace();
      </script>
       首页
      </a>
            </div>
            
            <div class="nav-link">
                <a href="https://qjwh.github.io/posts" aria-label="posts" >      <i data-feather="book"></i>
      <script>
        feather.replace();
      </script>
       文章
      </a>
            </div>
            
            <div class="nav-link">
                <a href="https://qjwh.github.io/tags" aria-label="tags" >      <i data-feather="tag"></i>
      <script>
        feather.replace();
      </script>
       标签
      </a>
            </div>
            
            <div class="nav-link">
                <a href="https://qjwh.github.io/about" aria-label="about" >      <i data-feather="info"></i>
      <script>
        feather.replace();
      </script>
       关于
      </a>
            </div>
            

            <span class="nav-icons-divider"></span>
            <div class="nav-link dark-theme-toggle">
                <span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
                <a aria-hidden="true" role="switch">
                    <span class="theme-toggle-icon" data-feather="moon"></span>
                </a>
            </div>

            <div class="nav-link" id="hamburger-menu-toggle">
                <span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
                <a aria-checked="false" aria-labelledby="hamburger-menu-toggle" id="hamburger-menu-toggle-target" role="switch">
                    <span data-feather="menu"></span>
                </a>
            </div>

            
            <ul class="nav-hamburger-list visibility-hidden">
                
                <li class="nav-item">
                    <a href="https://qjwh.github.io/" >      <i data-feather="home"></i>
      <script>
        feather.replace();
      </script>
       首页
      </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://qjwh.github.io/posts" >      <i data-feather="book"></i>
      <script>
        feather.replace();
      </script>
       文章
      </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://qjwh.github.io/tags" >      <i data-feather="tag"></i>
      <script>
        feather.replace();
      </script>
       标签
      </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://qjwh.github.io/about" >      <i data-feather="info"></i>
      <script>
        feather.replace();
      </script>
       关于
      </a>
                </li>
                
                <li class="nav-item dark-theme-toggle">
                    <span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
                    <a role="switch">
                        <span class="theme-toggle-icon" data-feather="moon"></span>
                    </a>
                </li>
            </ul>

        </div>
    </nav>
</header>
<main id="content">
    <div class="post container">
    <div class="post-header-section">
        <h1>平衡树</h1>

        

        
	
	
	
	
        

	

	

	
          <small role="doc-subtitle"></small>
	

	
          <p class="post-date">
              

              February 9, 2025

              
          </p>
	

        <ul class="post-tags">
          
           
             <li class="post-tag"><a href="https://qjwh.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B">信息学竞赛</a></li>
           
         
           
             <li class="post-tag"><a href="https://qjwh.github.io/tags/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">算法学习笔记</a></li>
           
         
        </ul>
    </div>

    <div class="post-content">
        <text style="font-family:Noto Sans SC">
<p>说到平衡树，很多人的第一印象就是：</p>
<ul>
<li>难学（知识点真多）</li>
<li>难懂（特别是“旋转”和证明）</li>
<li>难调（我的某个教练刚学平衡树的时候调了七个小时）</li>
</ul>
<p>下面我们就来从0开始讲平衡树。</p>
<p>（注：网上大多数人说到“平衡树”默认指的是“Splay”而不是其他算法）</p>
<h1 id="text-stylecolorrgb0150136-定义"><text style="color:rgb(0,150,136)"> 定义</h1>
<p>其实平衡树（Balance Tree，简称BT）不算一种算法，而是一种统称。</p>
<p>平衡树顾名思义就是非常平衡的树。</p>
<p>比如说这棵树就非常不平衡：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/88bai0mt.png" alt=""></p>
<p>而这棵树就比较平衡：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/w7w8hynq.png" alt=""></p>
<p>如果说的更形式化，平衡就意味着，对于每个点，其所有子树的大小差都不超过 $1$。</p>
<p>具体而言，对于每个点 $x$，如果我们把其所有儿子 $to$ 的子树大小都列出来，那么这个数组内最大值和最小值差不超过 $1$。</p>
<p>而且，大多数平衡树都是二叉树，这一点是为了方便操作和设计算法。</p>
<h1 id="text-stylecolorrgb0150136-种类"><text style="color:rgb(0,150,136)"> 种类</h1>
<p>听完上面的定义，你就知道了，平衡树就是一类树状数据结构的统称。</p>
<p>下面就来列举一下这类数据结构都有哪些，以及这些数据结构的简介。</p>
<h2 id="text-stylecolorrgb0150136-二叉搜索树binary-search-tree简称bst"><text style="color:rgb(0,150,136)"> 二叉搜索树（Binary Search Tree，简称BST）</h2>
<p>大多数平衡树的前置算法，这也就意味着，大多数的平衡树都是基于BST并进行优化、扩展后得到的算法。</p>
<p>而BST也是线段树（Segment Tree，部分情况下会简称为ST）进行扩展后的算法。</p>
<p>具体而言，权值线段树和BST都可以维护有序集合，但有时候只能用BST解决。</p>
<p>BST其实就是把权值“当做”节点编号（讲的时候一般就这么讲，但写的时候不能这么写，是把权值存入该节点的结构体内）。</p>
<p>然后对于每个点，它都有最多 $2$ 个儿子，左儿子权值 $&lt;$ 当前点权值 $&lt;$ 右儿子权值。</p>
<p>这样就可以方便查找。</p>
<p>优点：代码好写，容易讲明白</p>
<p>缺点：解决题型少，需要写定期重构（又被称作“替罪羊树思想”），复杂度高</p>
<h2 id="text-stylecolorrgb0150136-treap名字不是一个单词而是两个单词tree和heap的结合"><text style="color:rgb(0,150,136)"> Treap（名字不是一个单词，而是两个单词Tree和Heap的结合）</h2>
<p>这个算法给每个节点都添加了一个“优先级”，并让“优先级”满足小/大根堆的性质。</p>
<p>并且，这里还通过“旋转”操作（最头疼的地方来了）让树尽量平衡，这样会让树高稳定在 $O(\log n)$ 级别。</p>
<p>（不过注意，在最坏情况下，复杂度会达到 $O(n)$，所以 $O(\log n)$ 只是期望）</p>
<p>这样，复杂度就降下来了。</p>
<p>优点：复杂度低，比较容易理解，解决题型多，且容易被识别出</p>
<p>缺点：比较难写，细节较多，复杂度难证明</p>
<h2 id="text-stylecolorrgb0150136-splay本意为张开但这里不是这个意思"><text style="color:rgb(0,150,136)"> Splay（本意为“张开”但这里不是这个意思）</h2>
<p>这个算法对上面的“旋转”操作又做了一遍扩展，让其能够解决子串翻转问题。</p>
<p>而且，由于它也会让整棵树尽量平衡，所以树高还是会稳定在 $O(\log n)$ 级别。</p>
<p>（这里的 $O(\log n)$ 应该也是期望）</p>
<p>优点：复杂度低，解决题型多，且容易被识别出</p>
<p>缺点：非常难写，细节贼多，非常难理解，复杂度依然很难证明</p>
<h1 id="text-stylecolorrgb0150136-依次讲解"><text style="color:rgb(0,150,136)"> 依次讲解</h1>
<p>接下来来分别看每种算法的实现与解决题型</p>
<h2 id="text-stylecolorrgb0150136-解决题型"><text style="color:rgb(0,150,136)"> 解决题型</h2>
<p>下面默认都要解决<a href="https://www.luogu.com.cn/problem/P3369">P3369</a>这道题。</p>
<p>这种题型就是上面说的“维护集合”的题目。</p>
<p>下面来看如何解决。</p>
<h2 id="text-stylecolorrgb0150136-权值线段树"><text style="color:rgb(0,150,136)"> 权值线段树</h2>
<p>看到这道题，很多人都会想到权值线段树（不过要先离散化）。</p>
<p>我们就维护当前每个值域内的值个数。</p>
<p>然后，可以发现，每种询问分别可以这样解决：</p>
<ol>
<li>单点修改</li>
<li>单点修改</li>
<li>区间求和</li>
<li>线段树上二分</li>
<li>线段树上二分</li>
<li>线段树上二分</li>
</ol>
<p>具体细节这里不多说，可以看代码。</p>
<p>时间复杂度：$O(n \log n)$</p>
<h3 id="text-stylecolorrgb0150136-代码"><text style="color:rgb(0,150,136)"> 代码</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">递交到</span>P3369即可AC
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> LL N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>, Q <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL qc;
</span></span><span style="display:flex;"><span>LL opt;
</span></span><span style="display:flex;"><span>LL x;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Query</span>{
</span></span><span style="display:flex;"><span>    LL opt;
</span></span><span style="display:flex;"><span>    LL x;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>Query q[Q];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bs<span style="color:#f92672">&lt;</span>LL<span style="color:#f92672">&gt;</span> alls;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define find(x) (lower_bound(all(alls), x) - alls.begin() + 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL n;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define lc ((x) * 2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define rc ((x) * 2 + 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define mid ((l) + ((r) - (l)) / 2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL cnt[N <span style="color:#f92672">*</span> <span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define pushup(x) (cnt[x] = cnt[lc] + cnt[rc])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">updadd</span>(LL x, LL l, LL r, LL mx, LL mv){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l <span style="color:#f92672">==</span> r){ cnt[x] <span style="color:#f92672">+=</span> mv; <span style="color:#66d9ef">return</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(mx <span style="color:#f92672">&lt;=</span> mid) updadd(lc, l, mid, mx, mv);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> updadd(rc, mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r, mx, mv);
</span></span><span style="display:flex;"><span>    pushup(x);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">getsum</span>(LL x, LL l, LL r, LL ql, LL qr){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(ql <span style="color:#f92672">&gt;</span> qr) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(ql <span style="color:#f92672">&lt;=</span> l <span style="color:#f92672">&amp;&amp;</span> r <span style="color:#f92672">&lt;=</span> qr) <span style="color:#66d9ef">return</span> cnt[x];
</span></span><span style="display:flex;"><span>    LL ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(ql <span style="color:#f92672">&lt;=</span> mid) ret <span style="color:#f92672">+=</span> getsum(lc, l, mid, ql, qr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> qr) ret <span style="color:#f92672">+=</span> getsum(rc, mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r, ql, qr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">getrkx</span>(LL x, LL l, LL r, LL qx){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l <span style="color:#f92672">==</span> r) <span style="color:#66d9ef">return</span> alls[l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(cnt[lc] <span style="color:#f92672">&gt;=</span> qx) <span style="color:#66d9ef">return</span> getrkx(lc, l, mid, qx);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> getrkx(rc, mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r, qx <span style="color:#f92672">-</span> cnt[lc]);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#undef lc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#undef rc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#undef mid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    rd(qc);
</span></span><span style="display:flex;"><span>    rep(i, <span style="color:#ae81ff">1</span>, qc){
</span></span><span style="display:flex;"><span>        rd(opt), rd(x);
</span></span><span style="display:flex;"><span>        q[i] <span style="color:#f92672">=</span> {opt, x};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">!=</span> <span style="color:#ae81ff">4</span>) alls <span style="color:#f92672">+=</span> x;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    sort(all(alls));
</span></span><span style="display:flex;"><span>    alls.erase(unique(all(alls)), alls.end());
</span></span><span style="display:flex;"><span>    n <span style="color:#f92672">=</span> sz(alls);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    rep(i, <span style="color:#ae81ff">1</span>, qc){
</span></span><span style="display:flex;"><span>        LL opt <span style="color:#f92672">=</span> q[i].opt, <span style="color:#f92672">&amp;</span>x <span style="color:#f92672">=</span> q[i].x;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">!=</span> <span style="color:#ae81ff">4</span>) x <span style="color:#f92672">=</span> find(x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    rep(i, <span style="color:#ae81ff">1</span>, qc){
</span></span><span style="display:flex;"><span>        LL opt <span style="color:#f92672">=</span> q[i].opt, x <span style="color:#f92672">=</span> q[i].x;
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) updadd(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, n, x, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) updadd(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, n, x, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>) printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getsum(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, n, <span style="color:#ae81ff">1</span>, x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>) printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getrkx(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, n, x));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>) printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getrkx(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, n, getsum(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, n, <span style="color:#ae81ff">1</span>, x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>              printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, getrkx(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, n, getsum(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, n, <span style="color:#ae81ff">1</span>, x) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="text-stylecolorrgb0150136-动态开点权值线段树"><text style="color:rgb(0,150,136)"> 动态开点权值线段树</h2>
<p>不过，像<a href="https://www.luogu.com.cn/problem/P6136">P6136</a>这样，强制在线了，怎么搞？很简单，加个动态开点即可。</p>
<p>就是动态开点可能不太好写，且常数、空间更大。</p>
<p>其他的没变，只是用的是“动态开点权值线段树”而已。</p>
<blockquote>
<p><del>上联：可持久化带懒标记离线线段树</del><br>
<del>下联：有限状态乌姆尼克权值自动机</del></p></blockquote>
<p>时间复杂度：$O(n \log n)$</p>
<h3 id="text-stylecolorrgb0150136-代码-1"><text style="color:rgb(0,150,136)"> 代码</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">由于</span>P6136过于卡空间<span style="color:#960050;background-color:#1e0010">，所以下面代码递交上去并不能</span>AC<span style="color:#960050;background-color:#1e0010">，而是获得</span><span style="color:#ae81ff">64</span><span style="color:#960050;background-color:#1e0010">分，所以仅供参考</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> LL N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL n, qc;
</span></span><span style="display:flex;"><span>LL opt;
</span></span><span style="display:flex;"><span>LL x;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define lc (tlc[x])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define rc (trc[x])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define mid ((l) + ((r) - (l)) / 2)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL cnt[N <span style="color:#f92672">*</span> <span style="color:#ae81ff">77</span>];
</span></span><span style="display:flex;"><span>LL tlc[N <span style="color:#f92672">*</span> <span style="color:#ae81ff">77</span>], trc[N <span style="color:#f92672">*</span> <span style="color:#ae81ff">77</span>];
</span></span><span style="display:flex;"><span>LL ind;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define pushup(x) (cnt[x] = cnt[lc] + cnt[rc])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL <span style="color:#a6e22e">newnode</span>(){
</span></span><span style="display:flex;"><span>    ind<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    cnt[ind] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    tlc[ind] <span style="color:#f92672">=</span> trc[ind] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ind;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">updadd</span>(LL <span style="color:#f92672">&amp;</span>x, LL l, LL r, LL mx, LL mv){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) x <span style="color:#f92672">=</span> newnode();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l <span style="color:#f92672">==</span> r){ cnt[x] <span style="color:#f92672">+=</span> mv; <span style="color:#66d9ef">return</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(mx <span style="color:#f92672">&lt;=</span> mid) updadd(lc, l, mid, mx, mv);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> updadd(rc, mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r, mx, mv);
</span></span><span style="display:flex;"><span>    pushup(x);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">getsum</span>(LL x, LL l, LL r, LL ql, LL qr){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(ql <span style="color:#f92672">&gt;</span> qr) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(ql <span style="color:#f92672">&lt;=</span> l <span style="color:#f92672">&amp;&amp;</span> r <span style="color:#f92672">&lt;=</span> qr) <span style="color:#66d9ef">return</span> cnt[x];
</span></span><span style="display:flex;"><span>    LL ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(ql <span style="color:#f92672">&lt;=</span> mid <span style="color:#f92672">&amp;&amp;</span> lc) ret <span style="color:#f92672">+=</span> getsum(lc, l, mid, ql, qr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> qr <span style="color:#f92672">&amp;&amp;</span> rc) ret <span style="color:#f92672">+=</span> getsum(rc, mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r, ql, qr);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">getrkx</span>(LL x, LL l, LL r, LL qx){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l <span style="color:#f92672">==</span> r) <span style="color:#66d9ef">return</span> l;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(cnt[lc] <span style="color:#f92672">&gt;=</span> qx) <span style="color:#66d9ef">return</span> getrkx(lc, l, mid, qx);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> getrkx(rc, mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r, qx <span style="color:#f92672">-</span> cnt[lc]);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#undef lc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#undef rc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#undef mid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>LL ans;
</span></span><span style="display:flex;"><span>LL lans;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    rd(n), rd(qc);
</span></span><span style="display:flex;"><span>    LL rt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    cir(n){
</span></span><span style="display:flex;"><span>        rd(x);
</span></span><span style="display:flex;"><span>        updadd(rt, <span style="color:#ae81ff">0</span>, (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">30</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, x, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    rep(i, <span style="color:#ae81ff">1</span>, qc){
</span></span><span style="display:flex;"><span>        rd(opt), rd(x);
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">^=</span> lans;
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) updadd(rt, <span style="color:#ae81ff">0</span>, (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">30</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, x, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) updadd(rt, <span style="color:#ae81ff">0</span>, (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">30</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, x, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>) ans <span style="color:#f92672">^=</span> (lans <span style="color:#f92672">=</span> getsum(rt, <span style="color:#ae81ff">0</span>, (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">30</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>                         );
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>) ans <span style="color:#f92672">^=</span> (lans <span style="color:#f92672">=</span> getrkx(rt, <span style="color:#ae81ff">0</span>, (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">30</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, x)                                    );
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>) ans <span style="color:#f92672">^=</span> (lans <span style="color:#f92672">=</span> getrkx(rt, <span style="color:#ae81ff">0</span>, (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">30</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, getsum(rt, <span style="color:#ae81ff">0</span>, (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">30</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>              ans <span style="color:#f92672">^=</span> (lans <span style="color:#f92672">=</span> getrkx(rt, <span style="color:#ae81ff">0</span>, (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">30</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, getsum(rt, <span style="color:#ae81ff">0</span>, (<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">30</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, x) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="text-stylecolorrgb0150136-二叉搜索树"><text style="color:rgb(0,150,136)"> 二叉搜索树</h2>
<p>有人问，既然这题标题是“平衡树”，这题怎么修改，才能让这题没法用线段树解决？</p>
<p>其实非常简单，这题是对数字做维护，我们改成维护<code>pair</code>、<code>double</code>、高精度整数，就无法用线段树解决，或者复杂度炸裂。</p>
<p>这时候，我们就要引入一个新算法——二叉搜索树（BST）了。</p>
<h3 id="text-stylecolorrgb0150136-概览"><text style="color:rgb(0,150,136)"> 概览</h3>
<p>正如简介中所说，BST是个左 $&lt;$ 中 $&lt;$ 右（指权值）结构的二叉树。</p>
<p>而这样的结构，就是为了方便插入和删除而设的。</p>
<h3 id="text-stylecolorrgb0150136-初始化"><text style="color:rgb(0,150,136)"> 初始化</h3>
<p>如果给你一个序列，通过合理的方式，可以让BST的深度达到 $O(\log n)$ 级别。</p>
<p>其实现方式很简单，把这个序列从小到大排序，每次选择中间的元素 $\text{mid}$ 作为根，把比 $\text{mid}$ 小的作为左子树，大的作为右子树。</p>
<p>这样就是一个“类线段树结构”，树高一定是 $O(\log n)$ 的。</p>
<h3 id="text-stylecolorrgb0150136-插入节点"><text style="color:rgb(0,150,136)"> 插入节点</h3>
<p>接下来考虑插入。</p>
<p>其实很简单，如果当前节点权值比插入权值大，就递归左儿子，否则递归右儿子。</p>
<p>如果没有，则新建并退出函数。</p>
<h3 id="text-stylecolorrgb0150136-删除节点"><text style="color:rgb(0,150,136)"> 删除节点</h3>
<p>然后考虑删除。</p>
<p>如果删除节点 $x$ 是叶子节点，那么可以直接删除。</p>
<p>否则，如果直接删除 $x$ 的话，就会导致整棵树分裂。</p>
<p>为了防止分裂，我们必须找一个节点出来，来代替节点 $x$，这样就可以直接删除 $x$ 点了。</p>
<p>为了保证BST的性质仍然满足，我们可以找到节点 $x$ 左子树中权值最大的那个，或者右子树中权值最小的。</p>
<blockquote>
<p>找到这个点的话很简单，可以直接暴力。</p>
<p>由于BST要求左子树内的所有权值 $&lt;$ 右子树内的所有权值，所以我们可以贪心。</p>
<p>递归过程中，无脑一直往左/右儿子走，如果都没有则返回。</p></blockquote>
<p>然后，我们把这个节点和 $x$ 交换，并删除此时的 $x$ 点即可。</p>
<h3 id="text-stylecolorrgb0150136-其他四种操作"><text style="color:rgb(0,150,136)"> 其他四种操作</h3>
<p>类似于线段树上二分。</p>
<h3 id="text-stylecolorrgb0150136-复杂度证明"><text style="color:rgb(0,150,136)"> 复杂度证明</h3>
<p>时间复杂度：$O(?)$</p>
<p>看见那个“$?$”就说明我们得证明一下复杂度才能定结论。</p>
<p>可以发现，无论是删除、查询排名、查询前驱后继，这个复杂度其实都是和树高有关的。</p>
<p>而且，似乎插入对树高没什么影响啊，直接 $O(n \log n)$，用啥平衡树。</p>
<p>但是，这种做法复杂度并不是 $O(n \log n)$。</p>
<p>我们考虑一个极限数据。</p>
<p>我们依次插入 $1$、$2$、$3$、$4$、$\dots$、$5 \times 10^4$，这样就会让树高达到 $5 \times 10^4$ 而不是理想的 $\log n$。</p>
<p>这样的话，只要我们 $5 \times 10^4$ 次操作里，每次都查询一下 $5 \times 10^4$（最大数）的前驱，或者 $1$（最小数）的后继。</p>
<p>那么，复杂度就会达到 $O \left( \left( 5 \times 10^4 \right)^2 \right)$，爆炸。</p>
<p>所以我们考虑优化。</p>
<h3 id="text-stylecolorrgb0150136-定期重构"><text style="color:rgb(0,150,136)"> 定期重构</h3>
<p>其实上面的简介里也剧透了一点，就是我们考虑定期重构。</p>
<p>有一种算法叫“替罪羊树”，就是用定期重构来实现定期重构的平衡树，所以定期重构又被我称为“替罪羊树思想”。</p>
<p>而且，定期重构一般是每 $\sqrt n$ 次变化重构一次。</p>
<p>但这题里，只有插入操作会让树高变高，所以我们只要每加入 $\sqrt n$ 个数进行重构即可。</p>
<p>重构就是上面说的“初始化操作”，复杂度是 $O(n)$ 的。</p>
<p>所以总复杂度是 $O(n \sqrt n)$，因为瓶颈在于重构而不是查询。</p>
<p>这下复杂度就是大概率能接受的了。</p>
<h3 id="text-stylecolorrgb0150136-代码-2"><text style="color:rgb(0,150,136)"> 代码</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">做法假了，因为删除操作里，顶替的那个点不一定为叶子节点，目前还没有解决该</span>bug的思路
</span></span></code></pre></div><h2 id="text-stylecolorrgb0150136-treap"><text style="color:rgb(0,150,136)"> Treap</h2>
<p>但这个复杂度还不够优，我们得把它优化成 $O(n \log n)$。</p>
<p>不过我们已经无法在算法上优化了，我们得换一种做法。</p>
<p>我们考虑Treap。</p>
<h3 id="text-stylecolorrgb0150136-概览-1"><text style="color:rgb(0,150,136)"> 概览</h3>
<p>其实Treap就是BST的扩展版。</p>
<p>BST是单单维护权值，但Treap还要维护一个“优先级”。</p>
<p>这个优先级是随机的，这也是它树高的保证。（这个证明过于复杂难懂，这里就不说了）</p>
<p>并且，在简介里也说了，优先级是满足小/大根堆性质的。</p>
<p>正是因为这一点，Treap的结构才是唯一的。（这个容易证明，随便找一个构造方式你就知道为啥了）</p>
<h3 id="text-stylecolorrgb0150136-旋转"><text style="color:rgb(0,150,136)"> 旋转</h3>
<p>（最头疼的地方来了）</p>
<p>不过我们发现，不像BST，Treap的插入并不一定找到一个插入的地方。</p>
<p>所以，我们得尝试变化一下结构。</p>
<p>变化结构的方式被称为“旋转”</p>
<p>传入参数是一个 $x$，我们尝试把 $x$ 平移到 $x$ 的父亲的父亲位置。</p>
<p>这里的“平移”可以这么理解，我们设 $fa$ 为 $x$ 的父亲，那么：</p>
<ul>
<li>如果 $x$ 是 $fa$ 的左儿子，则旋转后 $fa$ 要作为 $x$ 的右儿子。</li>
<li>如果 $x$ 是 $fa$ 的右儿子，则旋转后 $fa$ 要作为 $x$ 的左儿子。</li>
</ul>
<p>但这个旋转也不那么简单。</p>
<p>因为 $x$ 的两个儿子的子树，还有 $fa$ 的某个子树，其排列位置可能会改变。</p>
<p>具体而言，它们会这么变化：</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/c3ld90kn.png" alt=""></p>
<p>这种变化方式可以用代码实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rotate</span>(LL x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(fa(x) <span style="color:#f92672">==</span> rt) rt <span style="color:#f92672">=</span> x;  <span style="color:#75715e">//根节点特判
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL y <span style="color:#f92672">=</span> fa(x), z <span style="color:#f92672">=</span> fa(y), p <span style="color:#f92672">=</span> sp(x);  <span style="color:#75715e">//x的父亲、x的祖父、x是哪个儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sons(y, p) <span style="color:#f92672">=</span> sons(x, <span style="color:#f92672">!</span>p), sons(x, <span style="color:#f92672">!</span>p) <span style="color:#f92672">=</span> y, fa(sons(y, p)) <span style="color:#f92672">=</span> y;  <span style="color:#75715e">//交换子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fa(x) <span style="color:#f92672">=</span> fa(y), fa(y) <span style="color:#f92672">=</span> x;  <span style="color:#75715e">//更换父亲节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    pushup(x), pushup(y);  <span style="color:#75715e">//pushup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(z){  <span style="color:#75715e">//如果x的祖父存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        sons(z, rc(z) <span style="color:#f92672">==</span> y) <span style="color:#f92672">=</span> x;  <span style="color:#75715e">//则变化其的儿子节点为x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pushup(z);  <span style="color:#75715e">//然后重新pushup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>注：</p>
<p>上面图里有两个操作，“左旋（Left Rotation）”和“右旋（Left Rotation）”。</p>
<p>但这里只写了一个函数，有人问这个函数实现的是什么旋？其实这个函数其实既实现了左旋，又实现了右旋。</p>
<p>而这一点怎么理解呢？可以发现，用哪种旋法，只取决于这个点是左还是右儿子。</p>
<p>如果是左儿子，那么就得用右旋，否则用左旋。</p>
<p>所以上面代码既实现了左旋（节点 $x$ 为右儿子），也实现了右旋（节点 $x$ 为左儿子）。</p></blockquote>
<p>在Splay里，会对“旋转”做升级（添加了一个<code>splay</code>操作，但<code>rotate</code>操作没变），这时候会更头疼。</p>
<blockquote>
<p>附：</p>
<p>Treap要维护的信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    LL val;  <span style="color:#75715e">//权值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL pri;  <span style="color:#75715e">//优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL sz;  <span style="color:#75715e">//子树大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL fath;  <span style="color:#75715e">//父亲节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL sons[<span style="color:#ae81ff">2</span>];  <span style="color:#75715e">//两个儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>Treap的<code>#define</code>有：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define val(x) (a[x].val)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define pri(x) (a[x].pri)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define sz(x) (a[x].sz)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define fa(x) (a[x].fath)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define sons(x, p) (a[x].sons[p])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define lc(x) sons(x, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define rc(x) sons(x, 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define sp(x) (rc(fa(x)) == x)  </span><span style="color:#75715e">//x的在哪个儿子上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define pushup(x) (sz(x) = sz(lc(x)) + sz(rc(x)))  </span><span style="color:#75715e">//pushup操作
</span></span></span></code></pre></div><p>这些信息只是为了方便理解代码，不用全抄。</p></blockquote>
<h3 id="text-stylecolorrgb0150136-插入"><text style="color:rgb(0,150,136)"> 插入</h3>
<p>在插入操作里，我们先忽略优先级，按BST的性质找到插入点。</p>
<p>然后，从该点遍历到根。</p>
<p>遍历到某个点的时候，如果该点的优先级比它的父亲的要小（假设要求优先级满足大根堆性质）。</p>
<p>那么，我们就得调用旋转操作，把当前点旋上去。</p>
<p>由于Treap的结构唯一且期望高度为 $O(\log n)$，并且最后整棵树必然满足Treap性质。</p>
<p>所以，插入操作不会对树高产生影响。</p>
<h3 id="text-stylecolorrgb0150136-删除"><text style="color:rgb(0,150,136)"> 删除</h3>
<p>删除的话，如果是叶子节点那么直接删。</p>
<p>否则，我们找到删除节点编号，并从这个地方开始往下递归。</p>
<p>每次我们看当前点的两个子节点，选择优先级较大的点，将其旋转到父亲那里，并递归到这个子节点。</p>
<p>这样不断旋转，就会使得删除节点为叶子，就直接删即可。</p>
<p>最后树结构满足Treap性质，所以不会对树高产生影响。</p>
<h3 id="text-stylecolorrgb0150136-其他四种操作-1"><text style="color:rgb(0,150,136)"> 其他四种操作</h3>
<p>可参考BST。</p>
<h3 id="text-stylecolorrgb0150136-复杂度"><text style="color:rgb(0,150,136)"> 复杂度</h3>
<p>复杂度还是与树高有关。</p>
<p>由于优先级随机，期望树高是 $O(\log n)$，所以复杂度就是 $O(q \log n)$。</p>
<h3 id="text-stylecolorrgb0150136-代码-3"><text style="color:rgb(0,150,136)"> 代码</h3>
<p>不合并相同权值版：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">递交到</span>P6136即可AC
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> LL N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>, Q <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e6</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>random_device rand_seed;
</span></span><span style="display:flex;"><span>mt19937_64 <span style="color:#a6e22e">_rand</span>(time(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">^</span> clock() <span style="color:#f92672">^</span> rand_seed());
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define random(l, r) (_rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>LL n, qc;
</span></span><span style="display:flex;"><span>LL opt;
</span></span><span style="display:flex;"><span>LL x;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    LL val;  <span style="color:#75715e">//权值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL pri;  <span style="color:#75715e">//优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL sz;  <span style="color:#75715e">//子树大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL ma;  <span style="color:#75715e">//子树内权值最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL fath;  <span style="color:#75715e">//父亲节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL sons[<span style="color:#ae81ff">2</span>];  <span style="color:#75715e">//两个儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define val(x) (a[x].val)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define pri(x) (a[x].pri)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define sz(x) (a[x].sz)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ma(x) (a[x].ma)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define fa(x) (a[x].fath)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define sons(x, p) (a[x].sons[p])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define lc(x) sons(x, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define rc(x) sons(x, 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Node a[N <span style="color:#f92672">+</span> Q];
</span></span><span style="display:flex;"><span>LL ind;
</span></span><span style="display:flex;"><span>LL rt;  <span style="color:#75715e">//由于涉及交换，所以这里要专门存储根节点编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> flag <span style="color:#f92672">=</span> false;  <span style="color:#75715e">//根节点是否被删掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define sp(x) (rc(fa(x)) == x)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define pushup(x) (sz(x) = sz(lc(x)) + 1 + sz(rc(x)), ma(x) = max({ma(lc(x)), val(x), ma(rc(x))}))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rotate</span>(LL x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(fa(x) <span style="color:#f92672">==</span> rt) rt <span style="color:#f92672">=</span> x;  <span style="color:#75715e">//如果是把某个根节点的儿子rotate上去，则这个儿子要作为新的根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL y <span style="color:#f92672">=</span> fa(x), z <span style="color:#f92672">=</span> fa(y), p <span style="color:#f92672">=</span> sp(x);  <span style="color:#75715e">//x的父亲、x的祖父、x是哪个儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sons(y, p) <span style="color:#f92672">=</span> sons(x, <span style="color:#f92672">!</span>p), sons(x, <span style="color:#f92672">!</span>p) <span style="color:#f92672">=</span> y, fa(sons(y, p)) <span style="color:#f92672">=</span> y;  <span style="color:#75715e">//交换子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fa(x) <span style="color:#f92672">=</span> fa(y), fa(y) <span style="color:#f92672">=</span> x;  <span style="color:#75715e">//更换父亲节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    pushup(y), pushup(x) <span style="color:#75715e">/* 这里要注意顺序，先对y点做pushup，然后才对其父亲x做pushup，这样才能让信息传达正确 */</span>;  <span style="color:#75715e">//pushup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(z){  <span style="color:#75715e">//如果x的祖父存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        sons(z, rc(z) <span style="color:#f92672">==</span> y) <span style="color:#f92672">=</span> x;  <span style="color:#75715e">//则变化其的儿子节点为x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pushup(z);  <span style="color:#75715e">//然后重新pushup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">newnode</span>(LL v, LL fa){
</span></span><span style="display:flex;"><span>    ind<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    val(ind) <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>    pri(ind) <span style="color:#f92672">=</span> random(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1e18</span>);
</span></span><span style="display:flex;"><span>    sz(ind) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    ma(ind) <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>    fa(ind) <span style="color:#f92672">=</span> fa;
</span></span><span style="display:flex;"><span>    lc(ind) <span style="color:#f92672">=</span> rc(ind) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ind;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(LL x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(ind <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){ rt <span style="color:#f92672">=</span> newnode(x, <span style="color:#ae81ff">0</span>); <span style="color:#66d9ef">return</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(flag){ ind <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, flag <span style="color:#f92672">=</span> false, rt <span style="color:#f92672">=</span> newnode(x, <span style="color:#ae81ff">0</span>); <span style="color:#66d9ef">return</span>; }
</span></span><span style="display:flex;"><span>    LL p <span style="color:#f92672">=</span> rt, ip <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>        LL <span style="color:#f92672">&amp;</span>to <span style="color:#f92672">=</span> (x <span style="color:#f92672">&lt;=</span> val(p) <span style="color:#f92672">?</span> lc(p) <span style="color:#f92672">:</span> rc(p));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(to <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){ ip <span style="color:#f92672">=</span> to <span style="color:#f92672">=</span> newnode(x, p); <span style="color:#66d9ef">break</span>; }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> p <span style="color:#f92672">=</span> to;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(ip <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(pri(ip) <span style="color:#f92672">&lt;</span> <span style="color:#75715e">/* 如果要求pri为大根堆，这里应该写&gt;，但代码里要求pri为小根堆 */</span> pri(fa(ip)))
</span></span><span style="display:flex;"><span>            rotate(ip);  <span style="color:#75715e">//这里rotate之后，底下不用把ip再设成fa(ip)，因为rotate已经把fa值更新了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(ip) pushup(ip), ip <span style="color:#f92672">=</span> fa(ip);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delnode</span>(LL x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">==</span> rt) flag <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    val(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    pri(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    sz(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    ma(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    sons(fa(x), sp(x)) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    fa(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    lc(x) <span style="color:#f92672">=</span> rc(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">del</span>(LL x){
</span></span><span style="display:flex;"><span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>        LL lc <span style="color:#f92672">=</span> lc(p), rc <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">==</span> val(p)) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">&lt;</span> val(p)) p <span style="color:#f92672">=</span> lc;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>                p <span style="color:#f92672">=</span> rc;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(lc(p) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> rc(p) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        LL t <span style="color:#f92672">=</span> fa(p);
</span></span><span style="display:flex;"><span>        delnode(p);
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(p) pushup(p), p <span style="color:#f92672">=</span> fa(p);  <span style="color:#75715e">//这里要记得pushup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//这里要return，因为如果涉及到这种情况，那么执行完while循环，p一定为0，这时候下面代码就很可能会死循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//具体原因不详，但能大概确定是0有儿子导致的死循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>        LL lc <span style="color:#f92672">=</span> lc(p), rc <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//还是，下面p不用专门设成lc或rc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(lc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) rotate(lc);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(lc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) rotate(rc);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(pri(lc) <span style="color:#f92672">&gt;=</span> pri(rc)) rotate(lc);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>                   rotate(rc);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    LL t <span style="color:#f92672">=</span> fa(p);
</span></span><span style="display:flex;"><span>    delnode(p);
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p) pushup(p), p <span style="color:#f92672">=</span> fa(p);  <span style="color:#75715e">//这里要记得pushup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">getsm</span>(LL x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(ind <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> flag) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">//此处要判断树为空的情况，这时候要及时返回0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    LL ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(val(p) <span style="color:#f92672">&lt;=</span> x) ret<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        LL lc <span style="color:#f92672">=</span> lc(p), rc <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(lc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) p <span style="color:#f92672">=</span> lc;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(lc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) p <span style="color:#f92672">=</span> rc;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">&lt;</span> ma(lc)) p <span style="color:#f92672">=</span> lc;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> ret <span style="color:#f92672">+=</span> sz(lc), p <span style="color:#f92672">=</span> rc;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">getrk</span>(LL x){
</span></span><span style="display:flex;"><span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>        LL lc <span style="color:#f92672">=</span> lc(p), rc <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(lc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> val(p);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">==</span> sz(lc) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> val(p);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;=</span> sz(lc)) p <span style="color:#f92672">=</span> lc;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(lc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> val(p);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(<span style="color:#ae81ff">2</span> <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;=</span> sz(rc) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) x<span style="color:#f92672">--</span>, p <span style="color:#f92672">=</span> rc;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">&lt;=</span> sz(lc)) p <span style="color:#f92672">=</span> lc;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">==</span> sz(lc) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">return</span> val(p);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> x <span style="color:#f92672">-=</span> sz(lc) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, p <span style="color:#f92672">=</span> rc;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL ans;
</span></span><span style="display:flex;"><span>LL lans;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    rd(n), rd(qc);
</span></span><span style="display:flex;"><span>    rep(i, <span style="color:#ae81ff">1</span>, n){
</span></span><span style="display:flex;"><span>        rd(x);
</span></span><span style="display:flex;"><span>        add(x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    rep(i, <span style="color:#ae81ff">1</span>, qc){
</span></span><span style="display:flex;"><span>        rd(opt), rd(x);
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">^=</span> lans;
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) add(x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) del(x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>) ans <span style="color:#f92672">^=</span> (lans <span style="color:#f92672">=</span> getsm(x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>   );
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>) ans <span style="color:#f92672">^=</span> (lans <span style="color:#f92672">=</span> getrk(x)           );
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>) ans <span style="color:#f92672">^=</span> (lans <span style="color:#f92672">=</span> getrk(getsm(x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>              ans <span style="color:#f92672">^=</span> (lans <span style="color:#f92672">=</span> getrk(getsm(x) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>合并相同权值版：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">递交到</span>P6136即可AC
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> LL N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>, Q <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e6</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>random_device rand_seed;
</span></span><span style="display:flex;"><span>mt19937_64 <span style="color:#a6e22e">_rand</span>(time(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">^</span> clock() <span style="color:#f92672">^</span> rand_seed());
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define random(l, r) (_rand() % ((LL)(r) - (LL)(l) + 1) + (LL)(l))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>LL n, qc;
</span></span><span style="display:flex;"><span>LL opt;
</span></span><span style="display:flex;"><span>LL x;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    LL val;  <span style="color:#75715e">//权值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL cnt;  <span style="color:#75715e">//权值出现次数（这也就意味着我们把相同的权值都合并到一个点上了）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL pri;  <span style="color:#75715e">//优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL sz;  <span style="color:#75715e">//子树大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL ma;  <span style="color:#75715e">//子树内权值最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL fath;  <span style="color:#75715e">//父亲节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL sons[<span style="color:#ae81ff">2</span>];  <span style="color:#75715e">//两个儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define val(x) (a[x].val)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define vcnt(x) (a[x].cnt)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define pri(x) (a[x].pri)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define sz(x) (a[x].sz)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ma(x) (a[x].ma)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define fa(x) (a[x].fath)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define sons(x, p) (a[x].sons[p])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define lc(x) sons(x, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define rc(x) sons(x, 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Node a[N <span style="color:#f92672">+</span> Q];
</span></span><span style="display:flex;"><span>LL ind;
</span></span><span style="display:flex;"><span>LL rt;  <span style="color:#75715e">//由于涉及交换，所以这里要专门存储根节点编号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> flag <span style="color:#f92672">=</span> false;  <span style="color:#75715e">//根节点是否被删掉
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define sp(x) (rc(fa(x)) == x)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define pushup(x) (sz(x) = sz(lc(x)) + vcnt(x) + sz(rc(x)), ma(x) = max({ma(lc(x)), val(x), ma(rc(x))}))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rotate</span>(LL x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(fa(x) <span style="color:#f92672">==</span> rt) rt <span style="color:#f92672">=</span> x;  <span style="color:#75715e">//如果是把某个根节点的儿子rotate上去，则这个儿子要作为新的根节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL y <span style="color:#f92672">=</span> fa(x), z <span style="color:#f92672">=</span> fa(y), p <span style="color:#f92672">=</span> sp(x);  <span style="color:#75715e">//x的父亲、x的祖父、x是哪个儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    sons(y, p) <span style="color:#f92672">=</span> sons(x, <span style="color:#f92672">!</span>p), sons(x, <span style="color:#f92672">!</span>p) <span style="color:#f92672">=</span> y, fa(sons(y, p)) <span style="color:#f92672">=</span> y;  <span style="color:#75715e">//交换子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    fa(x) <span style="color:#f92672">=</span> fa(y), fa(y) <span style="color:#f92672">=</span> x;  <span style="color:#75715e">//更换父亲节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    pushup(y), pushup(x) <span style="color:#75715e">/* 这里要注意顺序，先对y点做pushup，然后才对其父亲x做pushup，这样才能让信息传达正确 */</span>;  <span style="color:#75715e">//pushup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(z){  <span style="color:#75715e">//如果x的祖父存在
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        sons(z, rc(z) <span style="color:#f92672">==</span> y) <span style="color:#f92672">=</span> x;  <span style="color:#75715e">//则变化其的儿子节点为x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        pushup(z);  <span style="color:#75715e">//然后重新pushup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">newnode</span>(LL v, LL fa){
</span></span><span style="display:flex;"><span>    ind<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    val(ind) <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>    vcnt(ind) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    pri(ind) <span style="color:#f92672">=</span> random(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1e18</span>);
</span></span><span style="display:flex;"><span>    sz(ind) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    ma(ind) <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>    fa(ind) <span style="color:#f92672">=</span> fa;
</span></span><span style="display:flex;"><span>    lc(ind) <span style="color:#f92672">=</span> rc(ind) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ind;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(LL x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(ind <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){ rt <span style="color:#f92672">=</span> newnode(x, <span style="color:#ae81ff">0</span>); <span style="color:#66d9ef">return</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(flag){ ind <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, flag <span style="color:#f92672">=</span> false, rt <span style="color:#f92672">=</span> newnode(x, <span style="color:#ae81ff">0</span>); <span style="color:#66d9ef">return</span>; }
</span></span><span style="display:flex;"><span>    LL p <span style="color:#f92672">=</span> rt, ip <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">==</span> val(p)){
</span></span><span style="display:flex;"><span>            vcnt(p)<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(p) sz(p)<span style="color:#f92672">++</span>, p <span style="color:#f92672">=</span> fa(p);  <span style="color:#75715e">//这里要把sz值一并变化，并且不止变化p
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        LL <span style="color:#f92672">&amp;</span>to <span style="color:#f92672">=</span> (x <span style="color:#f92672">&lt;</span> val(p) <span style="color:#f92672">?</span> lc(p) <span style="color:#f92672">:</span> rc(p));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(to <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){ ip <span style="color:#f92672">=</span> to <span style="color:#f92672">=</span> newnode(x, p); <span style="color:#66d9ef">break</span>; }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> p <span style="color:#f92672">=</span> to;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(ip <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(pri(ip) <span style="color:#f92672">&lt;</span> <span style="color:#75715e">/* 如果要求pri为大根堆，这里应该写&lt;，但代码里要求pri为小根堆 */</span> pri(fa(ip)))
</span></span><span style="display:flex;"><span>            rotate(ip);  <span style="color:#75715e">//这里rotate之后，底下不用把ip再设成fa(ip)，因为rotate已经把fa值更新了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(ip) pushup(ip), ip <span style="color:#f92672">=</span> fa(ip);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delnode</span>(LL x){
</span></span><span style="display:flex;"><span>    val(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    vcnt(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    pri(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    sz(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    ma(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    sons(fa(x), sp(x)) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    fa(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    lc(x) <span style="color:#f92672">=</span> rc(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">del</span>(LL x){
</span></span><span style="display:flex;"><span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>        LL lc <span style="color:#f92672">=</span> lc(p), rc <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">==</span> val(p)) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">&lt;</span> val(p)) p <span style="color:#f92672">=</span> lc;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>                p <span style="color:#f92672">=</span> rc;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(vcnt(p) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        vcnt(p)<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(p) sz(p)<span style="color:#f92672">--</span>, p <span style="color:#f92672">=</span> fa(p);  <span style="color:#75715e">//这里要把sz值一并变化，并且不止变化p
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(lc(p) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> rc(p) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        LL t <span style="color:#f92672">=</span> fa(p);
</span></span><span style="display:flex;"><span>        delnode(p);
</span></span><span style="display:flex;"><span>        p <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(p) pushup(p), p <span style="color:#f92672">=</span> fa(p);  <span style="color:#75715e">//这里要记得pushup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//这里要return，因为如果涉及到这种情况，那么执行完while循环，p一定为0，这时候下面代码就很可能会死循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//具体原因不详，但能大概确定是0有儿子导致的死循环
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>        LL lc <span style="color:#f92672">=</span> lc(p), rc <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//还是，下面p不用专门设成lc或rc
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(lc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) rotate(lc);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(lc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) rotate(rc);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(pri(lc) <span style="color:#f92672">&gt;=</span> pri(rc)) rotate(lc);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>                   rotate(rc);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    LL t <span style="color:#f92672">=</span> fa(p);
</span></span><span style="display:flex;"><span>    delnode(p);
</span></span><span style="display:flex;"><span>    p <span style="color:#f92672">=</span> t;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p) pushup(p), p <span style="color:#f92672">=</span> fa(p);  <span style="color:#75715e">//这里要记得pushup
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">getsm</span>(LL x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(ind <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> flag) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">//此处要判断树为空的情况，这时候要及时返回0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    LL ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(val(p) <span style="color:#f92672">&lt;=</span> x) ret <span style="color:#f92672">+=</span> vcnt(p);
</span></span><span style="display:flex;"><span>        LL lc <span style="color:#f92672">=</span> lc(p), rc <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(lc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) p <span style="color:#f92672">=</span> lc;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(lc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) p <span style="color:#f92672">=</span> rc;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">&lt;</span> ma(lc)) p <span style="color:#f92672">=</span> lc;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> ret <span style="color:#f92672">+=</span> sz(lc), p <span style="color:#f92672">=</span> rc;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">getrk</span>(LL x){
</span></span><span style="display:flex;"><span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>        LL lc <span style="color:#f92672">=</span> lc(p), rc <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(lc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;=</span> vcnt(p)) <span style="color:#66d9ef">return</span> val(p);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(rc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;=</span> sz(lc)) p <span style="color:#f92672">=</span> lc;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(sz(lc) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;=</span> sz(lc) <span style="color:#f92672">+</span> vcnt(p)) <span style="color:#66d9ef">return</span> val(p);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(lc <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;=</span> vcnt(p)) <span style="color:#66d9ef">return</span> val(p);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(vcnt(p) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;=</span> vcnt(p) <span style="color:#f92672">+</span> sz(rc)) x <span style="color:#f92672">-=</span> vcnt(p), p <span style="color:#f92672">=</span> rc;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;=</span> sz(lc)) p <span style="color:#f92672">=</span> lc;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(sz(lc) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> x <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;=</span> sz(lc) <span style="color:#f92672">+</span> vcnt(p)) <span style="color:#66d9ef">return</span> val(p);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span> x <span style="color:#f92672">-=</span> sz(lc) <span style="color:#f92672">+</span> vcnt(p), p <span style="color:#f92672">=</span> rc;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL ans;
</span></span><span style="display:flex;"><span>LL lans;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    rd(n), rd(qc);
</span></span><span style="display:flex;"><span>    rep(i, <span style="color:#ae81ff">1</span>, n){
</span></span><span style="display:flex;"><span>        rd(x);
</span></span><span style="display:flex;"><span>        add(x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    rep(i, <span style="color:#ae81ff">1</span>, qc){
</span></span><span style="display:flex;"><span>        rd(opt), rd(x);
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">^=</span> lans;
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) add(x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) del(x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>) ans <span style="color:#f92672">^=</span> (lans <span style="color:#f92672">=</span> getsm(x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>   );
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>) ans <span style="color:#f92672">^=</span> (lans <span style="color:#f92672">=</span> getrk(x)           );
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>) ans <span style="color:#f92672">^=</span> (lans <span style="color:#f92672">=</span> getrk(getsm(x <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>              ans <span style="color:#f92672">^=</span> (lans <span style="color:#f92672">=</span> getrk(getsm(x) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="text-stylecolorrgb0150136-splay"><text style="color:rgb(0,150,136)"> Splay</h2>
<p>不过如果出现更多种类的修改、查询呢？我们可以考虑Splay。</p>
<h3 id="text-stylecolorrgb0150136-概览-2"><text style="color:rgb(0,150,136)"> 概览</h3>
<p>接下来是Splay，其实Splay能解决所有Treap能解决的问题，同时还可以解决区间修改、翻转、查询问题。</p>
<p>不过其缺点上面也说了，非常难写、细节贼多、非常难理解、复杂度很难证明，不过这些缺点是因人而异的。</p>
<p>并且，在比赛里，能用权值线段树就用，不能用就用Treap，如果仍然不能用再用Splay。</p>
<p>因为Splay本身常数就不算小，并且有时候写挂一个小点可能连对拍都拍不出来。</p>
<h3 id="text-stylecolorrgb0150136-旋转-1"><text style="color:rgb(0,150,136)"> 旋转</h3>
<p>上面剧透了一下，就是Splay里会对旋转做升级，这里说一下是如何升级的。</p>
<p>其实上面说的添加的<code>splay</code>操作，并不是什么很高深的操作，其原理就是把传入的那个点，一路旋转到根。</p>
<p>我们假设传入的点为 $x$ 号点，且设：</p>
<ul>
<li>$y$ 为 $x$ 的父亲</li>
<li>$z$ 为 $x$ 的祖父，即 $y$ 的父亲</li>
</ul>
<p>那么我们就考虑先通过若干次<code>rotate</code>操作，让 $x$ 在 $x$、$y$、$z$ 三点中深度最浅。</p>
<p>我们可以分两种情况：</p>
<ol>
<li>$x$ 和 $y$ 是一个儿子方向：
<img src="https://img-blog.csdnimg.cn/7737e70b692d41ccae61f9d280ec55e6.png" alt=""></li>
<li>$x$ 和 $y$ 不是一个儿子方向：
<img src="https://img-blog.csdnimg.cn/7085396ed295438d898065b98e4dc50c.png" alt=""></li>
</ol>
<p>（图源网络，在<a href="https://blog.csdn.net/w75779/article/details/127627358">这篇博客</a>里）</p>
<p>不过前提 $z$ 是存在的。</p>
<p>这样，我们就可以写出<code>splay</code>操作的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">splay</span>(LL x){  <span style="color:#75715e">//将一个点x旋转到根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//如果x和fa（x的父亲）的子节点关系一致，则旋转fa后旋转x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//否则，旋转两次x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(LL fa <span style="color:#f92672">=</span> fa(x);fa;rotate(x) <span style="color:#75715e">/* rotate完后不用把x赋值为其父亲 */</span>, fa <span style="color:#f92672">=</span> fa(x))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(fa(fa))
</span></span><span style="display:flex;"><span>            rotate(sp(x) <span style="color:#f92672">==</span> sp(fa) <span style="color:#f92672">?</span> fa : x);
</span></span><span style="display:flex;"><span>    rt <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>（提前剧透一下，在底下<code>splay</code>操作的实现会变）</p>
<h3 id="text-stylecolorrgb0150136-插入-1"><text style="color:rgb(0,150,136)"> 插入</h3>
<p>如果树为空，直接新建节点加入树中即可。</p>
<p>否则我们仿照Treap的“合并相同权值版本”代码实现即可。</p>
<p>不过注意，在找到加入位置后，一定要把插入的位置旋转到根。</p>
<p>放代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(LL x){  <span style="color:#75715e">//添加数x（且将数x旋转到根）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//特判树为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(rt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        ind <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        rt <span style="color:#f92672">=</span> newnode(x, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//找到添加点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果有相同的权值，直接cnt++即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(val(p) <span style="color:#f92672">==</span> x){
</span></span><span style="display:flex;"><span>            cnt(p)<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            pushup(fa(p));
</span></span><span style="display:flex;"><span>            splay(p);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//否则找到去哪个儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        LL <span style="color:#f92672">&amp;</span>to <span style="color:#f92672">=</span> sons(p, x <span style="color:#f92672">&gt;</span> <span style="color:#75715e">/* 这里是大于 */</span> val(p));
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果该儿子没有
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(to <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//则新增
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            to <span style="color:#f92672">=</span> newnode(x, p);
</span></span><span style="display:flex;"><span>            pushup(p);
</span></span><span style="display:flex;"><span>            splay(to);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//否则走到该儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }<span style="color:#66d9ef">else</span> p <span style="color:#f92672">=</span> to;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="text-stylecolorrgb0150136-查询x的排名"><text style="color:rgb(0,150,136)"> 查询x的排名</h3>
<p>仿照Treap的实现即可。</p>
<p>这里也要把我们找到的点旋转到根。</p>
<p>有人问为啥每次都要旋转，有两个原因：</p>
<ol>
<li>有时候旋转到根有别用。</li>
<li>旋转操作是复杂度的保证，这也就意味着旋转操作多多益善，少了可能会挂。</li>
</ol>
<p>放代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>LL <span style="color:#a6e22e">getrnk</span>(LL x){  <span style="color:#75715e">//查询数x的排名（且将数x旋转到根）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    LL ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果x比当前权值小，则说明答案都在左子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">&lt;</span> val(p)) p <span style="color:#f92672">=</span> lc(p);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//否则就是整个左子树、当前节点，和部分右子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//将左子树整个累加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ret <span style="color:#f92672">+=</span> sz(lc(p));
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果找到了x所在节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">==</span> val(p)){
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//则把该节点旋转到根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                splay(p);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//此时的ret为比x小的元素个数，所以要加1后返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> ret <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//否则当前节点也在答案范围内
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ret <span style="color:#f92672">+=</span> cnt(p);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//去右儿子更新答案
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            p <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="text-stylecolorrgb0150136-查询排名为x的数"><text style="color:rgb(0,150,136)"> 查询排名为x的数</h3>
<p>差不多的思路。</p>
<p>还是要旋转到根。</p>
<p>（剧透一下，看到底下就会发现，<code>splay</code>操作不能放到函数内实现了）</p>
<p>放代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>LL <span style="color:#a6e22e">getkth</span>(LL x){  <span style="color:#75715e">//查询第x名的数（且将该数旋转到根）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果左儿子存在，且x比左儿子大小要小（或等于），则说明答案在左儿子内
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(lc(p) <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;=</span> sz(lc(p))) p <span style="color:#f92672">=</span> lc(p);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//否则就在当前节点，或者右子树内
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//先假设在右子树内
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            x <span style="color:#f92672">-=</span> sz(lc(p)) <span style="color:#f92672">+</span> cnt(p);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果减之后比0小，则答案一定是当前节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//旋转到根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                splay(p);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> val(p);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//否则，就在右子树内
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            p <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="text-stylecolorrgb0150136-查询x的前驱"><text style="color:rgb(0,150,136)"> 查询x的前驱</h3>
<p>先把 $x$ 插入，此时 $x$ 已经默认旋转到根了。</p>
<p>于是我们跳左儿子，然后不断跳右儿子即可。</p>
<p>找到位置之后，<code>splay</code>到根即可。</p>
<p>放代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>LL <span style="color:#a6e22e">getpre</span>(LL x){  <span style="color:#75715e">//查询数x的前驱节点编号（且将前驱旋转到根，保证在调用前x一定存在于树中，且是作为根出现）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//保证是根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//先向左（走到左儿子内）一下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> lc(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果左儿子不存在，就说明无解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(p <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) exit(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//否则，无脑往右走（走到右儿子内）即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(rc(p)) p <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//直到没有右儿子的时候，就旋转
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    splay(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//并返回p节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="text-stylecolorrgb0150136-查询x的后继"><text style="color:rgb(0,150,136)"> 查询x的后继</h3>
<p>类似的，只不过是先跳右儿子，然后跳左儿子。</p>
<p>还是要旋转到根。</p>
<p>放代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>LL <span style="color:#a6e22e">getnxt</span>(LL x){  <span style="color:#75715e">//查询数x的后继节点编号（且将后继旋转到根，保证在调用前x一定存在于树中，且是作为根出现）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//保证是根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//先向右（走到右儿子内）一下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果右儿子不存在，就说明无解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(p <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) exit(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//否则，无脑往左走（走到左儿子内）即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(lc(p)) p <span style="color:#f92672">=</span> lc(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//直到没有左儿子的时候，就旋转
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    splay(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//并返回p节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="text-stylecolorrgb0150136-删除-1"><text style="color:rgb(0,150,136)"> 删除</h3>
<p>删除操作最后讲，是因为删除涉及到上面的操作。</p>
<p>我们首先找到删除的数（假设为 $x$）所在位置，然后把这个位置旋转到根。</p>
<p>之后，如果我们发现 $x$ 出现过不止一次，就直接把出现次数自减即可。</p>
<p>否则，我们分类讨论：</p>
<ul>
<li>如果此时的根（数 $x$）没有任何儿子：
<ul>
<li>那么就说明整个树内就只有一个点，直接删除即可。</li>
</ul>
</li>
<li>如果只有左儿子：
<ul>
<li>直接把左儿子当根即可。</li>
</ul>
</li>
<li>如果只有右儿子：
<ul>
<li>直接把右儿子当根即可。</li>
</ul>
</li>
<li>如果左右儿子都有：
<ul>
<li>则我们找到数 $x$ 的前驱。</li>
<li>此时前驱就默认旋转到根了，且数 $x$ 是作为根节点的右儿子的。</li>
<li>并且根节点的右儿子（数 $x$）是没有左儿子的，显然。</li>
<li>于是我们把数 $x$ 的右儿子街道根节点上即可。</li>
</ul>
</li>
</ul>
<p>于是即可写出代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">del</span>(LL x){  <span style="color:#75715e">//删除数x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//找到删除位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) exit(<span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//找到了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(val(p) <span style="color:#f92672">==</span> x) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//继续跳儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p <span style="color:#f92672">=</span> sons(p, x <span style="color:#f92672">&gt;</span> <span style="color:#75715e">/* 这里是大于 */</span> val(p));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//把删除位置旋转到根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    splay(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果有多于一个权值为x的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(cnt(rt) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//则直接cnt--即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        cnt(rt)<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        pushup(rt);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果根没有左右儿子（整棵树就只有rt一个点）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(lc(rt) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> rc(rt) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        delnode(rt);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果根只有左儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(rc(rt) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//则拿左儿子作为根，并删除原根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        LL t <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>        rt <span style="color:#f92672">=</span> lc(rt);
</span></span><span style="display:flex;"><span>        fa(rt) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        delnode(t);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果根只有右儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(lc(rt) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//则拿右儿子作为根，并删除原根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        LL t <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>        rt <span style="color:#f92672">=</span> rc(rt);
</span></span><span style="display:flex;"><span>        fa(rt) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        delnode(t);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果左右儿子都有
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//则把此时根节点的前驱旋转到根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        LL t <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>        getpre(val(rt));
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//把旧根删掉即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//此时旧根t一定是新根rt的右儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//并且不可能存在权值在val(t)与val(rt)之间（不包括两端点val(t)和val(rt)的值）的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//这也就意味着此时t没有左儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//只用把右儿子连到新根上去即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        rc(rt) <span style="color:#f92672">=</span> rc(t);
</span></span><span style="display:flex;"><span>        fa(rc(rt)) <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>        fa(t) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">//为了防止在delnode的时候把此时的根（t的父亲rt）的某个儿子清零，这里要把t的父亲指向0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        delnode(t <span style="color:#75715e">/* BBE++，原为rt */</span>);
</span></span><span style="display:flex;"><span>        pushup(rt);  <span style="color:#75715e">//并更新此时rt的信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="text-stylecolorrgb0150136-复杂度-1"><text style="color:rgb(0,150,136)"> 复杂度</h3>
<p>这个复杂度是可以证明的，其均摊复杂度为 $O(\log n)$，其中 $n$ 为节点数。</p>
<blockquote>
<p>证明：</p>
<p><em>（暑假的时候补）</em></p></blockquote>
<p>不过有时候少旋转了，可能会导致复杂度增加，所以建议比赛的时候（特别是OI赛制比赛）造几个边界数据看是否能过。</p>
<h3 id="text-stylecolorrgb0150136-代码-4"><text style="color:rgb(0,150,136)"> 代码</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">递交到</span>P3369即可AC
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> LL Q <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL q;
</span></span><span style="display:flex;"><span>LL opt, x;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//对于单点而言
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL val;  <span style="color:#75715e">//节点权值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL cnt;  <span style="color:#75715e">//权值出现次数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//对于邻边而言
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL fa;  <span style="color:#75715e">//父亲节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL sons[<span style="color:#ae81ff">2</span>];  <span style="color:#75715e">//两个儿子节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//对于子树而言
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL sz;  <span style="color:#75715e">//子树大小
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define val(x) (a[x].val)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define cnt(x) (a[x].cnt)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define fa(x) (a[x].fa)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define sons(x, p) (a[x].sons[p])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define lc(x) sons(x, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define rc(x) sons(x, 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define sz(x) (a[x].sz)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Node a[Q];  <span style="color:#75715e">//所有节点的信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL ind;  <span style="color:#75715e">//目前编号到几了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL rt;  <span style="color:#75715e">//根节点编号（由于有删除、旋转操作，所以根会不断变化）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define sp(x) (rc(fa(x)) == x)  </span><span style="color:#75715e">//x是哪个儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define pushup(x) (sz(x) = sz(lc(x)) + cnt(x) + sz(rc(x)))  </span><span style="color:#75715e">//上传信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL <span style="color:#a6e22e">newnode</span>(LL v, LL fa){  <span style="color:#75715e">//新增一个权值为v、父亲节点为fa的点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ind<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    val(ind) <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>    cnt(ind) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    fa(ind) <span style="color:#f92672">=</span> fa;
</span></span><span style="display:flex;"><span>    lc(ind) <span style="color:#f92672">=</span> rc(ind) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    sz(ind) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ind;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">delnode</span>(LL x){  <span style="color:#75715e">//删除节点x（如果x为根，则将根编号赋值为0）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">==</span> rt) rt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    val(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    cnt(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    sons(fa(x), sp(x)) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    fa(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    lc(x) <span style="color:#f92672">=</span> rc(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    sz(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rotate</span>(LL x){  <span style="color:#75715e">//旋转操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL y <span style="color:#f92672">=</span> fa(x), z <span style="color:#f92672">=</span> fa(y), p <span style="color:#f92672">=</span> sp(x);
</span></span><span style="display:flex;"><span>    sons(y, p) <span style="color:#f92672">=</span> sons(x, <span style="color:#f92672">!</span>p), sons(x, <span style="color:#f92672">!</span>p) <span style="color:#f92672">=</span> y, fa(sons(y, p)) <span style="color:#f92672">=</span> y;
</span></span><span style="display:flex;"><span>    fa(x) <span style="color:#f92672">=</span> fa(y), fa(y) <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>    pushup(y), pushup(x);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(z){
</span></span><span style="display:flex;"><span>        sons(z, rc(z) <span style="color:#f92672">==</span> y) <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>        pushup(z);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">splay</span>(LL x){  <span style="color:#75715e">//将一个点x旋转到根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//如果x和fa（x的父亲）的子节点关系一致，则旋转fa后旋转x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//否则，旋转两次x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(LL fa <span style="color:#f92672">=</span> fa(x);fa;rotate(x) <span style="color:#75715e">/* rotate完后不用把x赋值为其父亲 */</span>, fa <span style="color:#f92672">=</span> fa(x))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(fa(fa))
</span></span><span style="display:flex;"><span>            rotate(sp(x) <span style="color:#f92672">==</span> sp(fa) <span style="color:#f92672">?</span> fa : x);
</span></span><span style="display:flex;"><span>    rt <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add</span>(LL x){  <span style="color:#75715e">//添加数x（且将数x旋转到根）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//特判树为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(rt <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        ind <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        rt <span style="color:#f92672">=</span> newnode(x, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//找到添加点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果有相同的权值，直接cnt++即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(val(p) <span style="color:#f92672">==</span> x){
</span></span><span style="display:flex;"><span>            cnt(p)<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            pushup(fa(p));
</span></span><span style="display:flex;"><span>            splay(p);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//否则找到去哪个儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        LL <span style="color:#f92672">&amp;</span>to <span style="color:#f92672">=</span> sons(p, x <span style="color:#f92672">&gt;</span> <span style="color:#75715e">/* 这里是大于 */</span> val(p));
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果该儿子没有
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(to <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//则新增
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            to <span style="color:#f92672">=</span> newnode(x, p);
</span></span><span style="display:flex;"><span>            pushup(p);
</span></span><span style="display:flex;"><span>            splay(to);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//否则走到该儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }<span style="color:#66d9ef">else</span> p <span style="color:#f92672">=</span> to;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">getrnk</span>(LL x){  <span style="color:#75715e">//查询数x的排名（且将数x旋转到根）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    LL ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果x比当前权值小，则说明答案都在左子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">&lt;</span> val(p)) p <span style="color:#f92672">=</span> lc(p);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//否则就是整个左子树、当前节点，和部分右子树
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//将左子树整个累加
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ret <span style="color:#f92672">+=</span> sz(lc(p));
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果找到了x所在节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">==</span> val(p)){
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//则把该节点旋转到根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                splay(p);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//此时的ret为比x小的元素个数，所以要加1后返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> ret <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//否则当前节点也在答案范围内
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            ret <span style="color:#f92672">+=</span> cnt(p);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//去右儿子更新答案
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            p <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">getkth</span>(LL x){  <span style="color:#75715e">//查询第x名的数（且将该数旋转到根）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//如果左儿子存在，且x比左儿子大小要小（或等于），则说明答案在左儿子内
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(lc(p) <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;=</span> sz(lc(p))) p <span style="color:#f92672">=</span> lc(p);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//否则就在当前节点，或者右子树内
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//先假设在右子树内
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            x <span style="color:#f92672">-=</span> sz(lc(p)) <span style="color:#f92672">+</span> cnt(p);
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//如果减之后比0小，则答案一定是当前节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//旋转到根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                splay(p);
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">//返回
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> val(p);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">//否则，就在右子树内
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            p <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">getpre</span>(LL x){  <span style="color:#75715e">//查询数x的前驱节点编号（且将前驱旋转到根，保证在调用前x一定存在于树中，且是作为根出现）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//保证是根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//先向左（走到左儿子内）一下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> lc(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果左儿子不存在，就说明无解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(p <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) exit(<span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//否则，无脑往右走（走到右儿子内）即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(rc(p)) p <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//直到没有右儿子的时候，就旋转
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    splay(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//并返回p节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">getnxt</span>(LL x){  <span style="color:#75715e">//查询数x的后继节点编号（且将后继旋转到根，保证在调用前x一定存在于树中，且是作为根出现）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//保证是根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//先向右（走到右儿子内）一下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    p <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果右儿子不存在，就说明无解
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(p <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) exit(<span style="color:#ae81ff">5</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//否则，无脑往左走（走到左儿子内）即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(lc(p)) p <span style="color:#f92672">=</span> lc(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//直到没有左儿子的时候，就旋转
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    splay(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//并返回p节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">del</span>(LL x){  <span style="color:#75715e">//删除数x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">//找到删除位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(true){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(p <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) exit(<span style="color:#ae81ff">6</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//找到了
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(val(p) <span style="color:#f92672">==</span> x) <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//继续跳儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        p <span style="color:#f92672">=</span> sons(p, x <span style="color:#f92672">&gt;</span> <span style="color:#75715e">/* 这里是大于 */</span> val(p));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//把删除位置旋转到根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    splay(p);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果有多于一个权值为x的
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(cnt(rt) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//则直接cnt--即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        cnt(rt)<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>        pushup(rt);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果根没有左右儿子（整棵树就只有rt一个点）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(lc(rt) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> rc(rt) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        delnode(rt);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果根只有左儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(rc(rt) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//则拿左儿子作为根，并删除原根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        LL t <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>        rt <span style="color:#f92672">=</span> lc(rt);
</span></span><span style="display:flex;"><span>        fa(rt) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        delnode(t);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果根只有右儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(lc(rt) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//则拿右儿子作为根，并删除原根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        LL t <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>        rt <span style="color:#f92672">=</span> rc(rt);
</span></span><span style="display:flex;"><span>        fa(rt) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        delnode(t);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//如果左右儿子都有
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//则把此时根节点的前驱旋转到根
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        LL t <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>        getpre(val(rt));
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//把旧根删掉即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//此时旧根t一定是新根rt的右儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//并且不可能存在权值在val(t)与val(rt)之间（不包括两端点val(t)和val(rt)的值）的节点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//这也就意味着此时t没有左儿子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//只用把右儿子连到新根上去即可
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        rc(rt) <span style="color:#f92672">=</span> rc(t);
</span></span><span style="display:flex;"><span>        fa(rc(rt)) <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>        fa(t) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">//为了防止在delnode的时候把此时的根（t的父亲rt）的某个儿子清零，这里要把t的父亲指向0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        delnode(t <span style="color:#75715e">/* BBE++，原为rt */</span>);
</span></span><span style="display:flex;"><span>        pushup(rt);  <span style="color:#75715e">//并更新此时rt的信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    rd(q);
</span></span><span style="display:flex;"><span>    rep(i, <span style="color:#ae81ff">1</span>, q){
</span></span><span style="display:flex;"><span>        rd(opt), rd(x);
</span></span><span style="display:flex;"><span>             <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) add(x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) del(x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>)         printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,     getrnk(x) )        ;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>)         printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,     getkth(x) )        ;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>) add(x), printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, val(getpre(x))), del(x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>              add(x), printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, val(getnxt(x))), del(x);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="text-stylecolorrgb0150136-区间操作查询"><text style="color:rgb(0,150,136)"> 区间操作、查询</h3>
<p>不过这还没完，上面说“Splay能解决更多种类的操作、查询”，而具体是哪些呢？其实就是对区间的操作。</p>
<p>比如，最经典的就是对一段区间做翻转。</p>
<p>此时，我们设操作区间为 $[l,r]$，我们就考虑把这段区间提取为一个子树。</p>
<p>一种可行的思路是，我们把 $l-1$ 旋转到根，把 $r+1$ 旋转到根的右儿子。</p>
<p>有人说，这一步直接把 $r+1$ 旋转到根，随后把 $l-1$ 旋转到根不就彳亍了吗？事实并非如此。</p>
<p>实测在绝大部分情况下，这样都不能正确的提取 $[l,r]$ 这段区间。</p>
<p>所以，我们只能变化一下<code>splay</code>操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">splay</span>(LL x, LL tar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>){  <span style="color:#75715e">//tar表示旋转到哪个点为止
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(LL fa <span style="color:#f92672">=</span> fa(x);fa <span style="color:#f92672">!=</span> tar;rotate(x), fa <span style="color:#f92672">=</span> fa(x))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(fa(fa) <span style="color:#f92672">!=</span> tar)
</span></span><span style="display:flex;"><span>            rotate(sp(x) <span style="color:#f92672">==</span> sp(fa) <span style="color:#f92672">?</span> fa : x);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(tar <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#75715e">/* 只有在tar=0的时候根节点才会变化 */</span> rt <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>具体调用可以看底下的代码。</p>
<p>于是，此时根节点的右儿子的左儿子，就是 $[l,r]$ 这段区间对应子树的根。</p>
<p>我们只要在这个根上打标记即可。</p>
<p>或者如果是询问，就访问其权值即可。</p>
<p>注意在引入标记后，必须要时刻记得<code>pushdown</code>。</p>
<h3 id="text-stylecolorrgb0150136-代码-5"><text style="color:rgb(0,150,136)"> 代码</h3>
<p>只有旋转：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">递交到</span>P3391即可AC
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> LL Q <span style="color:#f92672">=</span> <span style="color:#ae81ff">1e5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL n, q;
</span></span><span style="display:flex;"><span>LL l, r;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    LL val;
</span></span><span style="display:flex;"><span>    LL fa;
</span></span><span style="display:flex;"><span>    LL sons[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>    LL sz;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> rev;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define val(x) (a[x].val)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define fa(x) (a[x].fa)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define sons(x, p) (a[x].sons[p])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define lc(x) sons(x, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define rc(x) sons(x, 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define sz(x) (a[x].sz)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define rev(x) (a[x].rev)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Node a[Q];
</span></span><span style="display:flex;"><span>LL ind;
</span></span><span style="display:flex;"><span>LL rt;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define sp(x) (rc(fa(x)) == x)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define pushup(x) (sz(x) = sz(lc(x)) + 1 + sz(rc(x)))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LL <span style="color:#a6e22e">newnode</span>(LL v, LL fa){
</span></span><span style="display:flex;"><span>    ind<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    val(ind) <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>    fa(ind) <span style="color:#f92672">=</span> fa;
</span></span><span style="display:flex;"><span>    lc(ind) <span style="color:#f92672">=</span> rc(ind) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    sz(ind) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    rev(ind) <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ind;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">build</span>(LL l, LL r, LL fa){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l <span style="color:#f92672">&gt;</span> r) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    LL mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> (r <span style="color:#f92672">-</span> l) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    LL x <span style="color:#f92672">=</span> newnode(mid, fa);
</span></span><span style="display:flex;"><span>    lc(x) <span style="color:#f92672">=</span> build(l, mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, x), rc(x) <span style="color:#f92672">=</span> build(mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r, x);
</span></span><span style="display:flex;"><span>    pushup(x);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define lazy_rev(x) (swap(lc(x), rc(x)), rev(x) ^= 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pushdown</span>(LL x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(rev(x)){
</span></span><span style="display:flex;"><span>        lazy_rev(lc(x));
</span></span><span style="display:flex;"><span>        lazy_rev(rc(x));
</span></span><span style="display:flex;"><span>        rev(x) <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rotate</span>(LL x){
</span></span><span style="display:flex;"><span>    LL y <span style="color:#f92672">=</span> fa(x), z <span style="color:#f92672">=</span> fa(y), p <span style="color:#f92672">=</span> sp(x);
</span></span><span style="display:flex;"><span>    pushdown(z), pushdown(y), pushdown(x);
</span></span><span style="display:flex;"><span>    sons(y, p) <span style="color:#f92672">=</span> sons(x, <span style="color:#f92672">!</span>p), sons(x, <span style="color:#f92672">!</span>p) <span style="color:#f92672">=</span> y, fa(sons(y, p)) <span style="color:#f92672">=</span> y;
</span></span><span style="display:flex;"><span>    fa(x) <span style="color:#f92672">=</span> fa(y), fa(y) <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>    pushup(y), pushup(x);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(z){
</span></span><span style="display:flex;"><span>        sons(z, rc(z) <span style="color:#f92672">==</span> y) <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>        pushup(z);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">splay</span>(LL x, LL tar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>){  <span style="color:#75715e">//tar表示旋转到哪个点为止
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(LL fa <span style="color:#f92672">=</span> fa(x);fa <span style="color:#f92672">!=</span> tar;rotate(x), fa <span style="color:#f92672">=</span> fa(x))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(fa(fa) <span style="color:#f92672">!=</span> tar)
</span></span><span style="display:flex;"><span>            rotate(sp(x) <span style="color:#f92672">==</span> sp(fa) <span style="color:#f92672">?</span> fa : x);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(tar <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#75715e">/* 只有在tar=0的时候根节点才会变化 */</span> rt <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">getkth</span>(LL x){
</span></span><span style="display:flex;"><span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p){
</span></span><span style="display:flex;"><span>        pushdown(p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(lc(p) <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;=</span> sz(lc(p))) p <span style="color:#f92672">=</span> lc(p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            x <span style="color:#f92672">-=</span> sz(lc(p)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> p;  <span style="color:#75715e">//不用着急在这里splay，在主程序里有详细处理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            p <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(LL x){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    pushdown(x);
</span></span><span style="display:flex;"><span>    dfs(lc(x));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> val(x) <span style="color:#f92672">&amp;&amp;</span> val(x) <span style="color:#f92672">&lt;=</span> n) printf(<span style="color:#e6db74">&#34;%lld &#34;</span>, val(x));
</span></span><span style="display:flex;"><span>    dfs(rc(x));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    rd(n), rd(q);
</span></span><span style="display:flex;"><span>    build(<span style="color:#ae81ff">0</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    rt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    cir(q){
</span></span><span style="display:flex;"><span>        rd(l), rd(r);
</span></span><span style="display:flex;"><span>        LL vl <span style="color:#f92672">=</span> getkth((l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        splay(vl);
</span></span><span style="display:flex;"><span>        LL vr <span style="color:#f92672">=</span> getkth((r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        splay(vr, vl);
</span></span><span style="display:flex;"><span>        lazy_rev(lc(rc(rt)));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    dfs(rt);
</span></span><span style="display:flex;"><span>    puts(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>旋转、区间加、区间查询最大值：（重写的，函数化了，会更加好看一些）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">递交到</span>P4146即可AC
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> LL N <span style="color:#f92672">=</span> <span style="color:#ae81ff">5e4</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>LL n, q;
</span></span><span style="display:flex;"><span>LL opt;
</span></span><span style="display:flex;"><span>LL l, r, v;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
</span></span><span style="display:flex;"><span>    LL val;
</span></span><span style="display:flex;"><span>    LL fa;
</span></span><span style="display:flex;"><span>    LL sons[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>    LL sz;
</span></span><span style="display:flex;"><span>    LL ma;
</span></span><span style="display:flex;"><span>    LL add;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> rev;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define val(x) (a[x].val)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define fa(x) (a[x].fa)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define sons(x, p) (a[x].sons[p])
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define lc(x) sons(x, 0)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define rc(x) sons(x, 1)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define sz(x) (a[x].sz)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define ma(x) (a[x].ma)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define add(x) (a[x].add)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define rev(x) (a[x].rev)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Node a[N];
</span></span><span style="display:flex;"><span>LL ind;
</span></span><span style="display:flex;"><span>LL rt;
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define sp(x) (rc(fa(x)) == x)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define pushup(x) (sz(x) = sz(lc(x)) + 1 + sz(rc(x)), ma(x) = max({ma(lc(x)), val(x), ma(rc(x))}))
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rotate</span>(LL x){
</span></span><span style="display:flex;"><span>    LL y <span style="color:#f92672">=</span> fa(x), z <span style="color:#f92672">=</span> fa(y), p <span style="color:#f92672">=</span> sp(x);
</span></span><span style="display:flex;"><span>    sons(y, p) <span style="color:#f92672">=</span> sons(x, <span style="color:#f92672">!</span>p), sons(x, <span style="color:#f92672">!</span>p) <span style="color:#f92672">=</span> y, fa(sons(y, p)) <span style="color:#f92672">=</span> y;
</span></span><span style="display:flex;"><span>    fa(x) <span style="color:#f92672">=</span> fa(y), fa(y) <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>    pushup(y), pushup(x);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(z){
</span></span><span style="display:flex;"><span>        sons(z, rc(z) <span style="color:#f92672">==</span> y) <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>        pushup(z);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">splay</span>(LL x, LL tar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(LL fa <span style="color:#f92672">=</span> fa(x);fa <span style="color:#f92672">!=</span> tar;rotate(x), fa <span style="color:#f92672">=</span> fa(x))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(fa(fa) <span style="color:#f92672">!=</span> tar)
</span></span><span style="display:flex;"><span>            rotate(sp(x) <span style="color:#f92672">==</span> sp(fa) <span style="color:#f92672">?</span> fa : x);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(tar <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) rt <span style="color:#f92672">=</span> x;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">newnode</span>(LL v, LL fa){
</span></span><span style="display:flex;"><span>    ind<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    val(ind) <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>    fa(ind) <span style="color:#f92672">=</span> fa;
</span></span><span style="display:flex;"><span>    lc(ind) <span style="color:#f92672">=</span> rc(ind) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    sz(ind) <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    ma(ind) <span style="color:#f92672">=</span> v;
</span></span><span style="display:flex;"><span>    add(ind) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    rev(ind) <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ind;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">build</span>(LL l, LL r, LL fa){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(l <span style="color:#f92672">&gt;</span> r) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    LL mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> (r <span style="color:#f92672">-</span> l) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    LL cur <span style="color:#f92672">=</span> newnode(<span style="color:#ae81ff">0</span>, fa);
</span></span><span style="display:flex;"><span>    lc(cur) <span style="color:#f92672">=</span> build(l, mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, cur);
</span></span><span style="display:flex;"><span>    rc(cur) <span style="color:#f92672">=</span> build(mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r, cur);
</span></span><span style="display:flex;"><span>    pushup(cur);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> cur;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">upd_lazy</span>(LL x, LL add, <span style="color:#66d9ef">bool</span> rev){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(add){
</span></span><span style="display:flex;"><span>        val(x) <span style="color:#f92672">+=</span> add;
</span></span><span style="display:flex;"><span>        ma(x) <span style="color:#f92672">+=</span> add;
</span></span><span style="display:flex;"><span>        add(x) <span style="color:#f92672">+=</span> add;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(rev){
</span></span><span style="display:flex;"><span>        swap(lc(x), rc(x));
</span></span><span style="display:flex;"><span>        rev(x) <span style="color:#f92672">^=</span> rev;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pushdown</span>(LL x){
</span></span><span style="display:flex;"><span>    upd_lazy(lc(x), add(x), rev(x));
</span></span><span style="display:flex;"><span>    upd_lazy(rc(x), add(x), rev(x));
</span></span><span style="display:flex;"><span>    add(x) <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, rev(x) <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">getkth</span>(LL x){
</span></span><span style="display:flex;"><span>    LL p <span style="color:#f92672">=</span> rt;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(p){
</span></span><span style="display:flex;"><span>        pushdown(p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(lc(p) <span style="color:#f92672">&amp;&amp;</span> x <span style="color:#f92672">&lt;=</span> sz(lc(p))) p <span style="color:#f92672">=</span> lc(p);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            x <span style="color:#f92672">-=</span> sz(lc(p)) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(x <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>            p <span style="color:#f92672">=</span> rc(p);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">lock_range</span>(LL l, LL r){
</span></span><span style="display:flex;"><span>    LL xl <span style="color:#f92672">=</span> getkth((l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    splay(xl);
</span></span><span style="display:flex;"><span>    LL xr <span style="color:#f92672">=</span> getkth((r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    splay(xr, xl);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> lc(rc(rt));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_range</span>(LL l, LL r, LL v){
</span></span><span style="display:flex;"><span>    upd_lazy(lock_range(l, r), v, false);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rev_range</span>(LL l, LL r){
</span></span><span style="display:flex;"><span>    upd_lazy(lock_range(l, r), <span style="color:#ae81ff">0</span>, true);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>LL <span style="color:#a6e22e">max_range</span>(LL l, LL r){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ma(lock_range(l, r));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">solve</span>(){
</span></span><span style="display:flex;"><span>    rd(n), rd(q);
</span></span><span style="display:flex;"><span>    ma(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>INF;  <span style="color:#75715e">//这里要把0节点的ma值设为-INF，防止权值为负，且某个儿子不存在（为0）的情况
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    build(<span style="color:#ae81ff">0</span>, n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    rt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    cir(q){
</span></span><span style="display:flex;"><span>        rd(opt);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) rd(l), rd(r), rd(v), add_range(l, r, v);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(opt <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) rd(l), rd(r), rev_range(l, r);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> rd(l), rd(r), printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, max_range(l, r));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
        
    </div>

    <div class="prev-next">
        
    </div>

    
    
    
</div>

<aside class="post-toc">
    <nav id="toc">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#text-stylecolorrgb0150136-定义"><text style="color:rgb(0,150,136)"> 定义</a></li>
    <li><a href="#text-stylecolorrgb0150136-种类"><text style="color:rgb(0,150,136)"> 种类</a>
      <ul>
        <li><a href="#text-stylecolorrgb0150136-二叉搜索树binary-search-tree简称bst"><text style="color:rgb(0,150,136)"> 二叉搜索树（Binary Search Tree，简称BST）</a></li>
        <li><a href="#text-stylecolorrgb0150136-treap名字不是一个单词而是两个单词tree和heap的结合"><text style="color:rgb(0,150,136)"> Treap（名字不是一个单词，而是两个单词Tree和Heap的结合）</a></li>
        <li><a href="#text-stylecolorrgb0150136-splay本意为张开但这里不是这个意思"><text style="color:rgb(0,150,136)"> Splay（本意为“张开”但这里不是这个意思）</a></li>
      </ul>
    </li>
    <li><a href="#text-stylecolorrgb0150136-依次讲解"><text style="color:rgb(0,150,136)"> 依次讲解</a>
      <ul>
        <li><a href="#text-stylecolorrgb0150136-解决题型"><text style="color:rgb(0,150,136)"> 解决题型</a></li>
        <li><a href="#text-stylecolorrgb0150136-权值线段树"><text style="color:rgb(0,150,136)"> 权值线段树</a>
          <ul>
            <li><a href="#text-stylecolorrgb0150136-代码"><text style="color:rgb(0,150,136)"> 代码</a></li>
          </ul>
        </li>
        <li><a href="#text-stylecolorrgb0150136-动态开点权值线段树"><text style="color:rgb(0,150,136)"> 动态开点权值线段树</a>
          <ul>
            <li><a href="#text-stylecolorrgb0150136-代码-1"><text style="color:rgb(0,150,136)"> 代码</a></li>
          </ul>
        </li>
        <li><a href="#text-stylecolorrgb0150136-二叉搜索树"><text style="color:rgb(0,150,136)"> 二叉搜索树</a>
          <ul>
            <li><a href="#text-stylecolorrgb0150136-概览"><text style="color:rgb(0,150,136)"> 概览</a></li>
            <li><a href="#text-stylecolorrgb0150136-初始化"><text style="color:rgb(0,150,136)"> 初始化</a></li>
            <li><a href="#text-stylecolorrgb0150136-插入节点"><text style="color:rgb(0,150,136)"> 插入节点</a></li>
            <li><a href="#text-stylecolorrgb0150136-删除节点"><text style="color:rgb(0,150,136)"> 删除节点</a></li>
            <li><a href="#text-stylecolorrgb0150136-其他四种操作"><text style="color:rgb(0,150,136)"> 其他四种操作</a></li>
            <li><a href="#text-stylecolorrgb0150136-复杂度证明"><text style="color:rgb(0,150,136)"> 复杂度证明</a></li>
            <li><a href="#text-stylecolorrgb0150136-定期重构"><text style="color:rgb(0,150,136)"> 定期重构</a></li>
            <li><a href="#text-stylecolorrgb0150136-代码-2"><text style="color:rgb(0,150,136)"> 代码</a></li>
          </ul>
        </li>
        <li><a href="#text-stylecolorrgb0150136-treap"><text style="color:rgb(0,150,136)"> Treap</a>
          <ul>
            <li><a href="#text-stylecolorrgb0150136-概览-1"><text style="color:rgb(0,150,136)"> 概览</a></li>
            <li><a href="#text-stylecolorrgb0150136-旋转"><text style="color:rgb(0,150,136)"> 旋转</a></li>
            <li><a href="#text-stylecolorrgb0150136-插入"><text style="color:rgb(0,150,136)"> 插入</a></li>
            <li><a href="#text-stylecolorrgb0150136-删除"><text style="color:rgb(0,150,136)"> 删除</a></li>
            <li><a href="#text-stylecolorrgb0150136-其他四种操作-1"><text style="color:rgb(0,150,136)"> 其他四种操作</a></li>
            <li><a href="#text-stylecolorrgb0150136-复杂度"><text style="color:rgb(0,150,136)"> 复杂度</a></li>
            <li><a href="#text-stylecolorrgb0150136-代码-3"><text style="color:rgb(0,150,136)"> 代码</a></li>
          </ul>
        </li>
        <li><a href="#text-stylecolorrgb0150136-splay"><text style="color:rgb(0,150,136)"> Splay</a>
          <ul>
            <li><a href="#text-stylecolorrgb0150136-概览-2"><text style="color:rgb(0,150,136)"> 概览</a></li>
            <li><a href="#text-stylecolorrgb0150136-旋转-1"><text style="color:rgb(0,150,136)"> 旋转</a></li>
            <li><a href="#text-stylecolorrgb0150136-插入-1"><text style="color:rgb(0,150,136)"> 插入</a></li>
            <li><a href="#text-stylecolorrgb0150136-查询x的排名"><text style="color:rgb(0,150,136)"> 查询x的排名</a></li>
            <li><a href="#text-stylecolorrgb0150136-查询排名为x的数"><text style="color:rgb(0,150,136)"> 查询排名为x的数</a></li>
            <li><a href="#text-stylecolorrgb0150136-查询x的前驱"><text style="color:rgb(0,150,136)"> 查询x的前驱</a></li>
            <li><a href="#text-stylecolorrgb0150136-查询x的后继"><text style="color:rgb(0,150,136)"> 查询x的后继</a></li>
            <li><a href="#text-stylecolorrgb0150136-删除-1"><text style="color:rgb(0,150,136)"> 删除</a></li>
            <li><a href="#text-stylecolorrgb0150136-复杂度-1"><text style="color:rgb(0,150,136)"> 复杂度</a></li>
            <li><a href="#text-stylecolorrgb0150136-代码-4"><text style="color:rgb(0,150,136)"> 代码</a></li>
            <li><a href="#text-stylecolorrgb0150136-区间操作查询"><text style="color:rgb(0,150,136)"> 区间操作、查询</a></li>
            <li><a href="#text-stylecolorrgb0150136-代码-5"><text style="color:rgb(0,150,136)"> 代码</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
    </nav>
</aside>



    

        </main><footer class="footer">
    
    

    

    

    

    <span>
        Made with &#10084;&#65039; using <a target="_blank" href="https://github.com/gokarna-theme/gokarna-hugo">Gokarna</a>
    </span>
</footer>
</body>
</html>
